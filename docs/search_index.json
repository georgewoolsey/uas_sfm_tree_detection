[["index.html", "UAS-SfM Software Tree Detection Comparison Section 1 Introduction", " UAS-SfM Software Tree Detection Comparison George Woolsey 11 October, 2024 Section 1 Introduction Code in support of “Influence of Structure from Motion Algorithm Parameters on Metrics of Individual Tree Detection Accuracy and Precision” published by Remote Sensing, 2024, XX, xx-xx (https://www.mdpi.com/journal/remotesensing) "],["objective.html", "Section 2 Objective", " Section 2 Objective Characterizing forest attributes from imagery collected via UAS platforms and processed using structure from motion (SfM) photogrammetry is among the most widely tested and affordable remote sensing approaches to describe 3-dimensional forest attributes. This study compares the accuracy and precision of individual tree detection against the range of SfM parameters available in two commercial (Agisoft Metashape and Pix4DMapper) and one open-source algorithm (OpenDroneMap). "],["data.html", "Section 3 Data", " Section 3 Data Five ponderosa pine (Pinus ponderosa) dominated sites with 100% census field stem-mapped inventories were used to evaluate how SfM algorithm parameters impact individual tree detection and resulting stand basal area estimates compared to field-based measurements. UAS flights from the following forests were included: the Manitou Experimental Forest on the Pike-San Isabel National Forest (Colorado; “N1”), the Black Hills Experimental Forest on the Black Hills National Forest (South Dakota; “SQ09_02”, “WA85_02”), and the Lookout Canyon area in the Kaibab National Forest (Arizona; “Kaibab_High”, “Kaibab_Low”). "],["ptcld_analysis.html", "Section 4 Point Cloud Generation and Processing 4.1 SfM Image Processing Data 4.2 R Point Cloud Processing Data 4.3 Summary of Data Generation and Processing", " Section 4 Point Cloud Generation and Processing 4.1 SfM Image Processing Data We tracked the photogrammetry (SfM) data generation processing times across the software platforms. Bring in this data and combine it as it has slightly different structure. The softwares were all run on different machines which means we need to figure out a way to standardize the image processing time to compare across software load the Excel file with ODM and Pix4D odm_pix_temp = readr::read_csv(&quot;../data/sfm_processing_time.csv&quot;) %&gt;% dplyr::rename_with(~ .x %&gt;% stringr::str_squish() %&gt;% str_remove_all(&quot;[[:punct:]]&quot;) %&gt;% stringr::str_replace_all(&quot;\\\\s&quot;,&quot;_&quot;) %&gt;% tolower() ) %&gt;% # map the processing parameters to the columns in our current data str dplyr::mutate( software = software %&gt;% stringr::str_remove_all(&quot;\\\\s&quot;) %&gt;% toupper() , processing_attribute1 = dplyr::case_when( software == &quot;PIX4D&quot; ~ keypoint_image_scale , T ~ depth_map_quality ) , processing_attribute2 = dplyr::case_when( software == &quot;PIX4D&quot; ~ depth_map_quality , T ~ filtering_mode ) , processing_attribute3 = dplyr::case_when( software == &quot;PIX4D&quot; ~ filtering_mode , T ~ as.character(NA) ) ) %&gt;% # clean the data dplyr::mutate( dplyr::across( tidyselect::starts_with(&quot;processing_attribute&quot;) , ~ .x %&gt;% stringr::str_remove_all(&quot;\\\\s&quot;) %&gt;% toupper() ) , site = site %&gt;% stringr::str_squish() %&gt;% stringr::str_replace_all(&quot;\\\\s&quot;,&quot;_&quot;) %&gt;% stringr::str_replace_all(&quot;[^[:alnum:]]&quot;,&quot;_&quot;) %&gt;% toupper() ) %&gt;% # filter pix4d for only original dplyr::filter( dplyr::case_when( tolower(software) == &quot;pix4d&quot; &amp; tolower(processing_attribute1) == &quot;original&quot; ~ T , tolower(software) != &quot;pix4d&quot; ~ T , T ~ F ) == T ) %&gt;% dplyr::mutate( # temporary qqq = dplyr::case_when( tolower(software) == &quot;pix4d&quot; ~ processing_attribute2 , T ~ processing_attribute1 ) , fff = dplyr::case_when( tolower(software) == &quot;pix4d&quot; ~ processing_attribute3 , T ~ processing_attribute2 ) ) %&gt;% dplyr::rename( study_site = site , total_sfm_time_min = total_generation_time_min , number_of_points_sfm = pc_total_number ) %&gt;% # select columns we need for joining dplyr::select( software , study_site , total_sfm_time_min , number_of_points_sfm , qqq , fff ) clean up the metashape image processing data and combine with odm and pix4d # clean up the metashape image processing data and combine with odm and pix4d ms_temp = readr::read_csv(&quot;../data/metashape_processing_data.csv&quot;) sfm_comb_temp = ms_temp %&gt;% dplyr::mutate( software = toupper(&quot;metashape&quot;) , total_sfm_time_min = total_dense_point_cloud_processing_time_mins + total_sparse_point_cloud_processing_time_mins , number_of_points_sfm = dense_point_cloud_points , qqq = depth_maps_generation_quality , fff = depth_maps_generation_filtering_mode ) %&gt;% dplyr::select(names(odm_pix_temp)) %&gt;% dplyr::bind_rows(odm_pix_temp) %&gt;% # map quality and filtering to match above dplyr::mutate( # mapping depth_maps_generation_quality = dplyr::case_when( tolower(qqq) %in% c(&quot;ultrahigh&quot;, &quot;ultra&quot;, &quot;original&quot;, &quot;origianl&quot;) ~ &quot;ultra high&quot; , tolower(qqq) %in% c(&quot;half&quot;) ~ &quot;high&quot; , tolower(qqq) %in% c(&quot;quarter&quot;) ~ &quot;medium&quot; , tolower(qqq) %in% c(&quot;eighth&quot;,&quot;eightht&quot;) ~ &quot;low&quot; , T ~ tolower(qqq) ) %&gt;% factor( ordered = TRUE , levels = c( &quot;lowest&quot; , &quot;low&quot; , &quot;medium&quot; , &quot;high&quot; , &quot;ultra high&quot; ) ) %&gt;% forcats::fct_rev() , depth_maps_generation_filtering_mode = dplyr::case_when( tolower(fff) %in% c(&quot;high&quot;) &amp; tolower(software) %in% c(&quot;opendronemap&quot;) ~ &quot;disabled&quot; , tolower(fff) %in% c(&quot;high&quot;) &amp; tolower(software) %in% c(&quot;pix4d&quot;) ~ &quot;disabled&quot; , tolower(fff) %in% c(&quot;medium&quot;) &amp; tolower(software) %in% c(&quot;opendronemap&quot;) ~ &quot;mild&quot; , tolower(fff) %in% c(&quot;optimal&quot;) &amp; tolower(software) %in% c(&quot;pix4d&quot;) ~ &quot;mild&quot; , tolower(fff) %in% c(&quot;low&quot;) &amp; tolower(software) %in% c(&quot;opendronemap&quot;) ~ &quot;moderate&quot; , tolower(fff) %in% c(&quot;low&quot;) &amp; tolower(software) %in% c(&quot;pix4d&quot;) ~ &quot;moderate&quot; , tolower(fff) %in% c(&quot;lowest&quot;) &amp; tolower(software) %in% c(&quot;opendronemap&quot;) ~ &quot;aggressive&quot; , T ~ tolower(fff) ) %&gt;% factor( ordered = TRUE , levels = c( &quot;disabled&quot; , &quot;mild&quot; , &quot;moderate&quot; , &quot;aggressive&quot; ) ) %&gt;% forcats::fct_rev() ) %&gt;% dplyr::select(-c(qqq,fff)) %&gt;% # keep only one thing record dplyr::group_by( software, study_site, depth_maps_generation_quality, depth_maps_generation_filtering_mode ) %&gt;% dplyr::filter(dplyr::row_number()==1) %&gt;% dplyr::ungroup() What? sfm_comb_temp %&gt;% dplyr::glimpse() ## Rows: 342 ## Columns: 6 ## $ software &lt;chr&gt; &quot;METASHAPE&quot;, &quot;METASHAPE&quot;, &quot;METASH… ## $ study_site &lt;chr&gt; &quot;KAIBAB_HIGH&quot;, &quot;KAIBAB_HIGH&quot;, &quot;KA… ## $ total_sfm_time_min &lt;dbl&gt; 209.600000, 232.600000, 206.60000… ## $ number_of_points_sfm &lt;dbl&gt; 225918417, 305690646, 295828394, … ## $ depth_maps_generation_quality &lt;ord&gt; ultra high, ultra high, ultra hig… ## $ depth_maps_generation_filtering_mode &lt;ord&gt; aggressive, moderate, mild, disab… 4.2 R Point Cloud Processing Data The point cloud files (.las|.laz files) exported by the SfM software platforms (Metashape, Pix4D, and OpenDroneMap) were processed in R using the process outlined in the manuscript and implemented via the cloud2trees() function from the cloud2trees package by Woolsey and Tinkham (2024). This process was completed for all 260 data sets to be analyzed based on the different combinations of SfM parameter settings tested (100 from both Metashape and OpenDroneMap and 60 from Pix4D). We saved the processed data in the directory which we call ptcld_processing_dir in the code below organized as ptcld_processing_dir/software/study_site/parameter1_parameter2.csv where parameter1 and parameter2 are the SfM algorithm parameter settings (e.g. dense cloud generation quality and filtering mode). The processing tracking data file is used to compare summary statistics on point cloud processing times and densities. For comparison across software, the SfM point cloud generation processing parameters are mapped to the Metashape parameters based on the Pix4D documentation, the OpenDroneMap documentation, and the Agisoft Metashape discussion board ### get tracking data # read list of all processed tracking files tracking_list_df = dplyr::tibble( file_full_path = list.files( ptcld_processing_dir , pattern = &quot;.*_processed_tracking_data\\\\.csv$&quot; , full.names = T, recursive = T ) %&gt;% normalizePath() ) %&gt;% # get the software used dplyr::mutate( file_full_path %&gt;% toupper() %&gt;% stringr::str_extract_all(pattern = paste(toupper(software_list),collapse = &quot;|&quot;), simplify = T) %&gt;% dplyr::as_tibble() %&gt;% tidyr::unite(col = &quot;software&quot;, sep = &quot; &quot;, na.rm = T) ) %&gt;% # filter processed tracking files dplyr::mutate( software = software %&gt;% stringr::word(-1) , study_site = file_full_path %&gt;% toupper() %&gt;% stringr::str_extract(pattern = paste(toupper(study_site_list),collapse = &quot;|&quot;)) , file_name = file_full_path %&gt;% basename() %&gt;% stringr::word(1, sep = fixed(&quot;.&quot;)) %&gt;% toupper() %&gt;% stringr::str_remove_all(&quot;_PROCESSED_TRACKING_DATA&quot;) ) %&gt;% dplyr::filter( !is.na(study_site) &amp; study_site %in% toupper(study_site_list) &amp; !is.na(software) &amp; software %in% toupper(software_list) ) %&gt;% # keep only unique files for processing dplyr::group_by(software, study_site, file_name) %&gt;% dplyr::filter(dplyr::row_number()==1) %&gt;% dplyr::ungroup() %&gt;% dplyr::rename(tracking_file_full_path = file_full_path) What? Here, there are 500 files because we also created data using image alignment other than “Original” in Pix4D but keep only the “Original” files for final analysis. tracking_list_df %&gt;% dplyr::glimpse() ## Rows: 500 ## Columns: 4 ## $ tracking_file_full_path &lt;chr&gt; &quot;E:\\\\SfM_Software_Comparison\\\\Metashape\\\\point… ## $ software &lt;chr&gt; &quot;METASHAPE&quot;, &quot;METASHAPE&quot;, &quot;METASHAPE&quot;, &quot;METASH… ## $ study_site &lt;chr&gt; &quot;KAIBAB_HIGH&quot;, &quot;KAIBAB_HIGH&quot;, &quot;KAIBAB_HIGH&quot;, &quot;… ## $ file_name &lt;chr&gt; &quot;HIGH_AGGRESSIVE&quot;, &quot;HIGH_DISABLED&quot;, &quot;HIGH_MILD… read each tracking data file, bind rows # read each tracking data file, bind rows ptcld_processing_data = 1:nrow(tracking_list_df) %&gt;% purrr::map(function(row_n){ tracking_list_df %&gt;% dplyr::filter(dplyr::row_number() == row_n) %&gt;% dplyr::bind_cols( read.csv(tracking_list_df$tracking_file_full_path[row_n]) ) }) %&gt;% dplyr::bind_rows() What? ptcld_processing_data %&gt;% dplyr::glimpse() ## Rows: 500 ## Columns: 26 ## $ tracking_file_full_path &lt;chr&gt; &quot;E:\\\\SfM_Software_Comparison\\\\Metas… ## $ software &lt;chr&gt; &quot;METASHAPE&quot;, &quot;METASHAPE&quot;, &quot;METASHAP… ## $ study_site &lt;chr&gt; &quot;KAIBAB_HIGH&quot;, &quot;KAIBAB_HIGH&quot;, &quot;KAIB… ## $ file_name &lt;chr&gt; &quot;HIGH_AGGRESSIVE&quot;, &quot;HIGH_DISABLED&quot;,… ## $ number_of_points &lt;int&gt; 52974294, 72549206, 69858217, 69825… ## $ las_area_m2 &lt;dbl&gt; 86661.27, 87175.42, 86404.78, 86413… ## $ timer_tile_time_mins &lt;dbl&gt; 0.63600698, 2.49318542, 0.84133803,… ## $ timer_class_dtm_norm_chm_time_mins &lt;dbl&gt; 3.6559556, 5.3289152, 5.1638296, 5.… ## $ timer_treels_time_mins &lt;dbl&gt; 8.9065272, 19.2119663, 12.3391793, … ## $ timer_itd_time_mins &lt;dbl&gt; 0.02202115, 0.02449968, 0.03798440,… ## $ timer_competition_time_mins &lt;dbl&gt; 0.10590740, 0.17865245, 0.12124869,… ## $ timer_estdbh_time_mins &lt;dbl&gt; 0.02290262, 0.02382533, 0.02199170,… ## $ timer_silv_time_mins &lt;dbl&gt; 0.012565533, 0.015940932, 0.0150339… ## $ timer_total_time_mins &lt;dbl&gt; 13.361886, 27.276985, 18.540606, 17… ## $ sttng_input_las_dir &lt;chr&gt; &quot;D:/Metashape_Testing_2024&quot;, &quot;D:/Me… ## $ sttng_use_parallel_processing &lt;lgl&gt; FALSE, FALSE, FALSE, FALSE, FALSE, … ## $ sttng_desired_chm_res &lt;dbl&gt; 0.25, 0.25, 0.25, 0.25, 0.25, 0.25,… ## $ sttng_max_height_threshold_m &lt;int&gt; 60, 60, 60, 60, 60, 60, 60, 60, 60,… ## $ sttng_minimum_tree_height_m &lt;int&gt; 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,… ## $ sttng_dbh_max_size_m &lt;int&gt; 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,… ## $ sttng_local_dbh_model &lt;chr&gt; &quot;rf&quot;, &quot;rf&quot;, &quot;rf&quot;, &quot;rf&quot;, &quot;rf&quot;, &quot;rf&quot;,… ## $ sttng_user_supplied_epsg &lt;lgl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA,… ## $ sttng_accuracy_level &lt;int&gt; 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,… ## $ sttng_pts_m2_for_triangulation &lt;int&gt; 20, 20, 20, 20, 20, 20, 20, 20, 20,… ## $ sttng_normalization_with &lt;chr&gt; &quot;triangulation&quot;, &quot;triangulation&quot;, &quot;… ## $ sttng_competition_buffer_m &lt;int&gt; 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,… split file name to get processing attributes # split file name to get processing attributes ptcld_processing_data = ptcld_processing_data %&gt;% tidyr::separate_wider_delim( cols = file_name , delim = &quot;_&quot; , names = paste0( &quot;processing_attribute&quot; , 1:(max(stringr::str_count(ptcld_processing_data$file_name, &quot;_&quot;))+1) ) , too_few = &quot;align_start&quot; , cols_remove = F ) %&gt;% # not sure how to map processing attributes for pix4d and opendronemap ?????????????? dplyr::mutate( # temporary qqq = dplyr::case_when( tolower(software) == &quot;pix4d&quot; ~ processing_attribute2 , T ~ processing_attribute1 ) , fff = dplyr::case_when( tolower(software) == &quot;pix4d&quot; ~ processing_attribute3 , T ~ processing_attribute2 ) # mapping , depth_maps_generation_quality = dplyr::case_when( tolower(qqq) %in% c(&quot;ultrahigh&quot;, &quot;ultra&quot;, &quot;original&quot;, &quot;origianl&quot;) ~ &quot;ultra high&quot; , tolower(qqq) %in% c(&quot;half&quot;) ~ &quot;high&quot; , tolower(qqq) %in% c(&quot;quarter&quot;) ~ &quot;medium&quot; , tolower(qqq) %in% c(&quot;eighth&quot;,&quot;eightht&quot;) ~ &quot;low&quot; , T ~ tolower(qqq) ) %&gt;% factor( ordered = TRUE , levels = c( &quot;lowest&quot; , &quot;low&quot; , &quot;medium&quot; , &quot;high&quot; , &quot;ultra high&quot; ) ) %&gt;% forcats::fct_rev() , depth_maps_generation_filtering_mode = dplyr::case_when( tolower(fff) %in% c(&quot;high&quot;) &amp; tolower(software) %in% c(&quot;opendronemap&quot;) ~ &quot;disabled&quot; , tolower(fff) %in% c(&quot;high&quot;) &amp; tolower(software) %in% c(&quot;pix4d&quot;) ~ &quot;disabled&quot; , tolower(fff) %in% c(&quot;medium&quot;) &amp; tolower(software) %in% c(&quot;opendronemap&quot;) ~ &quot;mild&quot; , tolower(fff) %in% c(&quot;optimal&quot;) &amp; tolower(software) %in% c(&quot;pix4d&quot;) ~ &quot;mild&quot; , tolower(fff) %in% c(&quot;low&quot;) &amp; tolower(software) %in% c(&quot;opendronemap&quot;) ~ &quot;moderate&quot; , tolower(fff) %in% c(&quot;low&quot;) &amp; tolower(software) %in% c(&quot;pix4d&quot;) ~ &quot;moderate&quot; , tolower(fff) %in% c(&quot;lowest&quot;) &amp; tolower(software) %in% c(&quot;opendronemap&quot;) ~ &quot;aggressive&quot; , T ~ tolower(fff) ) %&gt;% factor( ordered = TRUE , levels = c( &quot;disabled&quot; , &quot;mild&quot; , &quot;moderate&quot; , &quot;aggressive&quot; ) ) %&gt;% forcats::fct_rev() ) what have we done? ptcld_processing_data %&gt;% dplyr::glimpse() ## Rows: 500 ## Columns: 33 ## $ tracking_file_full_path &lt;chr&gt; &quot;E:\\\\SfM_Software_Comparison\\\\Met… ## $ software &lt;chr&gt; &quot;METASHAPE&quot;, &quot;METASHAPE&quot;, &quot;METASH… ## $ study_site &lt;chr&gt; &quot;KAIBAB_HIGH&quot;, &quot;KAIBAB_HIGH&quot;, &quot;KA… ## $ processing_attribute1 &lt;chr&gt; &quot;HIGH&quot;, &quot;HIGH&quot;, &quot;HIGH&quot;, &quot;HIGH&quot;, &quot;… ## $ processing_attribute2 &lt;chr&gt; &quot;AGGRESSIVE&quot;, &quot;DISABLED&quot;, &quot;MILD&quot;,… ## $ processing_attribute3 &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, N… ## $ file_name &lt;chr&gt; &quot;HIGH_AGGRESSIVE&quot;, &quot;HIGH_DISABLED… ## $ number_of_points &lt;int&gt; 52974294, 72549206, 69858217, 698… ## $ las_area_m2 &lt;dbl&gt; 86661.27, 87175.42, 86404.78, 864… ## $ timer_tile_time_mins &lt;dbl&gt; 0.63600698, 2.49318542, 0.8413380… ## $ timer_class_dtm_norm_chm_time_mins &lt;dbl&gt; 3.6559556, 5.3289152, 5.1638296, … ## $ timer_treels_time_mins &lt;dbl&gt; 8.9065272, 19.2119663, 12.3391793… ## $ timer_itd_time_mins &lt;dbl&gt; 0.02202115, 0.02449968, 0.0379844… ## $ timer_competition_time_mins &lt;dbl&gt; 0.10590740, 0.17865245, 0.1212486… ## $ timer_estdbh_time_mins &lt;dbl&gt; 0.02290262, 0.02382533, 0.0219917… ## $ timer_silv_time_mins &lt;dbl&gt; 0.012565533, 0.015940932, 0.01503… ## $ timer_total_time_mins &lt;dbl&gt; 13.361886, 27.276985, 18.540606, … ## $ sttng_input_las_dir &lt;chr&gt; &quot;D:/Metashape_Testing_2024&quot;, &quot;D:/… ## $ sttng_use_parallel_processing &lt;lgl&gt; FALSE, FALSE, FALSE, FALSE, FALSE… ## $ sttng_desired_chm_res &lt;dbl&gt; 0.25, 0.25, 0.25, 0.25, 0.25, 0.2… ## $ sttng_max_height_threshold_m &lt;int&gt; 60, 60, 60, 60, 60, 60, 60, 60, 6… ## $ sttng_minimum_tree_height_m &lt;int&gt; 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, … ## $ sttng_dbh_max_size_m &lt;int&gt; 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, … ## $ sttng_local_dbh_model &lt;chr&gt; &quot;rf&quot;, &quot;rf&quot;, &quot;rf&quot;, &quot;rf&quot;, &quot;rf&quot;, &quot;rf… ## $ sttng_user_supplied_epsg &lt;lgl&gt; NA, NA, NA, NA, NA, NA, NA, NA, N… ## $ sttng_accuracy_level &lt;int&gt; 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, … ## $ sttng_pts_m2_for_triangulation &lt;int&gt; 20, 20, 20, 20, 20, 20, 20, 20, 2… ## $ sttng_normalization_with &lt;chr&gt; &quot;triangulation&quot;, &quot;triangulation&quot;,… ## $ sttng_competition_buffer_m &lt;int&gt; 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, … ## $ qqq &lt;chr&gt; &quot;HIGH&quot;, &quot;HIGH&quot;, &quot;HIGH&quot;, &quot;HIGH&quot;, &quot;… ## $ fff &lt;chr&gt; &quot;AGGRESSIVE&quot;, &quot;DISABLED&quot;, &quot;MILD&quot;,… ## $ depth_maps_generation_quality &lt;ord&gt; high, high, high, high, low, low,… ## $ depth_maps_generation_filtering_mode &lt;ord&gt; aggressive, disabled, mild, moder… what is this mapping? # quality ptcld_processing_data %&gt;% dplyr::count(depth_maps_generation_quality, qqq, software) %&gt;% ggplot(aes(x = tolower(software), y = depth_maps_generation_quality, label = tolower(qqq))) + geom_tile(fill = NA, color = &quot;black&quot;) + ggrepel::geom_text_repel(color = &quot;gray33&quot;) + labs(y = &quot;Mapped: Depth Map Quality&quot;, x = &quot;&quot;) + scale_x_discrete(position = &quot;top&quot;) + coord_cartesian(expand = F) + theme_light() + theme( panel.grid = element_blank() , axis.text = element_text(size = 11, face = &quot;bold&quot;, color = &quot;black&quot;) , panel.border = element_rect(color = &quot;black&quot;) ) ggplot2::ggsave(&quot;../data/mapped_quality.jpg&quot;, height = 8, width = 6) notice the spelling errors in the file names…manual file naming can be a dangerous game to play. # filtering ptcld_processing_data %&gt;% dplyr::count(depth_maps_generation_filtering_mode, fff, software) %&gt;% ggplot(aes(x = tolower(software), y = depth_maps_generation_filtering_mode, label = tolower(fff))) + geom_tile(fill = NA, color = &quot;black&quot;) + ggrepel::geom_text_repel(color = &quot;gray33&quot;) + labs(y = &quot;Mapped: Filtering Mode&quot;, x = &quot;&quot;) + scale_x_discrete(position = &quot;top&quot;) + coord_cartesian(expand = F) + theme_light() + theme( panel.grid = element_blank() , axis.text = element_text(size = 11, face = &quot;bold&quot;, color = &quot;black&quot;) , panel.border = element_rect(color = &quot;black&quot;) ) ggplot2::ggsave(&quot;../data/mapped_filtering_mode.jpg&quot;, height = 8, width = 6) let’s filter out those extra Pix4D data sets ptcld_processing_data = ptcld_processing_data %&gt;% dplyr::select(-c(qqq,fff)) %&gt;% dplyr::filter( dplyr::case_when( tolower(software) == &quot;pix4d&quot; &amp; tolower(processing_attribute1) == &quot;original&quot; ~ T , tolower(software) != &quot;pix4d&quot; ~ T , T ~ F ) == T ) 4.3 Summary of Data Generation and Processing join the SfM data generation to the processing data which we’ll use to build our full analysis data set and create the normalized processing time using Min-Max normalization. ptcld_processing_data = ptcld_processing_data %&gt;% dplyr::left_join( sfm_comb_temp , by = dplyr::join_by( software, study_site, depth_maps_generation_quality, depth_maps_generation_filtering_mode ) ) %&gt;% # create the standardized time by software since the processing machine varied by software dplyr::group_by(software) %&gt;% dplyr::mutate( total_sfm_time_norm = (total_sfm_time_min-min(total_sfm_time_min, na.rm = T)) / (max(total_sfm_time_min, na.rm = T)-min(total_sfm_time_min, na.rm = T)) ) %&gt;% dplyr::ungroup() 4.3.1 Number of files summary ptcld_processing_data %&gt;% dplyr::count(software, depth_maps_generation_quality, depth_maps_generation_filtering_mode) %&gt;% ggplot(mapping = aes( y = depth_maps_generation_quality , x = depth_maps_generation_filtering_mode , fill = n , label = n )) + geom_tile(color = &quot;white&quot;) + geom_text(color = &quot;white&quot;, size = 3) + facet_grid(cols = vars(software)) + scale_x_discrete(expand = c(0, 0)) + scale_y_discrete(expand = c(0, 0)) + scale_fill_viridis_c(option = &quot;mako&quot;, direction=-1, begin = 0.2, end = 0.8) + labs( x = &quot;filtering mode&quot; , y = &quot;depth map quality&quot; , fill = &quot;number of sites&quot; ) + theme_light() + theme( legend.position = &quot;none&quot; , axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1) , panel.background = element_blank() , panel.grid = element_blank() , plot.subtitle = element_text(hjust = 0.5) , strip.text = element_text(color = &quot;black&quot;, face = &quot;bold&quot;) ) 4.3.2 R Processing Time Summary Total processing time by depth map generation quality and depth map filtering mode ptcld_processing_data %&gt;% ggplot( mapping = aes( x = depth_maps_generation_quality , y = timer_total_time_mins , color = depth_maps_generation_filtering_mode , fill = depth_maps_generation_filtering_mode ) ) + geom_boxplot(alpha = 0.6) + scale_color_viridis_d(option = &quot;plasma&quot;) + scale_fill_viridis_d(option = &quot;plasma&quot;) + scale_y_log10( labels = scales::comma_format(suffix = &quot; mins&quot;, accuracy = 1) , breaks = scales::breaks_log(n = 9) ) + labs( color = &quot;Filtering Mode&quot; , fill = &quot;Filtering Mode&quot; , y = &quot;Point Cloud Total Processing Time&quot; , x = &quot;Quality&quot; , title = bquote( bold(&quot;R&quot;) ~ &quot;point cloud total processing time by depth map generation quality and filtering mode&quot; ) , caption = &quot;*Note the log scale on the y-axis&quot; ) + theme_light() + theme( legend.position = &quot;top&quot; , legend.direction = &quot;horizontal&quot; ) + guides( color = guide_legend(override.aes = list(shape = 15, size = 6, alpha = 0.9)) ) Notice there are some outlier study sites in the point cloud processing time ptcld_processing_data %&gt;% ggplot( mapping = aes( y = timer_total_time_mins , x = depth_maps_generation_quality , color = depth_maps_generation_filtering_mode ) ) + geom_point(size = 3, alpha = 0.8) + facet_grid( cols = vars(study_site) , labeller = label_wrap_gen(width = 35, multi_line = TRUE) ) + scale_color_viridis_d(option = &quot;plasma&quot;) + scale_y_log10( labels = scales::comma_format(suffix = &quot; mins&quot;, accuracy = 1) , breaks = scales::breaks_log(n = 9) ) + labs( color = &quot;Filtering Mode&quot; , y = &quot;Point Cloud Total Processing Time&quot; , x = &quot;Quality&quot; , title = bquote( bold(&quot;R&quot;) ~ &quot;point cloud total processing time by depth map generation quality and filtering mode&quot; ) , subtitle = &quot;by Study Site&quot; , caption = &quot;*Note the log scale on the y-axis&quot; ) + theme_light() + theme( legend.position = &quot;top&quot; , legend.direction = &quot;horizontal&quot; , strip.text = element_text(color = &quot;black&quot;, face = &quot;bold&quot;) , axis.text.x = element_text(angle = 90) ) + guides( color = guide_legend(override.aes = list(shape = 15, size = 6, alpha = 0.9)) ) 4.3.3 R Processing Time vs # Points ptcld_processing_data %&gt;% ggplot( mapping = aes( x = number_of_points , y = timer_total_time_mins ) ) + geom_point(alpha = 0.7, color = &quot;navy&quot;) + scale_y_log10( labels = scales::comma_format(suffix = &quot; mins&quot;, accuracy = 1) , breaks = scales::breaks_log(n = 9) ) + scale_x_log10( labels = scales::comma_format(suffix = &quot; M&quot;, scale = 1e-6, accuracy = 1) , breaks = scales::breaks_log(n = 6) ) + labs( y = &quot;Point Cloud Total Processing Time&quot; , x = &quot;Dense Point Cloud # Points&quot; , title = bquote( bold(&quot;R&quot;) ~ &quot;point cloud total processing time versus dense point cloud number of points&quot; ) , caption = &quot;*Note the log scale on both axes&quot; ) + theme_light() 4.3.4 R Processing Section Timing ptcld_processing_data %&gt;% dplyr::select( depth_maps_generation_quality , tidyselect::ends_with(&quot;_mins&quot;) ) %&gt;% dplyr::select(-c(timer_total_time_mins)) %&gt;% tidyr::pivot_longer( cols = -c(depth_maps_generation_quality) , names_to = &quot;section&quot; , values_to = &quot;mins&quot; ) %&gt;% # dplyr::count(depth_maps_generation_quality, section) dplyr::group_by(depth_maps_generation_quality, section) %&gt;% dplyr::summarise(med_mins = median(mins)) %&gt;% dplyr::group_by(depth_maps_generation_quality) %&gt;% dplyr::mutate( total_mins = sum(med_mins) , pct_mins = med_mins/total_mins ) %&gt;% dplyr::ungroup() %&gt;% dplyr::mutate( section = section %&gt;% stringr::str_remove_all(&quot;timer_&quot;) %&gt;% stringr::str_remove_all(&quot;_time_mins&quot;) %&gt;% factor( ordered = T , levels = c( &quot;tile&quot; , &quot;class_dtm_norm_chm&quot; , &quot;treels&quot; , &quot;itd&quot; , &quot;estdbh&quot; , &quot;competition&quot; , &quot;silv&quot; ## olde # &quot;tile&quot; # , &quot;denoise&quot; # , &quot;classify&quot; # , &quot;dtm&quot; # , &quot;normalize&quot; # , &quot;chm&quot; # , &quot;treels&quot; # , &quot;itd&quot; # , &quot;estdbh&quot; # , &quot;competition&quot; # , &quot;silv&quot; ) , labels = c( &quot;Tile&quot; , &quot;Classify+Denoise+DTM+Normalize+CHM&quot; , &quot;TreeLS SfM DBH&quot; , &quot;CHM I.T.D.&quot; , &quot;Local DBH Est.&quot; , &quot;Tree Competition&quot; , &quot;Silvicultural Metrics&quot; ) ) %&gt;% forcats::fct_rev() ) %&gt;% ggplot( mapping = aes(x = pct_mins, y = depth_maps_generation_quality, fill=section, group=section) ) + geom_col( width = 0.7, alpha=0.8 ) + geom_text( mapping = aes( label = scales::percent(ifelse(pct_mins&gt;=0.06,pct_mins,NA), accuracy = 1) , fontface = &quot;bold&quot; ) , position = position_stack(vjust = 0.5) , color = &quot;black&quot;, size = 4 ) + scale_fill_viridis_d(option = &quot;turbo&quot;, begin = 0.1, end = 0.9) + scale_x_continuous(labels = scales::percent_format()) + labs( fill = &quot;R script\\nsection&quot; , y = &quot;depth map quality&quot; , x = &quot;% Point Cloud Total Processing Time&quot; , title = bquote( bold(&quot;R&quot;) ~ &quot;point cloud total processing time by depth map generation quality and R script section&quot; ) , subtitle = &quot;Median across software, study site, &amp; depth map filtering mode &quot; ) + theme_light() + theme( legend.position = &quot;top&quot; , legend.direction = &quot;horizontal&quot; , legend.title = element_text(size=7) , axis.title.x = element_text(size=10, face = &quot;bold&quot;) , axis.title.y = element_text(size = 8) , axis.text.x = element_blank() , axis.text.y = element_text(color = &quot;black&quot;,size=10, face = &quot;bold&quot;) , axis.ticks.x = element_blank() ) + guides( fill = guide_legend(nrow = 3, byrow = T, reverse = T, override.aes = list(alpha = 0.9)) ) ggplot2::ggsave(&quot;../data/processing_time_brkdown.png&quot;, width = 8.5, height = 6) 4.3.5 Summary of point cloud data Use flight boundary to calculate the per ha metrics but all of the flight boundaries based on the SfM data are different ; so will just use the Metashape “high” quality area median across filtering modes applied to all. 4.3.5.1 Table table_temp = ptcld_processing_data %&gt;% dplyr::select( # unique vars software, tidyselect::starts_with(&quot;depth_maps&quot;), study_site # vars , number_of_points, timer_total_time_mins ) %&gt;% # add area dplyr::inner_join( ptcld_processing_data %&gt;% dplyr::mutate( las_area_m2 = dplyr::case_when( tolower(software)==&quot;metashape&quot; &amp; tolower(depth_maps_generation_quality)==&quot;high&quot; ~ las_area_m2 , T ~ NA ) ) %&gt;% dplyr::group_by(study_site) %&gt;% dplyr::summarise(las_area_m2 = median(las_area_m2, na.rm = T)) , by = &quot;study_site&quot; ) %&gt;% # calculate per area metrics dplyr::mutate( number_of_points_m2 = number_of_points/las_area_m2 , timer_total_time_mins_ha = timer_total_time_mins/(las_area_m2/10000) ) %&gt;% # summary dplyr::rename_with( .fn = function(x){ x %&gt;% stringr::str_replace_all(&quot;depth_maps_generation_quality&quot;, &quot;quality&quot;) %&gt;% stringr::str_replace_all(&quot;depth_maps_generation_filtering_mode&quot;, &quot;filtering&quot;) } ) %&gt;% # plot it? # ggplot(mapping = aes(fill = software)) + # geom_boxplot(mapping = aes(x = software, y = timer_total_time_mins_ha)) + # facet_wrap(facets = vars(quality, filtering), ncol = 10) + # scale_fill_viridis_d(option = &quot;rocket&quot;, begin = 0.3, end = 0.9, drop = F) + # scale_y_log10( # labels = scales::comma_format(suffix = &quot; mins&quot;, accuracy = 0.1) # , breaks = scales::breaks_log(n = 9) # ) + # theme_light() # or table it dplyr::group_by(software, quality, filtering) %&gt;% dplyr::summarise( dplyr::across( c(number_of_points_m2, timer_total_time_mins_ha) , .fns = list(mean = mean, sd = sd) ) , n = dplyr::n() ) %&gt;% # combine mean/sd dplyr::mutate( pts = paste0( number_of_points_m2_mean %&gt;% round(1) %&gt;% scales::comma(accuracy = 1) , &quot;&lt;br&gt;(&quot; , number_of_points_m2_sd %&gt;% round(1) %&gt;% scales::comma(accuracy = 1) , &quot;)&quot; ) , mins = paste0( timer_total_time_mins_ha_mean %&gt;% round(1) %&gt;% scales::comma(accuracy = 0.1) , &quot;&lt;br&gt;(&quot; , timer_total_time_mins_ha_sd %&gt;% round(1) %&gt;% scales::comma(accuracy = 0.1) , &quot;)&quot; ) ) %&gt;% dplyr::ungroup() %&gt;% select(software,quality,filtering,pts,mins) table_temp = dplyr::bind_rows( table_temp %&gt;% dplyr::select(-c(mins)) %&gt;% tidyr::pivot_wider(names_from = filtering, values_from = pts) %&gt;% dplyr::mutate(metric = &quot;Points m&lt;sup&gt;-2&lt;/sup&gt;&quot;) , table_temp %&gt;% dplyr::select(-c(pts)) %&gt;% tidyr::pivot_wider(names_from = filtering, values_from = mins) %&gt;% dplyr::mutate(metric = &quot;Processing time&lt;br&gt;mins ha&lt;sup&gt;-1&lt;/sup&gt;&quot;) ) %&gt;% dplyr::relocate(software) %&gt;% dplyr::relocate(metric) # table table_temp %&gt;% kableExtra::kbl(escape = F) %&gt;% kableExtra::kable_styling() %&gt;% kableExtra::collapse_rows(columns = 1:2, valign = &quot;top&quot;) metric software quality aggressive moderate mild disabled Points m-2 METASHAPE ultra high 3,546(1,444) 4,446(1,687) 4,544(1,801) 4,597(1,786) high 789(296) 972(345) 1,019(378) 1,028(377) medium 183(64) 224(76) 238(84) 239(84) low 43(13) 52(17) 57(19) 57(20) lowest 11(3) 12(4) 13(4) 13(4) OPENDRONEMAP ultra high 1,684(664) 1,678(603) 1,557(515) 1,455(566) high 421(125) 421(128) 418(134) 418(133) medium 100(32) 100(32) 99(33) 100(34) low 99(32) 100(33) 99(33) 100(33) lowest 99(31) 100(33) 100(32) 99(33) PIX4D ultra high NA 262(84) 934(317) 3,454(1,185) high NA 58(24) 217(90) 774(318) medium NA 14(4) 54(16) 193(60) low NA 4(1) 13(4) 47(14) Processing timemins ha-1 METASHAPE ultra high 9.1(4.4) 13.3(6.1) 14.0(6.2) 17.5(8.2) high 2.2(0.8) 2.9(0.9) 3.2(1.2) 4.3(1.2) medium 0.9(0.3) 1.0(0.3) 1.0(0.4) 1.3(0.4) low 0.3(0.1) 0.3(0.1) 0.3(0.1) 0.4(0.1) lowest 0.1(0.0) 0.2(0.0) 0.2(0.0) 0.2(0.0) OPENDRONEMAP ultra high 2.8(1.1) 2.7(1.0) 2.4(0.7) 2.4(0.9) high 0.7(0.2) 0.7(0.2) 0.7(0.2) 0.6(0.2) medium 0.2(0.1) 0.2(0.1) 0.2(0.1) 0.2(0.1) low 0.2(0.1) 0.2(0.1) 0.2(0.1) 0.2(0.0) lowest 0.2(0.1) 0.2(0.1) 0.2(0.1) 0.2(0.0) PIX4D ultra high NA 1.1(0.4) 3.8(1.7) 42.1(31.0) high NA 0.3(0.1) 0.9(0.5) 3.5(1.6) medium NA 0.1(0.0) 0.3(0.1) 0.8(0.3) low NA 0.1(0.0) 0.1(0.0) 0.3(0.1) 4.3.6 R Processing Summary table_temp = ptcld_processing_data %&gt;% dplyr::select( # unique vars software, tidyselect::starts_with(&quot;depth_maps&quot;), study_site # vars , number_of_points, timer_total_time_mins ) %&gt;% # add area dplyr::inner_join( ptcld_processing_data %&gt;% dplyr::mutate( las_area_m2 = dplyr::case_when( tolower(software)==&quot;metashape&quot; &amp; tolower(depth_maps_generation_quality)==&quot;high&quot; ~ las_area_m2 , T ~ NA ) ) %&gt;% dplyr::group_by(study_site) %&gt;% dplyr::summarise(las_area_m2 = median(las_area_m2, na.rm = T)) , by = &quot;study_site&quot; ) %&gt;% # calculate per area metrics dplyr::mutate( number_of_points_m2 = number_of_points/las_area_m2 , timer_total_time_mins_ha = timer_total_time_mins/(las_area_m2/10000) ) %&gt;% # summary dplyr::rename_with( .fn = function(x){ x %&gt;% stringr::str_replace_all(&quot;depth_maps_generation_quality&quot;, &quot;quality&quot;) %&gt;% stringr::str_replace_all(&quot;depth_maps_generation_filtering_mode&quot;, &quot;filtering&quot;) } ) # plot it? p1_temp = table_temp %&gt;% dplyr::mutate(quality = forcats::fct_rev(quality)) %&gt;% ggplot(mapping = aes(x = filtering, y = timer_total_time_mins_ha, fill = software)) + geom_point( mapping = aes(group=software, color = software) , position = position_nudge(x = -0.4) , alpha = 0.8 , shape = &quot;-&quot;, size = 5 ) + geom_boxplot( width = 0.7, alpha = 0.8 , position = position_dodge2(preserve = &quot;single&quot;) , outliers = F ) + # set vertical lines between x groups geom_vline(xintercept = seq(0.5, length(table_temp$filtering), by = 1), color=&quot;gray22&quot;, lwd=.5) + facet_grid(cols = vars(quality)) + scale_fill_viridis_d(option = &quot;rocket&quot;, begin = 0.3, end = 0.9, drop = F) + scale_color_viridis_d(option = &quot;rocket&quot;, begin = 0.3, end = 0.9, drop = F) + scale_y_log10( labels = scales::comma_format(suffix = &quot; mins&quot;, accuracy = 0.1) , breaks = scales::breaks_log(n = 9) ) + labs( subtitle = &quot;quality&quot; , y = latex2exp::TeX(&quot;Pt. Cld. Processing Time (mins $\\\\cdot ha^{-1}$)&quot;) , x = &quot;filtering mode&quot; ) + theme_light() + theme( legend.position = &quot;bottom&quot; , legend.direction = &quot;horizontal&quot; , panel.grid.major.x = element_blank() , panel.grid.minor.x = element_blank() , axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1, size = 7) , strip.text = element_text(color = &quot;black&quot;, face = &quot;bold&quot;) , plot.subtitle = element_text(hjust = 0.5) ) + guides( fill = guide_legend(reverse = T, override.aes = list(alpha = 1, color = NA, shape = NA, lwd = NA)) , color = &quot;none&quot; ) # plot it? p2_temp = table_temp %&gt;% dplyr::mutate(quality = forcats::fct_rev(quality)) %&gt;% ggplot(mapping = aes(x = filtering, y = number_of_points_m2, fill = software)) + geom_point( mapping = aes(group=software, color = software) , position = position_nudge(x = -0.4) , alpha = 0.8 , shape = &quot;-&quot;, size = 5 ) + geom_boxplot( width = 0.7, alpha = 0.8 , position = position_dodge2(preserve = &quot;single&quot;) , outliers = F ) + # set vertical lines between x groups geom_vline(xintercept = seq(0.5, length(table_temp$filtering), by = 1), color=&quot;gray22&quot;, lwd=.5) + facet_grid(cols = vars(quality)) + scale_fill_viridis_d(option = &quot;rocket&quot;, begin = 0.3, end = 0.9, drop = F) + scale_color_viridis_d(option = &quot;rocket&quot;, begin = 0.3, end = 0.9, drop = F) + scale_y_log10( labels = scales::comma_format(accuracy = 1) , breaks = scales::breaks_log(n = 9) ) + labs( subtitle = &quot;quality&quot; , y = latex2exp::TeX(&quot;Point Density (points $\\\\cdot m^{-2}$)&quot;) , x = &quot;filtering mode&quot; ) + theme_light() + theme( legend.position = &quot;bottom&quot; , legend.direction = &quot;horizontal&quot; , panel.grid.major.x = element_blank() , panel.grid.minor.x = element_blank() , axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1, size = 7) , strip.text = element_text(color = &quot;black&quot;, face = &quot;bold&quot;) , plot.subtitle = element_text(hjust = 0.5) ) + guides( fill = guide_legend(reverse = T, override.aes = list(alpha = 1, color = NA, shape = NA, lwd = NA)) , color = &quot;none&quot; ) # combine plots p2_temp / p1_temp + patchwork::plot_layout(guides = &quot;collect&quot;) &amp; theme(legend.position = &quot;bottom&quot;) ggplot2::ggsave(&quot;../data/ptcld_summary_stats.png&quot;, height = 8.5, width = 11) 4.3.7 SfM image processing time summary Because the SfM photogrammetry software were each run on different processing computers we need to normalize the processing time by software. SfM image processing time was normalized using Min-Max normalization as: \\[ x^{\\prime}_{ij} = \\frac{x_{ij}-x_{min[j]}}{x_{max[j]}-x_{min[j]}} \\] where \\(i\\) is the the study site observation within each software \\(j\\) where each software was implemented on a different computer. ptcld_processing_data %&gt;% dplyr::group_by(software, depth_maps_generation_quality, depth_maps_generation_filtering_mode) %&gt;% dplyr::mutate(med = median(total_sfm_time_norm, na.rm = T)) %&gt;% dplyr::ungroup() %&gt;% dplyr::mutate(depth_maps_generation_quality = forcats::fct_rev(depth_maps_generation_quality)) %&gt;% ggplot(mapping = aes( x = depth_maps_generation_filtering_mode , y = total_sfm_time_norm , fill = med )) + geom_boxplot(width = 0.7, outliers = F, fill = &quot;slategray&quot;) + facet_grid( rows = vars(software) , cols = vars(depth_maps_generation_quality) ) + scale_fill_viridis_c(option = &quot;mako&quot;, direction = -1, end = 0.9) + scale_y_continuous( limits = c(-0.02,1.02) , breaks = c(0, 1) , minor_breaks = seq(0.2,0.8,0.2) , labels = c(&quot;min&quot;,&quot;max&quot;) ) + labs(x = &quot;filtering mode&quot;, y = &quot;SfM Image Processing Time (normalized)&quot;,subtitle = &quot;quality&quot;) + theme_light() + theme( legend.position = &quot;none&quot; , legend.direction = &quot;horizontal&quot; , panel.grid.major.x = element_blank() , panel.grid.minor.x = element_blank() , panel.grid.major.y = element_line(color = &quot;black&quot;) , axis.ticks.y = element_blank() , axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1) , strip.text = element_text(color = &quot;black&quot;, face = &quot;bold&quot;) , plot.subtitle = element_text(hjust = 0.5) ) ggplot2::ggsave(&quot;../data/sfm_img_processing_time.png&quot;, height = 7, width = 10.5) table it table_temp = ptcld_processing_data %&gt;% dplyr::group_by(software, depth_maps_generation_quality, depth_maps_generation_filtering_mode) %&gt;% dplyr::summarise( dplyr::across( total_sfm_time_norm , .fns = list(mean = mean, sd = sd, min = min, max = max) ) , n = dplyr::n() ) %&gt;% dplyr::mutate( range = paste0( total_sfm_time_norm_min %&gt;% scales::number(accuracy = 0.01) , &quot;—&quot; , total_sfm_time_norm_max %&gt;% scales::number(accuracy = 0.01) ) , depth_maps_generation_quality = depth_maps_generation_quality %&gt;% forcats::fct_rev() ) %&gt;% select(-c(n,total_sfm_time_norm_min, total_sfm_time_norm_max)) %&gt;% dplyr::ungroup() %&gt;% dplyr::arrange(software, depth_maps_generation_quality, depth_maps_generation_filtering_mode) table_temp %&gt;% # dplyr::select(-c(software)) %&gt;% kableExtra::kbl( digits = 2 , caption = &quot;Normalized SfM Image Processing Time&quot; , col.names = c( &quot;software&quot;, &quot;quality&quot;, &quot;filtering mode&quot; , &quot;Mean&quot; , &quot;Std Dev&quot;, &quot;Range&quot; ) , escape = F ) %&gt;% kableExtra::kable_styling() %&gt;% # kableExtra::pack_rows(index = table(forcats::fct_inorder(table_temp$software))) %&gt;% kableExtra::collapse_rows(columns = 1:2, valign = &quot;top&quot;) %&gt;% kableExtra::scroll_box(height = &quot;8in&quot;) Table 4.1: Normalized SfM Image Processing Time software quality filtering mode Mean Std Dev Range METASHAPE lowest aggressive 0.00 0.00 0.00—0.01 moderate 0.00 0.00 0.00—0.01 mild 0.00 0.00 0.00—0.01 disabled 0.00 0.00 0.00—0.01 low aggressive 0.01 0.01 0.00—0.02 moderate 0.01 0.01 0.00—0.02 mild 0.01 0.01 0.00—0.02 disabled 0.01 0.01 0.00—0.02 medium aggressive 0.04 0.02 0.02—0.06 moderate 0.04 0.02 0.02—0.06 mild 0.04 0.02 0.02—0.05 disabled 0.04 0.02 0.02—0.06 high aggressive 0.18 0.07 0.10—0.24 moderate 0.18 0.06 0.10—0.23 mild 0.16 0.06 0.09—0.21 disabled 0.17 0.06 0.09—0.22 ultra high aggressive 0.77 0.29 0.45—1.00 moderate 0.78 0.28 0.46—1.00 mild 0.72 0.26 0.43—0.93 disabled 0.76 0.27 0.45—0.99 OPENDRONEMAP lowest aggressive 0.02 0.00 0.02—0.02 moderate 0.02 0.01 0.00—0.03 mild 0.05 0.00 0.04—0.05 disabled 0.11 0.02 0.08—0.14 low aggressive 0.02 0.00 0.02—0.03 moderate 0.03 0.00 0.02—0.03 mild 0.05 0.01 0.04—0.06 disabled 0.11 0.03 0.08—0.15 medium aggressive 0.02 0.00 0.02—0.02 moderate 0.02 0.00 0.02—0.03 mild 0.05 0.00 0.04—0.05 disabled 0.11 0.02 0.09—0.14 high aggressive 0.09 0.01 0.08—0.10 moderate 0.09 0.01 0.08—0.10 mild 0.12 0.01 0.10—0.13 disabled 0.18 0.03 0.14—0.22 ultra high aggressive 0.71 0.08 0.61—0.80 moderate 0.73 0.11 0.60—0.85 mild 0.79 0.09 0.66—0.90 disabled 0.86 0.13 0.69—1.00 PIX4D low moderate 0.00 0.00 0.00—0.01 mild 0.01 0.00 0.01—0.01 disabled 0.01 0.01 0.01—0.02 medium moderate 0.01 0.01 0.00—0.02 mild 0.02 0.00 0.01—0.02 disabled 0.04 0.01 0.02—0.05 high moderate 0.02 0.01 0.01—0.03 mild 0.06 0.02 0.03—0.08 disabled 0.18 0.07 0.12—0.28 ultra high moderate 0.10 0.03 0.05—0.12 mild 0.29 0.09 0.15—0.39 disabled 0.78 0.17 0.54—1.00 "],["field_valid.html", "Section 5 Field Validation 5.1 Setup 5.2 Data Load Functions 5.3 Validation Data Functions 5.4 Full pipeline function 5.5 Apply validation for all 5.6 Full Validation Summary Data 5.7 Example Validation Process 5.8 Mapped validation for all sites 5.9 Field Data Descriptive Statistics 5.10 Summary of Dependent Variables", " Section 5 Field Validation This section combines the SfM-derived tree locations with stem-mapped tree locations from field sampling. Tinkham and Swayze (2021; p.6) describe a methodology for matching UAS detected trees with stem mapped trees identified via traditional field survey methods. Note, detected trees in the excerpt below references UAS detected trees while survey trees references field-based stem mapped trees: Each of the detected tree outputs was matched with survey tree locations through an iterative process. Iteratively, a detected tree was selected, and all survey trees within a 3 m radius and 10% height of the detected tree were identified. If a survey tree met both the location and height precision requirements, it was considered a true positive (TP) detection, and both the survey and detected trees were removed from further matching. However, if no match was made, the detected tree was considered a commission (Co) and removed from further matching. This process was repeated until all detected trees were classified as true positive or commission, with all unmatched survey trees classified as omission (Om). Overall tree detection performance was described using the F-score metric (p.6). The F-score incorporates true positive, commission, and omission rates to determine how well the UAS detected trees represent the field-based stem mapped trees. As a measure of predictive performance, the highest possible value of an F-score is 1.0, indicating perfect precision and recall, and the lowest possible value is 0, if either precision or recall are zero. \\[ \\textrm{F-score} = 2 \\times \\frac{\\bigl(\\frac{TP}{TP+Om} \\times \\frac{TP}{TP+Co} \\bigr)}{\\bigl(\\frac{TP}{TP+Om} + \\frac{TP}{TP+Co} \\bigr)} \\] The process to match UAS detected trees to field stem mapped trees implemented here is slightly different than the process described above. To match the data parametrization from the UAS point cloud processing workflow, only stem-mapped trees above 2 m were considered for analysis. Each UAS detected tree was matched with stem-mapped tree locations that were within a 3 m radius and 2 m height of the UAS detected tree. The matched UAS and stem-mapped tree pairs were jointly compared (rather than iteratively) to select the pair that minimized the height difference for both the stem-mapped tree and the UAS detected tree to ensure that only one UAS detected tree was selected for each stem-mapped tree. If more than one UAS detected tree had the same height difference to a stem-mapped tree, the UAS detected tree spatially nearest to the stem-mapped tree was selected as the match. These UAS detected trees with a paired stem-mapped tree after this filtering process were considered true positive (\\(TP\\)) detections. To determine UAS detected tree commissions (i.e. UAS detected trees within the overstory plot for which there was no stem-mapped tree pair; \\(Co\\)) this analysis used the 2023-06 BHEF overstory field survey plot center and plot radius with a minimum DBH of 5 in (12.69 cm) as only trees above this size were sampled as part of the overstory survey. UAS detected trees within this radius with an estimated DBH over 5 in (12.69 cm) that did not have a matched stem-mapped tree pair were considered commissions (\\(Co\\)). The 2023-06 BHEF field surveys used \\(\\frac{1}{10}\\) acre (404.686 m2) plots with a 37.24 ft (11.35 m) radius for overstory sampling and \\(\\frac{1}{400}\\) acre (10.117 m2) plots with a 5.89 ft (1.795 m) radius for regeneration sampling. All unmatched stem-mapped survey trees were classified as omissions (\\(Om\\)). 5.1 Setup Pick a DBH to use for the validation. For this project, the UAS point cloud processing via the cloud2trees package intitially utilized the linear model to estimate missing DBH values using training values extracted from the point cloud using the TreeLS package. For the research article we used the regional DBH model. The options for picking a DBH to use are: “rf” for random forest estimate “lin” for linear model with an intercept (dbh_cm ~ 1 + tree_height_m) estimate “lin_noint” for linear model with no intercept (dbh_cm ~ 0 + tree_height_m) estimate “regional” for regional estimate based on regional FIA data using the USFS TreeMap data # Pick a DBH to use for the validation my_dbh_estimate = &quot;regional&quot; Load field validation plot data and update the ptcld_processing_data created in this section by adding a processing_id which we’ll use to process the files for validation. # list of study sites with completed uas data study_site_list = ptcld_processing_data$study_site %&gt;% unique() %&gt;% toupper() # list of field validation data validation_data = list.files( &quot;../data/field_validation&quot; , pattern = &quot;\\\\.gpkg$&quot;, full.names = T ) %&gt;% normalizePath() %&gt;% dplyr::as_tibble() %&gt;% dplyr::rename(validation_file_full_path=1) %&gt;% dplyr::mutate( study_site = validation_file_full_path %&gt;% toupper() %&gt;% stringr::str_extract(pattern = paste(study_site_list, collapse = &quot;|&quot;)) ) %&gt;% dplyr::filter(study_site %in% study_site_list) %&gt;% dplyr::group_by(study_site) %&gt;% dplyr::filter(dplyr::row_number() == 1) %&gt;% dplyr::ungroup() # what about the field plot boundary? validation_plots = sf::st_read(&quot;../data/field_validation/Field_Data_Boundary.shp&quot;) %&gt;% dplyr::rename_with(tolower) %&gt;% dplyr::mutate( study_site = site %&gt;% toupper() %&gt;% stringr::str_extract(pattern = paste(study_site_list, collapse = &quot;|&quot;)) ) %&gt;% dplyr::filter(study_site %in% study_site_list) %&gt;% dplyr::group_by(study_site) %&gt;% dplyr::filter(dplyr::row_number() == 1) %&gt;% dplyr::ungroup() %&gt;% dplyr::mutate( area_ha = sf::st_area(.) %&gt;% as.numeric() %&gt;% `/`(10000) , area_acres = area_ha*2.471 ) ## Reading layer `Field_Data_Boundary&#39; from data source ## `C:\\Data\\usfs\\uas_sfm_tree_detection\\data\\field_validation\\Field_Data_Boundary.shp&#39; ## using driver `ESRI Shapefile&#39; ## Simple feature collection with 5 features and 4 fields ## Geometry type: POLYGON ## Dimension: XY ## Bounding box: xmin: -157287.6 ymin: 4068511 xmax: 608828.5 ymax: 4892131 ## Projected CRS: WGS 84 / UTM zone 13N # where is the uas processed data? ptcld_processing_data = ptcld_processing_data %&gt;% dplyr::mutate( processed_data_dir = dirname(tracking_file_full_path) , processing_id = dplyr::row_number() ) where are these validation plots and what do they look like? # what? validation_plots %&gt;% dplyr::glimpse() ## Rows: 5 ## Columns: 8 ## $ id &lt;dbl&gt; NA, NA, NA, NA, NA ## $ site &lt;chr&gt; &quot;WA85_02&quot;, &quot;SQ09_02&quot;, &quot;N1&quot;, &quot;Kaibab_Low&quot;, &quot;Kaibab_High&quot; ## $ acres &lt;dbl&gt; 2.476617, 2.476617, 3.911949, 5.059504, 4.264751 ## $ hectares &lt;dbl&gt; 1.002679, 1.002679, 1.583785, 2.048382, 1.726620 ## $ geometry &lt;POLYGON [m]&gt; POLYGON ((608678.6 4892131,..., POLYGON ((608720.2 4889252,… ## $ study_site &lt;chr&gt; &quot;WA85_02&quot;, &quot;SQ09_02&quot;, &quot;N1&quot;, &quot;KAIBAB_LOW&quot;, &quot;KAIBAB_HIGH&quot; ## $ area_ha &lt;dbl&gt; 1.002168, 1.002168, 1.582522, 2.068603, 1.743671 ## $ area_acres &lt;dbl&gt; 2.476358, 2.476358, 3.910412, 5.111518, 4.308611 # where? mapview::mapviewOptions(basemaps = c(&quot;OpenStreetMap&quot;,&quot;Esri.WorldImagery&quot;)) validation_plots %&gt;% sf::st_buffer(2000) %&gt;% # because they are small mapview::mapview(col.regions = &quot;blue&quot;, layer.name = &quot;plot&quot;, alpha.regions = 0.7) create a function to calculate the basal area of a tree in m2 from DBH measured in cm calc_ba_m2_from_dbh_cm = function(dbh_cm){ return( pi * dbh_cm^2 / (4*10000) ) } 5.2 Data Load Functions field validation data # function to read field data once per site read_field_data &lt;- function(my_study_site) { d = sf::st_read( validation_data %&gt;% dplyr::filter(study_site == my_study_site) %&gt;% dplyr::pull(validation_file_full_path) ) %&gt;% dplyr::mutate( study_site = my_study_site ) %&gt;% dplyr::rename_with(tolower) %&gt;% dplyr::rename( field_dbh_cm = dbh_cm , field_tree_height_m = ht_m ) %&gt;% sf::st_set_geometry(&quot;geometry&quot;) %&gt;% dplyr::filter( !is.na(field_dbh_cm) &amp; !is.na(field_tree_height_m) &amp; sf::st_is_valid(geometry) # only keep trees that are above height threshold used for uas processing &amp; field_tree_height_m &gt;= min(ptcld_processing_data$sttng_minimum_tree_height_m) # &amp; field_dbh_cm &gt;= min_tree_dbh_cm # if know min field dbh for field sampling ) # keep only trees within sampling plot d %&gt;% sf::st_intersection( validation_plots %&gt;% dplyr::filter(study_site == my_study_site) %&gt;% dplyr::mutate(intersected_with_plot_geom = T) %&gt;% dplyr::select(intersected_with_plot_geom) %&gt;% sf::st_transform(sf::st_crs(d)) ) %&gt;% dplyr::mutate( field_tree_id = dplyr::row_number() , tree_utm_x = sf::st_coordinates(geometry)[,1] #lon , tree_utm_y = sf::st_coordinates(geometry)[,2] #lat # basal area , basal_area_m2 = calc_ba_m2_from_dbh_cm(field_dbh_cm) ) %&gt;% dplyr::relocate(field_tree_id) } 5.2.1 Summary of field validation plot data table_temp = validation_plots %&gt;% dplyr::pull(study_site) %&gt;% purrr::map(function(x){ read_field_data(x) %&gt;% sf::st_drop_geometry() %&gt;% dplyr::select(study_site,field_dbh_cm,field_tree_height_m,basal_area_m2) }) %&gt;% dplyr::bind_rows() %&gt;% dplyr::group_by(study_site) %&gt;% dplyr::summarise( dplyr::across( tidyselect::starts_with(&quot;field_&quot;) , .fns = list(mean = mean, sd = sd) ) , n_trees = dplyr::n() , basal_area_m2 = sum(basal_area_m2) ) %&gt;% # add area dplyr::inner_join( validation_plots %&gt;% dplyr::select(study_site, area_ha) %&gt;% sf::st_drop_geometry() , by = &quot;study_site&quot; ) %&gt;% dplyr::mutate( ht = paste0( field_tree_height_m_mean %&gt;% round(1) %&gt;% scales::comma(accuracy = 0.1) , &quot;&lt;br&gt;(&quot; , field_tree_height_m_sd %&gt;% round(1) %&gt;% scales::comma(accuracy = 0.1) , &quot;)&quot; ) , dbh = paste0( field_dbh_cm_mean %&gt;% round(1) %&gt;% scales::comma(accuracy = 0.1) , &quot;&lt;br&gt;(&quot; , field_dbh_cm_sd %&gt;% round(1) %&gt;% scales::comma(accuracy = 0.1) , &quot;)&quot; ) , trees_ha = n_trees/area_ha , basal_area_m2_per_ha = basal_area_m2/area_ha , area_ha = area_ha %&gt;% round(1) %&gt;% scales::comma(accuracy = 0.1) ) %&gt;% dplyr::select( study_site, area_ha, trees_ha, basal_area_m2_per_ha, ht, dbh ) table_temp %&gt;% kableExtra::kbl( escape = F , digits = 1 , col.names = c( &quot;&quot; , &quot;Hectares&quot; , &quot;Trees&lt;br&gt;ha&lt;sup&gt;-1&lt;/sup&gt;&quot; , &quot;Basal Area&lt;br&gt;m&lt;sup&gt;2&lt;/sup&gt; ha&lt;sup&gt;-1&lt;/sup&gt;&quot; , &quot;Height (m)&quot;, &quot;DBH (cm)&quot; ) ) %&gt;% kableExtra::kable_styling() Hectares Treesha-1 Basal Aream2 ha-1 Height (m) DBH (cm) KAIBAB_HIGH 1.7 574.1 39.6 12.8(7.2) 24.0(17.4) KAIBAB_LOW 2.1 246.5 22.5 12.5(8.6) 27.3(20.5) N1 1.6 639.5 24.8 8.5(7.3) 15.4(16.0) SQ09_02 1.0 308.3 11.2 11.1(4.8) 19.7(8.8) WA85_02 1.0 171.6 14.9 15.7(6.0) 30.7(12.8) 5.2.2 Load UAS data function # function finds uas tree list # reads it # estimates linear model if not already used for DBH read_uas_data = function(my_processing_id, my_crs = NULL, use_this_dbh = my_dbh_estimate) { # where is this file? fnm = ptcld_processing_data %&gt;% dplyr::filter( processing_id == my_processing_id ) %&gt;% dplyr::mutate( fnm = paste0( processed_data_dir , &quot;/&quot; , file_name , &quot;_final_detected_tree_tops.gpkg&quot; ) ) %&gt;% dplyr::pull(fnm) if(file.exists(fnm)){ # read it dta = sf::st_read(fnm) %&gt;% dplyr::mutate( processing_id = my_processing_id ) %&gt;% dplyr::rename_with(tolower) %&gt;% sf::st_set_geometry(&quot;geometry&quot;) # transform if(is.null(my_crs)){ tcrs = sf::st_crs(dta) }else{tcrs = my_crs} dta = dta %&gt;% sf::st_transform(tcrs) ################# # estimate linear model if not already used for DBH ################# if( # is there sufficient training data? dta %&gt;% dplyr::filter(is_training_data == T) %&gt;% nrow() &gt; 10 &amp; # was rf model used? ptcld_processing_data %&gt;% dplyr::filter(processing_id == my_processing_id) %&gt;% dplyr::pull(sttng_local_dbh_model) %&gt;% tolower() == &quot;rf&quot; ){ # Gamma distribution for strictly positive response variable dbh # !!!! fit with intercept stem_prediction_model = brms::brm( formula = dbh_cm ~ 1 + tree_height_m , data = dta %&gt;% dplyr::filter(is_training_data==T) %&gt;% dplyr::select(dbh_cm, tree_height_m) , family = brms::brmsfamily(&quot;Gamma&quot;, link = &quot;log&quot;) , prior = c(prior(gamma(0.01, 0.01), class = shape)) , iter = 4000, warmup = 2000, chains = 4 , cores = lasR::half_cores() , file = ptcld_processing_data %&gt;% dplyr::filter(processing_id == my_processing_id) %&gt;% dplyr::mutate( fff = paste0( processed_data_dir , &quot;/&quot; , file_name , &quot;_local_dbh_height_model&quot; ) ) %&gt;% dplyr::pull(fff) # , file_refit = &quot;on_change&quot; ) # Gamma distribution for strictly positive response variable dbh # !!!! fit with NO intercept stem_prediction_noint_model = brms::brm( formula = dbh_cm ~ 0 + tree_height_m , data = dta %&gt;% dplyr::filter(is_training_data==T) %&gt;% dplyr::select(dbh_cm, tree_height_m) , family = brms::brmsfamily(&quot;Gamma&quot;, link = &quot;log&quot;) , prior = c(prior(gamma(0.01, 0.01), class = shape)) , iter = 4000, warmup = 2000, chains = 4 , cores = lasR::half_cores() , file = ptcld_processing_data %&gt;% dplyr::filter(processing_id == my_processing_id) %&gt;% dplyr::mutate( fff = paste0( processed_data_dir , &quot;/&quot; , file_name , &quot;_local_dbh_height_noint_model&quot; ) ) %&gt;% dplyr::pull(fff) # , file_refit = &quot;on_change&quot; ) ################# # prediction data ################# pred_temp = predict(stem_prediction_model, dta) %&gt;% dplyr::as_tibble() %&gt;% dplyr::pull(1) pred_noint_temp = predict(stem_prediction_noint_model, dta) %&gt;% dplyr::as_tibble() %&gt;% dplyr::pull(1) # add to data dta = dta %&gt;% dplyr::mutate( rf_dbh_cm = dbh_cm , pred_dbh_cm = pred_temp , pred_noint_dbh_cm = pred_noint_temp , lin_dbh_cm = ifelse(is_training_data==T, dbh_cm, pred_dbh_cm) , lin_noint_dbh_cm = ifelse(is_training_data==T, dbh_cm, pred_noint_dbh_cm) ) %&gt;% dplyr::select(-c(pred_dbh_cm,pred_noint_dbh_cm)) }else if(# is there sufficient training data? dta %&gt;% dplyr::filter(is_training_data == T) %&gt;% nrow() &lt;= 10 ){ # the regional model was used which would result in the same est for rf and lin dta = dta %&gt;% dplyr::mutate( rf_dbh_cm = dbh_cm , lin_dbh_cm = dbh_cm , lin_noint_dbh_cm = dbh_cm ) }else{ # linear model was already used and no rf pred # could update this to estimate rf model if missing...#nextyear dta = dta %&gt;% dplyr::mutate( rf_dbh_cm = as.numeric(NA) , lin_dbh_cm = dbh_cm , lin_noint_dbh_cm = as.numeric(NA) ) } # return with dbh updated return( dta %&gt;% dplyr::mutate( dbh_cm = dplyr::case_when( # update dbh to selected tolower(use_this_dbh) == &quot;rf&quot; &amp; !is.na(rf_dbh_cm) ~ rf_dbh_cm , tolower(use_this_dbh) == &quot;lin&quot; &amp; !is.na(lin_dbh_cm) ~ lin_dbh_cm , tolower(use_this_dbh) == &quot;lin_noint&quot; &amp; !is.na(lin_noint_dbh_cm) ~ lin_noint_dbh_cm , tolower(use_this_dbh) == &quot;regional&quot; &amp; !is.na(reg_est_dbh_cm) ~ reg_est_dbh_cm , T ~ reg_est_dbh_cm )) %&gt;% dplyr::mutate( basal_area_m2 = calc_ba_m2_from_dbh_cm(dbh_cm) , basal_area_ft2 = basal_area_m2 * 10.764 ) ) }else{stop(&quot;could not find file: &quot;, fnm)} } 5.3 Validation Data Functions 5.3.1 True Positive Identification The UAS detected and stem-mapped tree pairs identified in this filtering process (detailed above) were considered true positive (\\(TP\\)) detections. ## BUFFER THE UAS TREES AND SPATIALLY MATCH FIELD TREES BASED ON THAT BUFFER true_positive_trees_fn = function(uas_data, field_data, max_dist_m = 3, max_height_error_m = 2){ ## get FIELD trees within radius OF UAS TREES potential_tree_pairs_temp = uas_data %&gt;% dplyr::select(treeid, tree_height_m) %&gt;% # buffer point sf::st_buffer(max_dist_m) %&gt;% # spatial join with all FIELD tree points sf::st_join( field_data %&gt;% dplyr::select( field_tree_id, field_tree_height_m , tree_utm_x, tree_utm_y ) , join = sf::st_intersects , left = F # performs inner join to only keep uas trees with a match ) %&gt;% # calculate height difference dplyr::mutate( height_diff_m = abs(tree_height_m-field_tree_height_m) , height_diff_pct = height_diff_m/field_tree_height_m ) %&gt;% # removes tree pairs that are outside of the allowable error # dplyr::filter(height_diff_pct &lt;= max_height_error_pct) %&gt;% dplyr::filter(height_diff_m &lt;= max_height_error_m) %&gt;% dplyr::select(-c(height_diff_m)) %&gt;% dplyr::relocate(treeid, field_tree_id) ## apply pair selection criteria if there are potential tree pairs if(nrow(potential_tree_pairs_temp)&gt;0){ ## calculate row by row distances and height differences potential_tree_pairs_temp = potential_tree_pairs_temp %&gt;% # this is the position of the uas tree sf::st_centroid() %&gt;% sf::st_set_geometry(&quot;geom1&quot;) %&gt;% dplyr::bind_cols( potential_tree_pairs_temp %&gt;% sf::st_drop_geometry() %&gt;% dplyr::select(&quot;tree_utm_x&quot;, &quot;tree_utm_y&quot;) %&gt;% # this is the position of the field tree sf::st_as_sf( coords = c(&quot;tree_utm_x&quot;, &quot;tree_utm_y&quot;), crs = sf::st_crs(uas_data) ) %&gt;% sf::st_set_geometry(&quot;geom2&quot;) ) %&gt;% dplyr::mutate( distance_m = sf::st_distance(geom1, geom2, by_element = T) %&gt;% as.numeric() ) %&gt;% sf::st_drop_geometry() %&gt;% dplyr::select(-c(tree_utm_x, tree_utm_y, geom2)) ## define function to select the best tree pair select_best_tree_pair_fn &lt;- function(df) { df %&gt;% dplyr::group_by(field_tree_id) %&gt;% dplyr::arrange(field_tree_id, height_diff_pct, distance_m, desc(tree_height_m), treeid) %&gt;% dplyr::mutate( # at the field tree level...the number of uas trees n_uas_trees = dplyr::n() # at the field tree level... # the closest uas tree in height tie breaker distance, uas_tree_height_m, id , rank_within_field_tree = dplyr::row_number() ) %&gt;% dplyr::group_by(treeid) %&gt;% dplyr::arrange(treeid, height_diff_pct, distance_m, desc(field_tree_height_m), field_tree_id) %&gt;% dplyr::mutate( # at the uas tree level...the number of field trees n_field_trees = dplyr::n() # at the field tree level... # the closest field tree in height tie breaker distance, uas_tree_height_m, id , rank_within_uas_tree = dplyr::row_number() ) %&gt;% dplyr::ungroup() %&gt;% # select the uas-field tree pair with the minimum height difference dplyr::filter( rank_within_field_tree == 1 &amp; rank_within_uas_tree == 1 ) %&gt;% # remove columns dplyr::select( -c(tidyselect::starts_with(&quot;rank_&quot;), tidyselect::starts_with(&quot;n_&quot;)) ) } ## first filter for tree pairs true_positive_trees = select_best_tree_pair_fn(potential_tree_pairs_temp) ##remove matches from potential tree pairs potential_tree_pairs_temp = potential_tree_pairs_temp %&gt;% dplyr::filter( !(treeid %in% true_positive_trees$treeid) &amp; !(field_tree_id %in% true_positive_trees$field_tree_id) ) ## keep filtering for best pair until no unique pairs remain while(nrow(potential_tree_pairs_temp)&gt;0) { # keep filtering for best pair until no unique pairs remain true_positive_trees = true_positive_trees %&gt;% dplyr::bind_rows( select_best_tree_pair_fn(potential_tree_pairs_temp) ) #remove matches from potential tree pairs potential_tree_pairs_temp = potential_tree_pairs_temp %&gt;% dplyr::filter( !(treeid %in% true_positive_trees$treeid) &amp; !(field_tree_id %in% true_positive_trees$field_tree_id) ) } ## rename columns and flag true_positive_trees = true_positive_trees %&gt;% dplyr::rename( uas_tree_height_m = tree_height_m , uas_tree_id = treeid , field_uas_distance_m = distance_m ) %&gt;% dplyr::mutate( field_uas_group = &quot;true positive&quot; ) }else{ # if there are spatially matched trees true_positive_trees = dplyr::tibble( uas_tree_id = as.character(NA) , field_tree_id = as.character(NA) , uas_tree_height_m = as.numeric(NA) , field_tree_height_m = as.numeric(NA) , height_diff_pct = as.numeric(NA) , field_uas_distance_m = as.numeric(NA) , field_uas_group = as.character(NA) ) } # return return(true_positive_trees) } 5.3.2 Combine with Commission and Omission To determine UAS detected tree commissions (i.e. UAS detected trees within the overstory plot for which there was no stem-mapped tree pair; \\(Co\\)) this analysis used the 2023-06 BHEF overstory field survey plot center and plot radius of 11.35 m. UAS detected trees within this radius with an estimated DBH over 5 in (12.69 cm) that did not have a matched stem-mapped tree pair were considered commissions (\\(Co\\)). Omissions (\\(Om\\)) are stem-mapped trees without a UAS detected tree match. field_uas_comparison_fn = function(uas_data, field_data, true_positive_trees, plot_data, overstory_ht_m = 7){ field_uas_comparison = dplyr::bind_rows( ## true positive true_positive_trees %&gt;% dplyr::mutate(field_tree_id = as.numeric(field_tree_id)) ## omission , field_data %&gt;% sf::st_drop_geometry() %&gt;% dplyr::select( field_tree_id, field_tree_height_m ) %&gt;% dplyr::anti_join( true_positive_trees %&gt;% dplyr::mutate(field_tree_id = as.numeric(field_tree_id)) , by = dplyr::join_by(field_tree_id) ) %&gt;% dplyr::mutate( field_uas_group = &quot;omission&quot; ) ## commission , plot_data %&gt;% sf::st_transform(sf::st_crs(uas_data)) %&gt;% dplyr::select(study_site) %&gt;% # join with uas tree points sf::st_join( uas_data %&gt;% dplyr::filter( !treeid %in% true_positive_trees$uas_tree_id ) %&gt;% dplyr::select(treeid) %&gt;% dplyr::rename(uas_tree_id=treeid) , join = sf::st_intersects , left = F # performs inner join to only keep uas trees and plots with a match ) %&gt;% dplyr::select(-c(study_site)) %&gt;% sf::st_drop_geometry() %&gt;% dplyr::mutate( field_uas_group = &quot;commission&quot; ) ) %&gt;% dplyr::filter(!is.na(field_uas_group) &amp; field_uas_group!=&quot;&quot;) %&gt;% # attach uas data dplyr::left_join( uas_data %&gt;% sf::st_set_geometry(&quot;geometry&quot;) %&gt;% dplyr::mutate( uas_tree_utm_x = sf::st_coordinates(geometry)[,1] #lon , uas_tree_utm_y = sf::st_coordinates(geometry)[,2] #lat ) %&gt;% sf::st_drop_geometry() %&gt;% dplyr::select(treeid, tree_height_m, dbh_cm, basal_area_m2, uas_tree_utm_x, uas_tree_utm_y) %&gt;% dplyr::rename( uas_tree_id = treeid , uas_tree_height_m = tree_height_m , uas_dbh_cm = dbh_cm , uas_basal_area_m2 = basal_area_m2 ) , by = dplyr::join_by(uas_tree_id) ) %&gt;% # attach field data dplyr::left_join( field_data %&gt;% sf::st_drop_geometry() %&gt;% dplyr::select( field_tree_id, field_tree_height_m, field_dbh_cm, basal_area_m2 , tree_utm_x, tree_utm_y ) %&gt;% dplyr::rename( field_basal_area_m2 = basal_area_m2 , field_tree_utm_x = tree_utm_x , field_tree_utm_y = tree_utm_y ) , by = dplyr::join_by(field_tree_id) ) %&gt;% # update data dplyr::mutate( uas_tree_height_m = uas_tree_height_m.y , field_tree_height_m = field_tree_height_m.y , field_uas_group = factor( field_uas_group , ordered = T , levels = c( &quot;true positive&quot; , &quot;commission&quot; , &quot;omission&quot; ) ) %&gt;% forcats::fct_rev() , dbh_diff_cm = uas_dbh_cm - field_dbh_cm , tree_height_diff_m = uas_tree_height_m - field_tree_height_m , dbh_diff_pct = dbh_diff_cm/field_dbh_cm , height_diff_pct = tree_height_diff_m/field_tree_height_m , abs_dbh_diff_pct = abs(dbh_diff_pct) , abs_height_diff_pct = abs(height_diff_pct) # determine overstory/understory , overstory_understory_grp = dplyr::case_when( dplyr::coalesce(field_tree_height_m, uas_tree_height_m) &gt;= overstory_ht_m ~ &quot;overstory&quot; , dplyr::coalesce(field_tree_height_m, uas_tree_height_m) &lt; overstory_ht_m ~ &quot;understory&quot; , T ~ &quot;error&quot; ) %&gt;% factor() # attach identifying data , study_site = uas_data$study_site[1] , file_name = uas_data$file_name[1] , software = uas_data$software[1] , overstory_ht_m = overstory_ht_m ) %&gt;% dplyr::relocate(field_uas_group) %&gt;% dplyr::select(-c(tidyselect::ends_with(&quot;.x&quot;), tidyselect::ends_with(&quot;.y&quot;))) # # convert to imperial units # calc_imperial_units_fn() # return return(field_uas_comparison) } 5.3.3 Full validation function function to write comparison data and return aggregate metrics when passed a ptcld_processing_data$processing_id function returns: write full validation tree list to disk update ptcld_processing_data with metrics for testing: f-score height comparison metrics (mae, mape, smape, mse, rmse) dbh comparison metrics (mae, mape, smape, mse, rmse) path to full validation tree list written to disk ##################################################### # function to map over each file for a particular study site ##################################################### # function for a file name identified by processing_id in ptcld_processing_data validate_file_fn = function(p_id, fld_dta, plt_dta){ # tree list file name tl_fnm = paste0( ptcld_processing_data %&gt;% dplyr::filter(processing_id == p_id) %&gt;% dplyr::pull(processed_data_dir) , &quot;/&quot; , ptcld_processing_data %&gt;% dplyr::filter(processing_id == p_id) %&gt;% dplyr::pull(file_name) , &quot;_field_uas_comparison_data.csv&quot; ) # brms model brms_fnm = paste0( ptcld_processing_data %&gt;% dplyr::filter(processing_id == p_id) %&gt;% dplyr::pull(processed_data_dir) , &quot;/&quot; , ptcld_processing_data %&gt;% dplyr::filter(processing_id == p_id) %&gt;% dplyr::pull(file_name) , &quot;_local_dbh_height_model.rds&quot; ) # brms model noint brms_noint_fnm = paste0( ptcld_processing_data %&gt;% dplyr::filter(processing_id == p_id) %&gt;% dplyr::pull(processed_data_dir) , &quot;/&quot; , ptcld_processing_data %&gt;% dplyr::filter(processing_id == p_id) %&gt;% dplyr::pull(file_name) , &quot;_local_dbh_height_noint_model.rds&quot; ) # check it if(file.exists(tl_fnm) &amp; file.exists(brms_fnm) &amp; file.exists(brms_noint_fnm)){ # read it field_uas_comparison = readr::read_csv(tl_fnm) }else{ # uas_data u_dta = read_uas_data( my_processing_id = p_id , my_crs = sf::st_crs(fld_dta) ) # true positives tp_trees = true_positive_trees_fn(uas_data = u_dta, field_data = fld_dta) # field uas comparison field_uas_comparison = field_uas_comparison_fn( uas_data = u_dta , field_data = fld_dta , true_positive_trees = tp_trees , plot_data = plt_dta ) %&gt;% # attach id information dplyr::bind_cols( ptcld_processing_data %&gt;% dplyr::filter(processing_id == p_id) %&gt;% dplyr::select( processing_id, study_site, file_name, software , depth_maps_generation_quality , depth_maps_generation_filtering_mode , processing_attribute3 , processed_data_dir ) ) # write it write.csv( field_uas_comparison , tl_fnm , row.names = F ) } ############################################ # aggregate field_uas_comparison for return ############################################ # get plot area from plot data plot_area_ha = plt_dta$area_ha[1] # this is the return data which has lots of columns return_dta = ptcld_processing_data %&gt;% dplyr::filter(processing_id == p_id) %&gt;% ############################################ # overall statistics ############################################ # attach f score dplyr::bind_cols( # blank data in case missing dplyr::tibble(field_uas_group = c(&quot;tp&quot;, &quot;co&quot;, &quot;om&quot;)) %&gt;% dplyr::left_join( field_uas_comparison %&gt;% dplyr::count(field_uas_group) %&gt;% dplyr::mutate(field_uas_group = dplyr::case_when( field_uas_group == &quot;true positive&quot; ~ &quot;tp&quot; , field_uas_group == &quot;commission&quot; ~ &quot;co&quot; , field_uas_group == &quot;omission&quot; ~ &quot;om&quot; )) , by = dplyr::join_by(field_uas_group) ) %&gt;% dplyr::mutate(n = ifelse(is.na(n),0,n)) %&gt;% tidyr::pivot_wider( names_from = field_uas_group , values_from = n , values_fill = 0 ) %&gt;% dplyr::mutate( f_score = dplyr::coalesce( 2 * ( (tp/(tp+om)) * (tp/(tp+co)) ) / ( (tp/(tp+om)) + (tp/(tp+co)) ) , 0 ) ) %&gt;% dplyr::rename( true_positive_n_trees = tp , commission_n_trees = co , omission_n_trees = om ) %&gt;% dplyr::ungroup() ) %&gt;% # attach summary error metrics dplyr::bind_cols( field_uas_comparison %&gt;% dplyr::filter(field_uas_group==&quot;true positive&quot;) %&gt;% dplyr::ungroup() %&gt;% # thx Metrics pkg!! dplyr::summarise( # tree_height_m tree_height_m_me = mean(uas_tree_height_m-field_tree_height_m, na.rm = T) , tree_height_m_mpe = mean((uas_tree_height_m-field_tree_height_m)/field_tree_height_m, na.rm = T) , tree_height_m_mae = Metrics::mae(field_tree_height_m, uas_tree_height_m) , tree_height_m_mape = Metrics::mape(field_tree_height_m, uas_tree_height_m) , tree_height_m_smape = Metrics::smape(field_tree_height_m, uas_tree_height_m) , tree_height_m_mse = Metrics::mse(field_tree_height_m, uas_tree_height_m) , tree_height_m_rmse = Metrics::rmse(field_tree_height_m, uas_tree_height_m) # dbh_cm , dbh_cm_me = mean(uas_dbh_cm-field_dbh_cm, na.rm = T) , dbh_cm_mpe = mean((uas_dbh_cm-field_dbh_cm)/field_dbh_cm, na.rm = T) , dbh_cm_mae = Metrics::mae(field_dbh_cm, uas_dbh_cm) , dbh_cm_mape = Metrics::mape(field_dbh_cm, uas_dbh_cm) , dbh_cm_smape = Metrics::smape(field_dbh_cm, uas_dbh_cm) , dbh_cm_mse = Metrics::mse(field_dbh_cm, uas_dbh_cm) , dbh_cm_rmse = Metrics::rmse(field_dbh_cm, uas_dbh_cm) ) ) %&gt;% # attach basal area dplyr::bind_cols( field_uas_comparison %&gt;% dplyr::ungroup() %&gt;% dplyr::summarise( uas_basal_area_m2 = sum(uas_basal_area_m2, na.rm = T) , field_basal_area_m2 = sum(field_basal_area_m2, na.rm = T) ) %&gt;% # ba/ha and error dplyr::mutate( uas_basal_area_m2_per_ha = uas_basal_area_m2/plot_area_ha , field_basal_area_m2_per_ha = field_basal_area_m2/plot_area_ha # error , basal_area_m2_error = uas_basal_area_m2-field_basal_area_m2 , basal_area_m2_per_ha_error = uas_basal_area_m2_per_ha-field_basal_area_m2_per_ha , basal_area_pct_error = (uas_basal_area_m2-field_basal_area_m2)/field_basal_area_m2 , basal_area_abs_pct_error = abs(basal_area_pct_error) ) ) %&gt;% ############################################ # overstory/understory statistics ############################################ # attach f score dplyr::bind_cols( # blank data in case missing tidyr::crossing( field_uas_group = c(&quot;tp&quot;, &quot;co&quot;, &quot;om&quot;) , overstory_understory_grp = c(&quot;overstory&quot;, &quot;understory&quot;) ) %&gt;% dplyr::left_join( field_uas_comparison %&gt;% dplyr::count(field_uas_group, overstory_understory_grp) %&gt;% dplyr::mutate(field_uas_group = dplyr::case_when( field_uas_group == &quot;true positive&quot; ~ &quot;tp&quot; , field_uas_group == &quot;commission&quot; ~ &quot;co&quot; , field_uas_group == &quot;omission&quot; ~ &quot;om&quot; )) , by = dplyr::join_by(field_uas_group, overstory_understory_grp) ) %&gt;% dplyr::mutate(n = ifelse(is.na(n),0,n)) %&gt;% tidyr::pivot_wider( names_from = field_uas_group , values_from = n , values_fill = 0 ) %&gt;% dplyr::mutate( f_score = dplyr::coalesce( 2 * ( (tp/(tp+om)) * (tp/(tp+co)) ) / ( (tp/(tp+om)) + (tp/(tp+co)) ) , 0 ) ) %&gt;% dplyr::rename( true_positive_n_trees = tp , commission_n_trees = co , omission_n_trees = om ) %&gt;% dplyr::ungroup() %&gt;% tidyr::pivot_wider( names_from = overstory_understory_grp , values_from = -c(overstory_understory_grp) , values_fill = 0 , names_glue = &quot;{overstory_understory_grp}_{.value}&quot; ) ) %&gt;% # attach summary error metrics dplyr::bind_cols( tidyr::crossing( field_uas_group = c(&quot;true positive&quot;) , overstory_understory_grp = c(&quot;overstory&quot;,&quot;understory&quot;) ) %&gt;% dplyr::left_join( field_uas_comparison %&gt;% dplyr::mutate(overstory_understory_grp=as.character(overstory_understory_grp)) , by = dplyr::join_by(&quot;field_uas_group&quot;, &quot;overstory_understory_grp&quot;) ) %&gt;% dplyr::group_by(overstory_understory_grp) %&gt;% # thx Metrics pkg!! dplyr::summarise( # tree_height_m tree_height_m_me = mean(uas_tree_height_m-field_tree_height_m, na.rm = T) , tree_height_m_mpe = mean((uas_tree_height_m-field_tree_height_m)/field_tree_height_m, na.rm = T) , tree_height_m_mae = Metrics::mae(field_tree_height_m, uas_tree_height_m) , tree_height_m_mape = Metrics::mape(field_tree_height_m, uas_tree_height_m) , tree_height_m_smape = Metrics::smape(field_tree_height_m, uas_tree_height_m) , tree_height_m_mse = Metrics::mse(field_tree_height_m, uas_tree_height_m) , tree_height_m_rmse = Metrics::rmse(field_tree_height_m, uas_tree_height_m) # dbh_cm , dbh_cm_me = mean(uas_dbh_cm-field_dbh_cm, na.rm = T) , dbh_cm_mpe = mean((uas_dbh_cm-field_dbh_cm)/field_dbh_cm, na.rm = T) , dbh_cm_mae = Metrics::mae(field_dbh_cm, uas_dbh_cm) , dbh_cm_mape = Metrics::mape(field_dbh_cm, uas_dbh_cm) , dbh_cm_smape = Metrics::smape(field_dbh_cm, uas_dbh_cm) , dbh_cm_mse = Metrics::mse(field_dbh_cm, uas_dbh_cm) , dbh_cm_rmse = Metrics::rmse(field_dbh_cm, uas_dbh_cm) ) %&gt;% dplyr::ungroup() %&gt;% tidyr::pivot_wider( names_from = overstory_understory_grp , values_from = -c(overstory_understory_grp) , values_fill = 0 , names_glue = &quot;{overstory_understory_grp}_{.value}&quot; ) ) %&gt;% # attach basal area dplyr::bind_cols( dplyr::tibble( overstory_understory_grp = c(&quot;overstory&quot;,&quot;understory&quot;) ) %&gt;% dplyr::left_join( field_uas_comparison %&gt;% dplyr::group_by(overstory_understory_grp) %&gt;% dplyr::summarise( uas_basal_area_m2 = sum(uas_basal_area_m2, na.rm = T) , field_basal_area_m2 = sum(field_basal_area_m2, na.rm = T) ) %&gt;% dplyr::ungroup() %&gt;% # ba/ha and error dplyr::mutate( uas_basal_area_m2_per_ha = uas_basal_area_m2/plot_area_ha , field_basal_area_m2_per_ha = field_basal_area_m2/plot_area_ha # error , basal_area_m2_per_ha_error = uas_basal_area_m2_per_ha-field_basal_area_m2_per_ha , basal_area_pct_error = (uas_basal_area_m2_per_ha-field_basal_area_m2_per_ha)/field_basal_area_m2_per_ha , basal_area_abs_pct_error = abs(basal_area_pct_error) ) , by = dplyr::join_by(&quot;overstory_understory_grp&quot;) ) %&gt;% tidyr::pivot_wider( names_from = overstory_understory_grp , values_from = -c(overstory_understory_grp) , values_fill = 0 , names_glue = &quot;{overstory_understory_grp}_{.value}&quot; ) ) %&gt;% # where is the tree list ? dplyr::mutate( validation_file_full_path = tl_fnm # what is this overstory/understory? , overstory_ht_m = field_uas_comparison$overstory_ht_m[1] ) # return return(return_dta) } check validation function validation_temp = validate_file_fn( p_id = ptcld_processing_data %&gt;% dplyr::filter(study_site == study_site_list[1]) %&gt;% dplyr::pull(processing_id) %&gt;% .[1] , fld_dta = read_field_data(study_site_list[1]) , plt_dta = validation_plots %&gt;% dplyr::filter(study_site == study_site_list[1]) ) what does the validation data look like? # what? validation_temp %&gt;% dplyr::glimpse() ## Rows: 1 ## Columns: 114 ## $ tracking_file_full_path &lt;chr&gt; &quot;E:\\\\SfM_Software_Comparison\\\\Me… ## $ software &lt;chr&gt; &quot;METASHAPE&quot; ## $ study_site &lt;chr&gt; &quot;KAIBAB_HIGH&quot; ## $ processing_attribute1 &lt;chr&gt; &quot;HIGH&quot; ## $ processing_attribute2 &lt;chr&gt; &quot;AGGRESSIVE&quot; ## $ processing_attribute3 &lt;chr&gt; NA ## $ file_name &lt;chr&gt; &quot;HIGH_AGGRESSIVE&quot; ## $ number_of_points &lt;int&gt; 52974294 ## $ las_area_m2 &lt;dbl&gt; 86661.27 ## $ timer_tile_time_mins &lt;dbl&gt; 0.636007 ## $ timer_class_dtm_norm_chm_time_mins &lt;dbl&gt; 3.655956 ## $ timer_treels_time_mins &lt;dbl&gt; 8.906527 ## $ timer_itd_time_mins &lt;dbl&gt; 0.02202115 ## $ timer_competition_time_mins &lt;dbl&gt; 0.1059074 ## $ timer_estdbh_time_mins &lt;dbl&gt; 0.02290262 ## $ timer_silv_time_mins &lt;dbl&gt; 0.01256553 ## $ timer_total_time_mins &lt;dbl&gt; 13.36189 ## $ sttng_input_las_dir &lt;chr&gt; &quot;D:/Metashape_Testing_2024&quot; ## $ sttng_use_parallel_processing &lt;lgl&gt; FALSE ## $ sttng_desired_chm_res &lt;dbl&gt; 0.25 ## $ sttng_max_height_threshold_m &lt;int&gt; 60 ## $ sttng_minimum_tree_height_m &lt;int&gt; 2 ## $ sttng_dbh_max_size_m &lt;int&gt; 2 ## $ sttng_local_dbh_model &lt;chr&gt; &quot;rf&quot; ## $ sttng_user_supplied_epsg &lt;lgl&gt; NA ## $ sttng_accuracy_level &lt;int&gt; 2 ## $ sttng_pts_m2_for_triangulation &lt;int&gt; 20 ## $ sttng_normalization_with &lt;chr&gt; &quot;triangulation&quot; ## $ sttng_competition_buffer_m &lt;int&gt; 5 ## $ depth_maps_generation_quality &lt;ord&gt; high ## $ depth_maps_generation_filtering_mode &lt;ord&gt; aggressive ## $ total_sfm_time_min &lt;dbl&gt; 54.8 ## $ number_of_points_sfm &lt;dbl&gt; 52974294 ## $ total_sfm_time_norm &lt;dbl&gt; 0.1117824 ## $ processed_data_dir &lt;chr&gt; &quot;E:/SfM_Software_Comparison/Meta… ## $ processing_id &lt;int&gt; 1 ## $ true_positive_n_trees &lt;int&gt; 229 ## $ commission_n_trees &lt;int&gt; 173 ## $ omission_n_trees &lt;int&gt; 772 ## $ f_score &lt;dbl&gt; 0.3264433 ## $ tree_height_m_me &lt;dbl&gt; 0.2703367 ## $ tree_height_m_mpe &lt;dbl&gt; 0.002357383 ## $ tree_height_m_mae &lt;dbl&gt; 0.787361 ## $ tree_height_m_mape &lt;dbl&gt; 0.06624939 ## $ tree_height_m_smape &lt;dbl&gt; 0.06776453 ## $ tree_height_m_mse &lt;dbl&gt; 0.9842433 ## $ tree_height_m_rmse &lt;dbl&gt; 0.9920904 ## $ dbh_cm_me &lt;dbl&gt; 2.055127 ## $ dbh_cm_mpe &lt;dbl&gt; 0.07707617 ## $ dbh_cm_mae &lt;dbl&gt; 5.091373 ## $ dbh_cm_mape &lt;dbl&gt; 0.2076874 ## $ dbh_cm_smape &lt;dbl&gt; 0.1966263 ## $ dbh_cm_mse &lt;dbl&gt; 44.38957 ## $ dbh_cm_rmse &lt;dbl&gt; 6.662549 ## $ uas_basal_area_m2 &lt;dbl&gt; 55.75278 ## $ field_basal_area_m2 &lt;dbl&gt; 69.04409 ## $ uas_basal_area_m2_per_ha &lt;dbl&gt; 31.97437 ## $ field_basal_area_m2_per_ha &lt;dbl&gt; 39.59697 ## $ basal_area_m2_error &lt;dbl&gt; -13.29131 ## $ basal_area_m2_per_ha_error &lt;dbl&gt; -7.622601 ## $ basal_area_pct_error &lt;dbl&gt; -0.1925047 ## $ basal_area_abs_pct_error &lt;dbl&gt; 0.1925047 ## $ overstory_commission_n_trees &lt;int&gt; 141 ## $ understory_commission_n_trees &lt;int&gt; 32 ## $ overstory_omission_n_trees &lt;int&gt; 558 ## $ understory_omission_n_trees &lt;int&gt; 214 ## $ overstory_true_positive_n_trees &lt;int&gt; 185 ## $ understory_true_positive_n_trees &lt;int&gt; 44 ## $ overstory_f_score &lt;dbl&gt; 0.3461179 ## $ understory_f_score &lt;dbl&gt; 0.2634731 ## $ overstory_tree_height_m_me &lt;dbl&gt; 0.4169317 ## $ understory_tree_height_m_me &lt;dbl&gt; -0.3460289 ## $ overstory_tree_height_m_mpe &lt;dbl&gt; 0.02079067 ## $ understory_tree_height_m_mpe &lt;dbl&gt; -0.07514623 ## $ overstory_tree_height_m_mae &lt;dbl&gt; 0.8201433 ## $ understory_tree_height_m_mae &lt;dbl&gt; 0.6495266 ## $ overstory_tree_height_m_mape &lt;dbl&gt; 0.04662933 ## $ understory_tree_height_m_mape &lt;dbl&gt; 0.1487428 ## $ overstory_tree_height_m_smape &lt;dbl&gt; 0.04589942 ## $ understory_tree_height_m_smape &lt;dbl&gt; 0.1596974 ## $ overstory_tree_height_m_mse &lt;dbl&gt; 1.062376 ## $ understory_tree_height_m_mse &lt;dbl&gt; 0.65573 ## $ overstory_tree_height_m_rmse &lt;dbl&gt; 1.030716 ## $ understory_tree_height_m_rmse &lt;dbl&gt; 0.8097715 ## $ overstory_dbh_cm_me &lt;dbl&gt; 2.882251 ## $ understory_dbh_cm_me &lt;dbl&gt; -1.422553 ## $ overstory_dbh_cm_mpe &lt;dbl&gt; 0.1119944 ## $ understory_dbh_cm_mpe &lt;dbl&gt; -0.06973931 ## $ overstory_dbh_cm_mae &lt;dbl&gt; 5.75301 ## $ understory_dbh_cm_mae &lt;dbl&gt; 2.309487 ## $ overstory_dbh_cm_mape &lt;dbl&gt; 0.1862021 ## $ understory_dbh_cm_mape &lt;dbl&gt; 0.2980235 ## $ overstory_dbh_cm_smape &lt;dbl&gt; 0.1686851 ## $ understory_dbh_cm_smape &lt;dbl&gt; 0.3141064 ## $ overstory_dbh_cm_mse &lt;dbl&gt; 52.7825 ## $ understory_dbh_cm_mse &lt;dbl&gt; 9.101103 ## $ overstory_dbh_cm_rmse &lt;dbl&gt; 7.265156 ## $ understory_dbh_cm_rmse &lt;dbl&gt; 3.016803 ## $ overstory_uas_basal_area_m2 &lt;dbl&gt; 55.49096 ## $ understory_uas_basal_area_m2 &lt;dbl&gt; 0.2618258 ## $ overstory_field_basal_area_m2 &lt;dbl&gt; 67.50326 ## $ understory_field_basal_area_m2 &lt;dbl&gt; 1.540832 ## $ overstory_uas_basal_area_m2_per_ha &lt;dbl&gt; 31.82421 ## $ understory_uas_basal_area_m2_per_ha &lt;dbl&gt; 0.1501578 ## $ overstory_field_basal_area_m2_per_ha &lt;dbl&gt; 38.7133 ## $ understory_field_basal_area_m2_per_ha &lt;dbl&gt; 0.883671 ## $ overstory_basal_area_m2_per_ha_error &lt;dbl&gt; -6.889088 ## $ understory_basal_area_m2_per_ha_error &lt;dbl&gt; -0.7335132 ## $ overstory_basal_area_pct_error &lt;dbl&gt; -0.1779515 ## $ understory_basal_area_pct_error &lt;dbl&gt; -0.830075 ## $ overstory_basal_area_abs_pct_error &lt;dbl&gt; 0.1779515 ## $ understory_basal_area_abs_pct_error &lt;dbl&gt; 0.830075 ## $ validation_file_full_path &lt;chr&gt; &quot;E:/SfM_Software_Comparison/Meta… ## $ overstory_ht_m &lt;dbl&gt; 7 the output file is the same thing as field_uas_comparison_fn # output file is the same thing as field_uas_comparison_fn validation_temp$validation_file_full_path %&gt;% readr::read_csv() %&gt;% dplyr::glimpse() ## Rows: 1,174 ## Columns: 30 ## $ field_uas_group &lt;chr&gt; &quot;true positive&quot;, &quot;true positive&quot;,… ## $ uas_tree_id &lt;chr&gt; &quot;1000_-157206.9_4068542.9&quot;, &quot;1020… ## $ field_tree_id &lt;dbl&gt; 96, 82, 87, 42, 77, 85, 51, 56, 4… ## $ height_diff_pct &lt;dbl&gt; -0.065845684, -0.014773812, 0.009… ## $ field_uas_distance_m &lt;dbl&gt; 0.5527370, 1.7755352, 2.1687497, … ## $ uas_dbh_cm &lt;dbl&gt; 18.206771, 38.308104, 28.830423, … ## $ uas_basal_area_m2 &lt;dbl&gt; 0.026034891, 0.115258031, 0.06528… ## $ uas_tree_utm_x &lt;dbl&gt; 380396.4, 380441.5, 380403.7, 380… ## $ uas_tree_utm_y &lt;dbl&gt; 4044246, 4044246, 4044240, 404423… ## $ field_dbh_cm &lt;dbl&gt; 25.908, 33.020, 28.448, 34.290, 4… ## $ field_basal_area_m2 &lt;dbl&gt; 0.052717846, 0.085633564, 0.06356… ## $ field_tree_utm_x &lt;dbl&gt; 380396.4, 380441.9, 380403.7, 380… ## $ field_tree_utm_y &lt;dbl&gt; 4044246, 4044244, 4044242, 404423… ## $ uas_tree_height_m &lt;dbl&gt; 10.851, 19.284, 15.638, 20.122, 2… ## $ field_tree_height_m &lt;dbl&gt; 11.615854, 19.573171, 15.487805, … ## $ dbh_diff_cm &lt;dbl&gt; -7.7012286, 5.2881039, 0.3824233,… ## $ tree_height_diff_m &lt;dbl&gt; -0.7648538, -0.2891703, 0.1501947… ## $ dbh_diff_pct &lt;dbl&gt; -0.29725292, 0.16014851, 0.013442… ## $ abs_dbh_diff_pct &lt;dbl&gt; 0.29725292, 0.16014851, 0.0134428… ## $ abs_height_diff_pct &lt;dbl&gt; 0.065845684, 0.014773812, 0.00969… ## $ overstory_understory_grp &lt;chr&gt; &quot;overstory&quot;, &quot;overstory&quot;, &quot;overst… ## $ overstory_ht_m &lt;dbl&gt; 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, … ## $ processing_id &lt;dbl&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, … ## $ study_site &lt;chr&gt; &quot;KAIBAB_HIGH&quot;, &quot;KAIBAB_HIGH&quot;, &quot;KA… ## $ file_name &lt;chr&gt; &quot;HIGH_AGGRESSIVE&quot;, &quot;HIGH_AGGRESSI… ## $ software &lt;chr&gt; &quot;METASHAPE&quot;, &quot;METASHAPE&quot;, &quot;METASH… ## $ depth_maps_generation_quality &lt;chr&gt; &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;… ## $ depth_maps_generation_filtering_mode &lt;chr&gt; &quot;aggressive&quot;, &quot;aggressive&quot;, &quot;aggr… ## $ processing_attribute3 &lt;lgl&gt; NA, NA, NA, NA, NA, NA, NA, NA, N… ## $ processed_data_dir &lt;chr&gt; &quot;D:/SfM_Software_Comparison/Metas… 5.4 Full pipeline function function to map over study sites represented in ptcld_processing_data # function to map over study sites represented in ptcld_processing_data # set up in a way so that only have to read field data from disk once and # perform validation for each uas data represented for that site in ptcld_processing_data # Returns: # 1) write full validation tree list to disk # 2) update ptcld_processing_data with metrics for testing: # f-score # ht rmse # dbh rmse # path to validation tree list full_validation_fn = function(study_site_nm) { # filter plot data validation_plot = validation_plots %&gt;% dplyr::filter(study_site == study_site_nm) # read field data field_data = read_field_data(study_site_nm) # # map over file validation function and return data # function for a file name identified by processing_id in ptcld_processing_data d = ptcld_processing_data %&gt;% dplyr::filter(study_site == study_site_nm) %&gt;% dplyr::pull(processing_id) %&gt;% purrr::map(validate_file_fn, fld_dta = field_data, plt_dta = validation_plot) %&gt;% dplyr::bind_rows() # return return(d) } 5.5 Apply validation for all ptcld_validation_data = study_site_list %&gt;% purrr::map(full_validation_fn) %&gt;% dplyr::bind_rows() # write this! write.csv( ptcld_validation_data , &quot;../data/ptcld_full_analysis_data.csv&quot; , row.names = F ) what is this validation data? ptcld_validation_data %&gt;% dplyr::glimpse() ## Rows: 260 ## Columns: 114 ## $ tracking_file_full_path &lt;chr&gt; &quot;E:\\\\SfM_Software_Comparison\\\\Me… ## $ software &lt;chr&gt; &quot;METASHAPE&quot;, &quot;METASHAPE&quot;, &quot;METAS… ## $ study_site &lt;chr&gt; &quot;KAIBAB_HIGH&quot;, &quot;KAIBAB_HIGH&quot;, &quot;K… ## $ processing_attribute1 &lt;chr&gt; &quot;HIGH&quot;, &quot;HIGH&quot;, &quot;HIGH&quot;, &quot;HIGH&quot;, … ## $ processing_attribute2 &lt;chr&gt; &quot;AGGRESSIVE&quot;, &quot;DISABLED&quot;, &quot;MILD&quot;… ## $ processing_attribute3 &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, … ## $ file_name &lt;chr&gt; &quot;HIGH_AGGRESSIVE&quot;, &quot;HIGH_DISABLE… ## $ number_of_points &lt;int&gt; 52974294, 72549206, 69858217, 69… ## $ las_area_m2 &lt;dbl&gt; 86661.27, 87175.42, 86404.78, 86… ## $ timer_tile_time_mins &lt;dbl&gt; 0.63600698, 2.49318542, 0.841338… ## $ timer_class_dtm_norm_chm_time_mins &lt;dbl&gt; 3.6559556, 5.3289152, 5.1638296,… ## $ timer_treels_time_mins &lt;dbl&gt; 8.9065272, 19.2119663, 12.339179… ## $ timer_itd_time_mins &lt;dbl&gt; 0.02202115, 0.02449968, 0.037984… ## $ timer_competition_time_mins &lt;dbl&gt; 0.10590740, 0.17865245, 0.121248… ## $ timer_estdbh_time_mins &lt;dbl&gt; 0.02290262, 0.02382533, 0.021991… ## $ timer_silv_time_mins &lt;dbl&gt; 0.012565533, 0.015940932, 0.0150… ## $ timer_total_time_mins &lt;dbl&gt; 13.361886, 27.276985, 18.540606,… ## $ sttng_input_las_dir &lt;chr&gt; &quot;D:/Metashape_Testing_2024&quot;, &quot;D:… ## $ sttng_use_parallel_processing &lt;lgl&gt; FALSE, FALSE, FALSE, FALSE, FALS… ## $ sttng_desired_chm_res &lt;dbl&gt; 0.25, 0.25, 0.25, 0.25, 0.25, 0.… ## $ sttng_max_height_threshold_m &lt;int&gt; 60, 60, 60, 60, 60, 60, 60, 60, … ## $ sttng_minimum_tree_height_m &lt;int&gt; 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,… ## $ sttng_dbh_max_size_m &lt;int&gt; 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,… ## $ sttng_local_dbh_model &lt;chr&gt; &quot;rf&quot;, &quot;rf&quot;, &quot;rf&quot;, &quot;rf&quot;, &quot;rf&quot;, &quot;r… ## $ sttng_user_supplied_epsg &lt;lgl&gt; NA, NA, NA, NA, NA, NA, NA, NA, … ## $ sttng_accuracy_level &lt;int&gt; 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,… ## $ sttng_pts_m2_for_triangulation &lt;int&gt; 20, 20, 20, 20, 20, 20, 20, 20, … ## $ sttng_normalization_with &lt;chr&gt; &quot;triangulation&quot;, &quot;triangulation&quot;… ## $ sttng_competition_buffer_m &lt;int&gt; 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,… ## $ depth_maps_generation_quality &lt;ord&gt; high, high, high, high, low, low… ## $ depth_maps_generation_filtering_mode &lt;ord&gt; aggressive, disabled, mild, mode… ## $ total_sfm_time_min &lt;dbl&gt; 54.800000, 60.316667, 55.933333,… ## $ number_of_points_sfm &lt;dbl&gt; 52974294, 72549206, 69858217, 69… ## $ total_sfm_time_norm &lt;dbl&gt; 0.1117823680, 0.1237564664, 0.11… ## $ processed_data_dir &lt;chr&gt; &quot;E:/SfM_Software_Comparison/Meta… ## $ processing_id &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1… ## $ true_positive_n_trees &lt;dbl&gt; 229, 261, 260, 234, 220, 175, 23… ## $ commission_n_trees &lt;dbl&gt; 173, 222, 213, 193, 148, 223, 16… ## $ omission_n_trees &lt;dbl&gt; 772, 740, 741, 767, 781, 826, 77… ## $ f_score &lt;dbl&gt; 0.3264433, 0.3517520, 0.3527815,… ## $ tree_height_m_me &lt;dbl&gt; 0.270336679, 0.283568790, 0.3122… ## $ tree_height_m_mpe &lt;dbl&gt; 0.002357383, 0.013286785, 0.0142… ## $ tree_height_m_mae &lt;dbl&gt; 0.7873610, 0.6886235, 0.6914983,… ## $ tree_height_m_mape &lt;dbl&gt; 0.06624939, 0.06903969, 0.060550… ## $ tree_height_m_smape &lt;dbl&gt; 0.06776453, 0.06838733, 0.060410… ## $ tree_height_m_mse &lt;dbl&gt; 0.9842433, 0.8507862, 0.8259923,… ## $ tree_height_m_rmse &lt;dbl&gt; 0.9920904, 0.9223807, 0.9088412,… ## $ dbh_cm_me &lt;dbl&gt; 2.0551269, 1.2718827, 1.7505679,… ## $ dbh_cm_mpe &lt;dbl&gt; 0.077076168, 0.056392083, 0.0755… ## $ dbh_cm_mae &lt;dbl&gt; 5.091373, 4.375871, 4.674437, 4.… ## $ dbh_cm_mape &lt;dbl&gt; 0.2076874, 0.2185989, 0.2110014,… ## $ dbh_cm_smape &lt;dbl&gt; 0.1966263, 0.2081000, 0.1986588,… ## $ dbh_cm_mse &lt;dbl&gt; 44.38957, 35.29251, 38.33622, 38… ## $ dbh_cm_rmse &lt;dbl&gt; 6.662549, 5.940750, 6.191625, 6.… ## $ uas_basal_area_m2 &lt;dbl&gt; 55.75278, 60.26123, 58.67391, 57… ## $ field_basal_area_m2 &lt;dbl&gt; 69.04409, 69.04409, 69.04409, 69… ## $ uas_basal_area_m2_per_ha &lt;dbl&gt; 31.97437, 34.55997, 33.64964, 33… ## $ field_basal_area_m2_per_ha &lt;dbl&gt; 39.59697, 39.59697, 39.59697, 39… ## $ basal_area_m2_error &lt;dbl&gt; -13.291309, -8.782866, -10.37018… ## $ basal_area_m2_per_ha_error &lt;dbl&gt; -7.622601, -5.036997, -5.947326,… ## $ basal_area_pct_error &lt;dbl&gt; -0.19250466, -0.12720663, -0.150… ## $ basal_area_abs_pct_error &lt;dbl&gt; 0.19250466, 0.12720663, 0.150196… ## $ overstory_commission_n_trees &lt;dbl&gt; 141, 178, 178, 160, 95, 173, 120… ## $ understory_commission_n_trees &lt;dbl&gt; 32, 44, 35, 33, 53, 50, 43, 39, … ## $ overstory_omission_n_trees &lt;dbl&gt; 558, 560, 545, 556, 554, 598, 54… ## $ understory_omission_n_trees &lt;dbl&gt; 214, 180, 196, 211, 227, 228, 22… ## $ overstory_true_positive_n_trees &lt;dbl&gt; 185, 183, 198, 187, 189, 145, 19… ## $ understory_true_positive_n_trees &lt;dbl&gt; 44, 78, 62, 47, 31, 30, 33, 40, … ## $ overstory_f_score &lt;dbl&gt; 0.3461179, 0.3315217, 0.3538874,… ## $ understory_f_score &lt;dbl&gt; 0.2634731, 0.4105263, 0.3492958,… ## $ overstory_tree_height_m_me &lt;dbl&gt; 0.41693172, 0.44114110, 0.442167… ## $ understory_tree_height_m_me &lt;dbl&gt; -0.34602886, -0.08612009, -0.102… ## $ overstory_tree_height_m_mpe &lt;dbl&gt; 0.020790675, 0.024558478, 0.0241… ## $ understory_tree_height_m_mpe &lt;dbl&gt; -0.075146232, -0.013158341, -0.0… ## $ overstory_tree_height_m_mae &lt;dbl&gt; 0.8201433, 0.7820879, 0.7770369,… ## $ understory_tree_height_m_mae &lt;dbl&gt; 0.6495266, 0.4693415, 0.4183269,… ## $ overstory_tree_height_m_mape &lt;dbl&gt; 0.04662933, 0.04863237, 0.048708… ## $ understory_tree_height_m_mape &lt;dbl&gt; 0.14874284, 0.11691842, 0.098369… ## $ overstory_tree_height_m_smape &lt;dbl&gt; 0.04589942, 0.04776615, 0.047912… ## $ understory_tree_height_m_smape &lt;dbl&gt; 0.15969736, 0.11676780, 0.100322… ## $ overstory_tree_height_m_mse &lt;dbl&gt; 1.0623763, 1.0055835, 0.9739823,… ## $ understory_tree_height_m_mse &lt;dbl&gt; 0.6557300, 0.4876080, 0.3533791,… ## $ overstory_tree_height_m_rmse &lt;dbl&gt; 1.0307164, 1.0027878, 0.9869054,… ## $ understory_tree_height_m_rmse &lt;dbl&gt; 0.8097715, 0.6982893, 0.5944570,… ## $ overstory_dbh_cm_me &lt;dbl&gt; 2.88225065, 2.37098111, 2.694675… ## $ understory_dbh_cm_me &lt;dbl&gt; -1.4225525, -1.3067712, -1.26448… ## $ overstory_dbh_cm_mpe &lt;dbl&gt; 0.11199444, 0.09928650, 0.110477… ## $ understory_dbh_cm_mpe &lt;dbl&gt; -0.06973931, -0.04424482, -0.035… ## $ overstory_dbh_cm_mae &lt;dbl&gt; 5.753010, 5.298094, 5.472454, 5.… ## $ understory_dbh_cm_mae &lt;dbl&gt; 2.309487, 2.212192, 2.125931, 2.… ## $ overstory_dbh_cm_mape &lt;dbl&gt; 0.1862021, 0.1848729, 0.1898205,… ## $ understory_dbh_cm_mape &lt;dbl&gt; 0.2980235, 0.2977254, 0.2786439,… ## $ overstory_dbh_cm_smape &lt;dbl&gt; 0.1686851, 0.1699578, 0.1735200,… ## $ understory_dbh_cm_smape &lt;dbl&gt; 0.3141064, 0.2975874, 0.2789409,… ## $ overstory_dbh_cm_mse &lt;dbl&gt; 52.78250, 46.57941, 47.70797, 46… ## $ understory_dbh_cm_mse &lt;dbl&gt; 9.101103, 8.811704, 8.407077, 9.… ## $ overstory_dbh_cm_rmse &lt;dbl&gt; 7.265156, 6.824911, 6.907095, 6.… ## $ understory_dbh_cm_rmse &lt;dbl&gt; 3.016803, 2.968451, 2.899496, 3.… ## $ overstory_uas_basal_area_m2 &lt;dbl&gt; 55.49096, 59.79139, 58.30184, 57… ## $ understory_uas_basal_area_m2 &lt;dbl&gt; 0.2618258, 0.4698415, 0.3720740,… ## $ overstory_field_basal_area_m2 &lt;dbl&gt; 67.50326, 67.50326, 67.50326, 67… ## $ understory_field_basal_area_m2 &lt;dbl&gt; 1.540832, 1.540832, 1.540832, 1.… ## $ overstory_uas_basal_area_m2_per_ha &lt;dbl&gt; 31.82421, 34.29052, 33.43626, 32… ## $ understory_uas_basal_area_m2_per_ha &lt;dbl&gt; 0.15015781, 0.26945534, 0.213385… ## $ overstory_field_basal_area_m2_per_ha &lt;dbl&gt; 38.7133, 38.7133, 38.7133, 38.71… ## $ understory_field_basal_area_m2_per_ha &lt;dbl&gt; 0.883671, 0.883671, 0.883671, 0.… ## $ overstory_basal_area_m2_per_ha_error &lt;dbl&gt; -6.889088, -4.422782, -5.277041,… ## $ understory_basal_area_m2_per_ha_error &lt;dbl&gt; -0.7335132, -0.6142157, -0.67028… ## $ overstory_basal_area_pct_error &lt;dbl&gt; -0.17795146, -0.11424450, -0.136… ## $ understory_basal_area_pct_error &lt;dbl&gt; -0.8300750, -0.6950728, -0.75852… ## $ overstory_basal_area_abs_pct_error &lt;dbl&gt; 0.17795146, 0.11424450, 0.136310… ## $ understory_basal_area_abs_pct_error &lt;dbl&gt; 0.8300750, 0.6950728, 0.7585239,… ## $ validation_file_full_path &lt;chr&gt; &quot;E:/SfM_Software_Comparison/Meta… ## $ overstory_ht_m &lt;dbl&gt; 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,… # summary of validation metrics ptcld_validation_data %&gt;% dplyr::select(f_score, tree_height_m_mape, dbh_cm_mape) %&gt;% summary() ## f_score tree_height_m_mape dbh_cm_mape ## Min. :0.0000 Min. :0.02518 Min. :0.0745 ## 1st Qu.:0.2983 1st Qu.:0.05239 1st Qu.:0.1489 ## Median :0.4425 Median :0.06231 Median :0.2185 ## Mean :0.4611 Mean :0.06575 Mean :0.2177 ## 3rd Qu.:0.6222 3rd Qu.:0.07139 3rd Qu.:0.2659 ## Max. :0.8997 Max. :0.15715 Max. :0.6367 ## NA&#39;s :2 NA&#39;s :2 5.6 Full Validation Summary Data 5.6.1 True Positive, Commission, Ommission Summary of tree true positive (\\(TP\\)), commission (\\(Co\\)), and omission (\\(Om\\)) detection by depth map quality and filtering mode plt_fn_temp = function(site = study_site_list[1]){ ptcld_validation_data %&gt;% dplyr::filter(study_site == site) %&gt;% dplyr::mutate( plot_lab = forcats::fct_cross(depth_maps_generation_quality,depth_maps_generation_filtering_mode) ) %&gt;% dplyr::mutate(plot_lab = forcats::fct_reorder( plot_lab , .x = depth_maps_generation_quality , .fun = max ) %&gt;% forcats::fct_rev() ) %&gt;% dplyr::select( software, plot_lab, tidyselect::ends_with(&quot;_n_trees&quot;) &amp; !tidyselect::starts_with(&quot;overstory_&quot;) &amp; !tidyselect::starts_with(&quot;understory_&quot;) ) %&gt;% tidyr::pivot_longer( cols = -c(software,plot_lab) , values_drop_na = F ) %&gt;% dplyr::group_by(software,plot_lab) %&gt;% dplyr::mutate( field_uas_group = name %&gt;% stringr::str_remove_all(&quot;_n_trees&quot;) %&gt;% stringr::str_replace_all(&quot;_&quot;,&quot; &quot;) %&gt;% factor( ordered = T , levels = c( &quot;true positive&quot; , &quot;commission&quot; , &quot;omission&quot; ) ) %&gt;% forcats::fct_rev() , pct = dplyr::coalesce(value,0)/sum(dplyr::coalesce(value,0)) ) %&gt;% dplyr::ungroup() %&gt;% ggplot( mapping = aes(x = pct, y = plot_lab, fill=field_uas_group, group=field_uas_group) ) + geom_col( width = 0.7, alpha=0.8 ) + geom_text( mapping = aes( label = scales::percent(ifelse(pct&gt;=0.12,pct,NA), accuracy = 1) , fontface = &quot;bold&quot; ) , position = position_stack(vjust = 0.5) , color = &quot;black&quot;, size = 2.3 ) + facet_grid(cols = vars(software)) + scale_fill_viridis_d(option = &quot;cividis&quot;) + scale_x_continuous(labels = scales::percent_format()) + labs( fill = &quot;&quot; , y = &quot;&quot; , x = &quot;Percent of Trees&quot; # , title = &quot;UAS and Stem-Mapped Tree Validation Summary&quot; , subtitle = paste0(&quot;plot: &quot;, site) ) + theme_light() + theme( legend.position = &quot;top&quot; , legend.direction = &quot;horizontal&quot; , legend.title = element_text(size=7) , axis.title.x = element_text(size=8, face = &quot;bold&quot;) , axis.title.y = element_blank() , axis.text.x = element_blank() , axis.text.y = element_text(color = &quot;black&quot;,size=8) , axis.ticks.x = element_blank() , panel.grid.major.x = element_blank() , panel.grid.minor.x = element_blank() , strip.text = element_text(color = &quot;black&quot;, face = &quot;bold&quot;) ) + guides( fill = guide_legend(reverse = T, override.aes = list(alpha = 0.9)) ) } # map over sites plt_list_temp = study_site_list %&gt;% purrr::map(plt_fn_temp) # combine patchwork::wrap_plots(plt_list_temp, ncol = 2, guides = &quot;collect&quot;) &amp; theme(legend.position=&quot;bottom&quot;) 5.6.2 F-score plt_fn_temp = function(site = study_site_list[1]){ ptcld_validation_data %&gt;% dplyr::filter(study_site == site) %&gt;% dplyr::mutate( plot_lab = forcats::fct_cross(depth_maps_generation_quality,depth_maps_generation_filtering_mode) ) %&gt;% dplyr::mutate(plot_lab = forcats::fct_reorder( plot_lab , .x = depth_maps_generation_quality , .fun = max ) %&gt;% forcats::fct_rev() ) %&gt;% dplyr::distinct(software,plot_lab,f_score) %&gt;% ggplot( mapping = aes(x = f_score, y = plot_lab, fill=f_score, label = scales::comma(f_score, accuracy = 0.01)) ) + geom_col( width = 0.7 ) + geom_text( color = &quot;black&quot;, size = 2.3 , hjust = -0.1 ) + facet_grid(cols = vars(software)) + scale_fill_viridis_c(option = &quot;mako&quot;, direction = -1, begin = 0.1, limits = c(0,max(ptcld_validation_data$f_score)*1.14)) + scale_x_continuous(limits = c(0,max(ptcld_validation_data$f_score)*1.14), breaks = NULL) + labs( fill = &quot;&quot; , y = &quot;&quot; , x = &quot;F-Score&quot; # , title = &quot;UAS and Stem-Mapped Tree F-Score Summary&quot; , subtitle = paste0(&quot;plot: &quot;, site) ) + theme_light() + theme( legend.position = &quot;none&quot; , axis.title.x = element_text(size=8, face = &quot;bold&quot;) , axis.title.y = element_blank() , axis.text.x = element_blank() , axis.text.y = element_text(color = &quot;black&quot;,size=8) , axis.ticks.x = element_blank() , panel.grid.major.x = element_blank() , panel.grid.minor.x = element_blank() , strip.text = element_text(color = &quot;black&quot;, face = &quot;bold&quot;) ) + guides( fill = guide_legend(reverse = T, override.aes = list(alpha = 0.9)) ) } # plt_fn_temp() # map over sites plt_list_temp = study_site_list %&gt;% purrr::map(plt_fn_temp) # combine patchwork::wrap_plots(plt_list_temp, ncol = 2) 5.7 Example Validation Process Let’s go through one example for KAIBAB_LOW 5.7.1 Data Load Data load using functions defined above for KAIBAB_LOW # validation plot boundary plot_bound_temp = validation_plots %&gt;% dplyr::filter(study_site==study_site_list[2]) # read field data field_data_temp = read_field_data(my_study_site = study_site_list[2]) # read_uas_data uas_data_temp = read_uas_data( my_processing_id = ptcld_processing_data %&gt;% dplyr::filter(study_site==study_site_list[2]) %&gt;% dplyr::pull(processing_id) %&gt;% .[1] , my_crs = sf::st_crs(field_data_temp) ) # true positive true_positive_trees_temp = true_positive_trees_fn(uas_data = uas_data_temp, field_data = field_data_temp) # field_uas_comparison_fn field_uas_comparison_temp = field_uas_comparison_fn( uas_data = uas_data_temp , field_data = field_data_temp , true_positive_trees = true_positive_trees_temp , plot_data = plot_bound_temp ) get the orthomosaic (here using from ODM ultra-lowest) from the directory titled field_validation/orthomosaic with the name of the site as the file name (e.g.; “kaibab_high.tif”) # let&#39;s load the orthomosaic for this site too # put the orthomosaic images (here using from ODM ultra-lowest) in a folder # ...titled &quot;field_validation/orthomosaic&quot; with the name of the site as the file (&quot;kaibab_high.tif&quot;) ortho_list = list.files( &quot;../data/field_validation/orthomosaic/&quot; , pattern = &quot;.*\\\\.(tif|tiff)$&quot; , full.names = T ) # load raster ortho_rast = ortho_list %&gt;% purrr::pluck( ortho_list %&gt;% toupper() %&gt;% stringr::str_which(pattern = study_site_list[2]) %&gt;% .[1] ) %&gt;% terra::rast() # aggregate to lower resolution if needed if(terra::res(ortho_rast)[1]&lt;0.5){ ortho_rast = terra::aggregate( ortho_rast , fact = round(0.5/terra::res(ortho_rast)[1]) , fun = &quot;median&quot; , cores = round(parallel::detectCores()/2) ) } # ortho_rast # terra::res(ortho_rast) # ortho_rast %&gt;% # terra::aggregate(2) %&gt;% # terra::plotRGB(r = 1, g = 2, b = 3, stretch = &quot;lin&quot;, colNA = &quot;transparent&quot;) # convert to stars ortho_st = ortho_rast %&gt;% terra::subset(subset = c(1,2,3)) %&gt;% terra::crop( # stand %&gt;% plot_bound_temp %&gt;% sf::st_buffer(2) %&gt;% sf::st_bbox() %&gt;% sf::st_as_sfc() %&gt;% terra::vect() %&gt;% terra::project(terra::crs(ortho_rast)) ) %&gt;% stars::st_as_stars() # convert to rgb ortho_rgb = stars::st_rgb( ortho_st[,,,1:3] , dimension = 3 , use_alpha = FALSE # , stretch = &quot;histogram&quot; , probs = c(0.005, 0.995) , stretch = &quot;percent&quot; ) what is all this data? 5.7.2 Orthomosaic Data ortho_rast ortho_rast ## class : SpatRaster ## dimensions : 573, 556, 4 (nrow, ncol, nlyr) ## resolution : 0.5, 0.4999662 (x, y) ## extent : 380355.9, 380633.9, 4044343, 4044630 (xmin, xmax, ymin, ymax) ## coord. ref. : WGS 84 / UTM zone 12N (EPSG:32612) ## source(s) : memory ## names : red, green, blue, kaibab_low_4 ## min values : 0, 0, 0, 0 ## max values : 226, 229, 232, 255 plot it # ggplot rgb plt_rgb = ggplot() + stars::geom_stars(data = ortho_rgb[]) + scale_fill_identity(na.value = &quot;transparent&quot;) + # !!! don&#39;t take this out or RGB plot will kill your computer # add plot boundary geom_sf( data = plot_bound_temp %&gt;% terra::vect() %&gt;% terra::project(terra::crs(ortho_rast)) %&gt;% sf::st_as_sf() , alpha = 0 , lwd = 1.2 , color = &quot;blue&quot; ) + scale_x_continuous(expand = c(0, 0)) + scale_y_continuous(expand = c(0, 0)) + labs( x = &quot;&quot; , y = &quot;&quot; ) + theme_void() # plot + boundary plt_rgb 5.7.3 Field Data field_data # field_data field_data_temp %&gt;% dplyr::glimpse() ## Rows: 510 ## Columns: 16 ## $ field_tree_id &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, … ## $ site &lt;chr&gt; &quot;Kaibab - Low&quot;, &quot;Kaibab - Low&quot;, &quot;Kaibab - L… ## $ northing &lt;dbl&gt; 4044408, 4044405, 4044436, 4044436, 4044443… ## $ easting &lt;dbl&gt; 380523.9, 380536.4, 380528.6, 380528.3, 380… ## $ spp &lt;chr&gt; &quot;PIPO&quot;, &quot;PIPO&quot;, &quot;PIPO&quot;, &quot;PIPO&quot;, &quot;PIPO&quot;, &quot;PI… ## $ a.d &lt;lgl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,… ## $ field_dbh_cm &lt;dbl&gt; 56.642, 60.960, 13.970, 56.896, 34.544, 45.… ## $ cbh_m &lt;dbl&gt; 14.268293, 15.914634, 2.439024, 10.762195, … ## $ field_tree_height_m &lt;dbl&gt; 26.646341, 24.756098, 6.676829, 23.201220, … ## $ notes &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,… ## $ study_site &lt;chr&gt; &quot;KAIBAB_LOW&quot;, &quot;KAIBAB_LOW&quot;, &quot;KAIBAB_LOW&quot;, &quot;… ## $ intersected_with_plot_geom &lt;lgl&gt; TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, T… ## $ geometry &lt;POINT [m]&gt; POINT (380523.9 4044408), POINT (3805… ## $ tree_utm_x &lt;dbl&gt; 380523.9, 380536.4, 380528.6, 380528.3, 380… ## $ tree_utm_y &lt;dbl&gt; 4044408, 4044405, 4044436, 4044436, 4044443… ## $ basal_area_m2 &lt;dbl&gt; 0.25198056, 0.29186351, 0.01532790, 0.25424… plot it plt_field_data_temp = plt_rgb + ggnewscale::new_scale_fill() + geom_sf( data = field_data_temp %&gt;% terra::vect() %&gt;% terra::project(terra::crs(ortho_rast)) %&gt;% sf::st_as_sf() , mapping = aes(fill = field_tree_height_m) , shape = 21 , size = 1.1 ) + scale_fill_viridis_c( option=&quot;plasma&quot;, alpha = 0.6, name = &quot;ht. (m)&quot; , limits = c( min(field_data_temp$field_tree_height_m, na.rm = T) , max(field_data_temp$field_tree_height_m, na.rm = T) ) , breaks = scales::breaks_extended(6) ) + labs(subtitle = &quot;field mapped trees&quot;) # plot plt_field_data_temp 5.7.4 UAS Data uas_data # uas_data uas_data_temp %&gt;% dplyr::glimpse() ## Rows: 1,592 ## Columns: 23 ## $ treeid &lt;chr&gt; &quot;1_-157075.4_4068915.6&quot;, &quot;2_-157089.4_406891… ## $ tree_height_m &lt;dbl&gt; 5.357, 21.154, 12.778, 21.002, 20.948, 3.579… ## $ crown_area_m2 &lt;dbl&gt; 1.3125, 16.4375, 10.0000, 16.2500, 14.8125, … ## $ comp_trees_per_ha &lt;dbl&gt; 254.7643, 127.3822, 254.7643, 254.7643, 382.… ## $ comp_relative_tree_height &lt;dbl&gt; 41.92362, 100.00000, 100.00000, 100.00000, 9… ## $ comp_dist_to_nearest_m &lt;dbl&gt; 4.2500000, 8.4001488, 4.2500000, 2.6575365, … ## $ mean_crown_ht_m &lt;dbl&gt; 4.122833, 17.681132, 9.023225, 18.342263, 16… ## $ median_crown_ht_m &lt;dbl&gt; 4.445000, 18.034000, 9.382500, 19.767000, 17… ## $ min_crown_ht_m &lt;dbl&gt; 2.264000, 12.726000, 3.607500, 8.022000, 3.7… ## $ reg_est_dbh_cm &lt;dbl&gt; 8.343743, 44.429833, 22.647150, 43.713975, 4… ## $ reg_est_dbh_cm_lower &lt;dbl&gt; 4.410595, 23.389277, 11.940055, 23.033076, 2… ## $ reg_est_dbh_cm_upper &lt;dbl&gt; 13.253220, 70.603026, 36.013406, 69.666868, … ## $ is_training_data &lt;lgl&gt; FALSE, FALSE, FALSE, FALSE, TRUE, FALSE, FAL… ## $ dbh_cm &lt;dbl&gt; 8.343743, 44.429833, 22.647150, 43.713975, 4… ## $ dbh_m &lt;dbl&gt; 0.4186878, 0.4677839, 0.4125874, 0.4526102, … ## $ radius_m &lt;dbl&gt; 0.2093439, 0.2338919, 0.2062937, 0.2263051, … ## $ basal_area_m2 &lt;dbl&gt; 0.005467789, 0.155038385, 0.040282553, 0.150… ## $ basal_area_ft2 &lt;dbl&gt; 0.05885528, 1.66883318, 0.43360140, 1.615489… ## $ processing_id &lt;int&gt; 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, … ## $ rf_dbh_cm &lt;dbl&gt; 41.86878, 46.77839, 41.25874, 45.26102, 43.3… ## $ lin_dbh_cm &lt;dbl&gt; 20.76127, 47.00656, 30.15524, 46.64239, 43.3… ## $ lin_noint_dbh_cm &lt;dbl&gt; 2.690000, 51.017779, 10.817579, 49.589342, 4… ## $ geometry &lt;POINT [m]&gt; POINT (380503.8 4044624), POINT (38049… plot it plt_uas_data_temp = plt_rgb + ggnewscale::new_scale_fill() + geom_sf( data = uas_data_temp %&gt;% sf::st_transform(sf::st_crs(plot_bound_temp)) %&gt;% sf::st_intersection(plot_bound_temp %&gt;% sf::st_buffer(3)) %&gt;% terra::vect() %&gt;% terra::project(terra::crs(ortho_rast)) %&gt;% sf::st_as_sf() , mapping = aes(fill = tree_height_m) , shape = 21 , size = 1.1 ) + scale_fill_viridis_c( option=&quot;plasma&quot;, alpha = 0.6, name = &quot;ht. (m)&quot; , limits = c( min(field_data_temp$field_tree_height_m, na.rm = T) , max(field_data_temp$field_tree_height_m, na.rm = T) ) , breaks = scales::breaks_extended(6) ) + labs(subtitle = &quot;UAS detected trees&quot;) # plot plt_uas_data_temp 5.7.5 True Positives true_positive_trees # true_positive_trees true_positive_trees_temp %&gt;% dplyr::glimpse() ## Rows: 227 ## Columns: 7 ## $ uas_tree_id &lt;chr&gt; &quot;1009_-157051.4_4068750.6&quot;, &quot;1014_-157040.9_40687… ## $ field_tree_id &lt;int&gt; 119, 285, 295, 330, 120, 123, 329, 121, 124, 127,… ## $ uas_tree_height_m &lt;dbl&gt; 14.261, 21.799, 2.967, 3.563, 18.281, 18.785, 3.2… ## $ field_tree_height_m &lt;dbl&gt; 14.054878, 22.896341, 2.591463, 3.628049, 17.0731… ## $ height_diff_pct &lt;dbl&gt; 0.014665487, 0.047926507, 0.144912944, 0.01792942… ## $ field_uas_distance_m &lt;dbl&gt; 1.11155605, 1.11336058, 0.04502782, 0.86474303, 0… ## $ field_uas_group &lt;chr&gt; &quot;true positive&quot;, &quot;true positive&quot;, &quot;true positive&quot;… 5.7.6 Field &amp; UAS Comparison field_uas_comparison # field_uas_comparison field_uas_comparison_temp %&gt;% dplyr::glimpse() ## Rows: 818 ## Columns: 22 ## $ field_uas_group &lt;ord&gt; true positive, true positive, true positive, … ## $ uas_tree_id &lt;chr&gt; &quot;1009_-157051.4_4068750.6&quot;, &quot;1014_-157040.9_4… ## $ field_tree_id &lt;dbl&gt; 119, 285, 295, 330, 120, 123, 329, 121, 124, … ## $ height_diff_pct &lt;dbl&gt; 0.014665487, -0.047926507, 0.144912944, -0.01… ## $ field_uas_distance_m &lt;dbl&gt; 1.11155605, 1.11336058, 0.04502782, 0.8647430… ## $ uas_dbh_cm &lt;dbl&gt; 26.245856, 45.977434, 4.981910, 5.755637, 36.… ## $ uas_basal_area_m2 &lt;dbl&gt; 0.054101758, 0.166027239, 0.001949313, 0.0026… ## $ uas_tree_utm_x &lt;dbl&gt; 380537.9, 380548.3, 380487.0, 380545.8, 38053… ## $ uas_tree_utm_y &lt;dbl&gt; 4044462, 4044462, 4044454, 4044458, 4044453, … ## $ field_dbh_cm &lt;dbl&gt; 32.512, 49.276, 4.572, 10.160, 43.434, 30.734… ## $ field_basal_area_m2 &lt;dbl&gt; 0.083018953, 0.190704427, 0.001641732, 0.0081… ## $ field_tree_utm_x &lt;dbl&gt; 380538.9, 380549.1, 380487.0, 380546.7, 38053… ## $ field_tree_utm_y &lt;dbl&gt; 4044462, 4044462, 4044454, 4044458, 4044454, … ## $ uas_tree_height_m &lt;dbl&gt; 14.261, 21.799, 2.967, 3.563, 18.281, 18.785,… ## $ field_tree_height_m &lt;dbl&gt; 14.054878, 22.896341, 2.591463, 3.628049, 17.… ## $ dbh_diff_cm &lt;dbl&gt; -6.2661437, -3.2985657, 0.4099102, -4.4043635… ## $ tree_height_diff_m &lt;dbl&gt; 0.20612163, -1.09734168, 0.37553659, -0.06504… ## $ dbh_diff_pct &lt;dbl&gt; -0.19273326, -0.06694061, 0.08965665, -0.4335… ## $ abs_dbh_diff_pct &lt;dbl&gt; 0.19273326, 0.06694061, 0.08965665, 0.4335003… ## $ abs_height_diff_pct &lt;dbl&gt; 0.014665487, 0.047926507, 0.144912944, 0.0179… ## $ overstory_understory_grp &lt;fct&gt; overstory, overstory, understory, understory,… ## $ overstory_ht_m &lt;dbl&gt; 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, … no geometry, let’s attach it field_uas_comparison_temp = field_uas_comparison_temp %&gt;% dplyr::mutate( x = ifelse(!is.na(field_tree_utm_x), field_tree_utm_x, uas_tree_utm_x) , y = ifelse(!is.na(field_tree_utm_x), field_tree_utm_y, uas_tree_utm_y) ) %&gt;% sf::st_as_sf( coords = c(&quot;x&quot;, &quot;y&quot;) , crs = sf::st_crs(field_data_temp) , remove=T ) plot it plt_comparison_temp = plt_rgb + ggnewscale::new_scale_fill() + geom_sf( data = field_uas_comparison_temp %&gt;% terra::vect() %&gt;% terra::project(terra::crs(ortho_rast)) %&gt;% sf::st_as_sf() , mapping = aes(fill = field_uas_group) , color = &quot;black&quot; , shape = 21 , size = 1.1 ) + scale_fill_viridis_d(option = &quot;cividis&quot;, name = &quot;trees&quot;, drop = F, alpha = 0.7) + labs(subtitle = &quot;field &amp; UAS comparison trees&quot;) # plot plt_comparison_temp 5.7.7 Combine Plots combine these (plt_field_data_temp + theme(legend.position = &quot;none&quot;) + plt_uas_data_temp) / plt_comparison_temp ggplot2::ggsave(&quot;../data/field_uas_comparison.jpg&quot;, width = 8, height = 9) we can also view these with satellite imagery which is not what the UAS-derived tree detections are from but can be a good viewing tool # load chm chm_temp = ptcld_processing_data %&gt;% dplyr::filter(study_site==study_site_list[2]) %&gt;% dplyr::filter(dplyr::row_number()==1) %&gt;% dplyr::mutate( f = paste0( processed_data_dir , &quot;/&quot; , file_name , &quot;_chm_0.25m.tif&quot; ) ) %&gt;% dplyr::pull(f) %&gt;% terra::rast() %&gt;% terra::aggregate(2) %&gt;% stars::st_as_stars() # map it mapview::mapviewOptions(basemaps = c(&quot;Esri.WorldImagery&quot;, &quot;OpenStreetMap&quot;)) mapview::mapview( plot_bound_temp , color = &quot;blue&quot; , lwd = 2 , alpha.regions = 0 , layer.name = &quot;boundary&quot; , label = FALSE , legend = FALSE , popup = FALSE ) + # aggregate raster and map mapview::mapview( chm_temp , layer.name = &quot;canopy ht. (m)&quot; , col.regions = viridis::plasma(n=50) , alpha.regions = 0.7 , na.color = &quot;transparent&quot; ) + # validation mapview::mapview( field_uas_comparison_temp , zcol = &quot;field_uas_group&quot; , col.regions = viridis::cividis(n=3) , cex = 2 , alpha.regions = 0.8 , layer.name = &quot;validation&quot; , popup = leafpop::popupTable( field_uas_comparison_temp , zcol = c( &quot;field_uas_group&quot; , &quot;uas_tree_height_m&quot; , &quot;field_tree_height_m&quot; , &quot;uas_dbh_cm&quot; , &quot;field_dbh_cm&quot; ) , row.numbers = FALSE , feature.id = FALSE ) ) + # fld mapview::mapview( field_data_temp , zcol = &quot;field_tree_height_m&quot; , cex = 2 , alpha.regions = 0.8 , layer.name = &quot;field&quot; , hide = T )+ # uas mapview::mapview( uas_data_temp , zcol = &quot;tree_height_m&quot; , cex = 2 , alpha.regions = 0.8 , layer.name = &quot;uas&quot; , hide = T ) 5.7.8 Height vs. DBH of \\(Tp\\), \\(Co\\), \\(Om\\) field_uas_comparison_temp %&gt;% sf::st_drop_geometry() %&gt;% dplyr::mutate( dbh_temp = dplyr::coalesce(field_dbh_cm, uas_dbh_cm) , ht_temp = dplyr::coalesce(field_tree_height_m, uas_tree_height_m) ) %&gt;% ggplot( mapping = aes(x = ht_temp, y = dbh_temp, color = field_uas_group) ) + geom_point( mapping = aes(shape = field_uas_group) , alpha=0.8 , size=2 ) + scale_color_viridis_d(option = &quot;cividis&quot;, drop = F) + scale_x_continuous(breaks = scales::extended_breaks(n=8)) + scale_y_continuous(breaks = scales::extended_breaks(n=8)) + labs( color = &quot;detection&quot; , shape = &quot;detection&quot; , y = &quot;DBH (cm)&quot; , x = &quot;Tree Ht. (m)&quot; , title = &quot;UAS and Stem-Mapped Tree Validation Summary&quot; , subtitle = &quot;height and DBH relationship&quot; ) + theme_light() + theme( legend.position = &quot;top&quot; , legend.direction = &quot;horizontal&quot; , legend.title = element_blank() ) + guides( color = guide_legend(reverse = T, override.aes = list(alpha = 0.9, size = 5)) , shape = guide_legend(reverse = T) ) 5.7.9 Height and DBH Distribution \\(Tp\\), \\(Co\\), \\(Om\\) field_uas_comparison_temp %&gt;% sf::st_drop_geometry() %&gt;% dplyr::mutate( dbh = dplyr::coalesce(field_dbh_cm, uas_dbh_cm) , height = dplyr::coalesce(field_tree_height_m, uas_tree_height_m) ) %&gt;% dplyr::select(dbh, height, field_uas_group) %&gt;% tidyr::pivot_longer(cols = -c(field_uas_group), names_to = &quot;metric&quot;, values_to = &quot;value&quot;) %&gt;% dplyr::group_by(field_uas_group,metric) %&gt;% dplyr::mutate( metric = dplyr::case_when( metric == &quot;dbh&quot; ~ &quot;DBH (cm)&quot; , metric == &quot;height&quot; ~ &quot;Height (m)&quot; ) , n_rows = dplyr::n() , plot_lab = paste0( field_uas_group ,&quot; (n=&quot;, scales::comma(n_rows,accuracy=1),&quot;)&quot; ) ) %&gt;% ggplot(mapping = aes(x = value, y = plot_lab, fill = field_uas_group)) + geom_violin() + geom_boxplot(width = 0.1, outlier.shape = NA, color = &quot;gray66&quot;) + facet_grid(cols = vars(metric), scales = &quot;free_x&quot;) + scale_fill_viridis_d(option = &quot;cividis&quot;, drop = F) + scale_x_continuous(breaks = scales::extended_breaks(n=8)) + labs( fill = &quot;&quot; , y = &quot;&quot; , x = &quot;&quot; , title = &quot;UAS and Stem-Mapped Tree Validation Summary&quot; , subtitle = &quot;height and DBH distribution comparison&quot; ) + theme_light() + theme( legend.position = &quot;none&quot; , axis.title.x = element_text(size=10, face = &quot;bold&quot;) , axis.title.y = element_blank() , axis.text.y = element_text(color = &quot;black&quot;,size=10, face = &quot;bold&quot;, hjust = 0) , strip.text = element_text(color = &quot;black&quot;, size = 12) , strip.background = element_rect(fill = &quot;gray88&quot;) ) 5.7.10 Detected Overstory (\\(TP\\)) Height Difference Detected overstory tree (\\(TP\\)) height reliability. field_uas_comparison_temp %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(field_uas_group == &quot;true positive&quot;) %&gt;% dplyr::group_by(field_uas_group) %&gt;% dplyr::mutate( plot_lab = paste0( field_uas_group ,&quot; (n=&quot;, scales::comma(dplyr::n(),accuracy=1),&quot;)&quot; ) , med = median(height_diff_pct, na.rm=T) , color_box = med&lt;0 ) %&gt;% ggplot(mapping = aes(x = height_diff_pct)) + # height_diff_pct # ggplot(mapping = aes(x = height_diff_pct, y = plot_lab )) + # height_diff_pct geom_vline(xintercept = 0, color = &quot;gray22&quot;, lwd = 1) + # geom_boxplot(mapping = aes(fill = color_box), alpha = 0.8, width = 0.7, outlier.shape = NA) + geom_density(mapping = aes(fill = color_box), alpha = 0.8) + geom_vline(aes(xintercept = med), color = &quot;gray66&quot;, linetype = &quot;dashed&quot;) + # ymin = -Inf, ymax = Inf geom_text( aes(x = med, y = 0, label = paste0(&quot;median: &quot;,scales::percent(med, accuracy = 0.1))) , hjust = -0.1, vjust = 1 ) + scale_fill_manual(values = c(&quot;steelblue&quot;, &quot;coral&quot;)) + scale_x_continuous( labels = scales::percent_format() , breaks = scales::extended_breaks(n=8) , limits = c( -max(field_uas_comparison_temp$abs_height_diff_pct, na.rm = T) , max(field_uas_comparison_temp$abs_height_diff_pct, na.rm = T) ) ) + scale_y_continuous(NULL, breaks = NULL) + labs( fill = &quot;&quot; , y = &quot;&quot; , x = &quot;Percent Difference in Height&quot; , title = &quot;Detected Overstory Height Difference&quot; , caption = &quot;-values = UAS&lt;field | +values = UAS&gt;field&quot; ) + theme_light() + theme( legend.position = &quot;none&quot; , axis.title.x = element_text(size=10, face = &quot;bold&quot;) , axis.title.y = element_blank() , axis.text.y = element_text(color = &quot;black&quot;,size=10, face = &quot;bold&quot;, hjust = 0) ) 5.7.11 Detected Overstory (\\(TP\\)) DBH Difference Detected overstory tree (\\(TP\\)) DBH reliability. field_uas_comparison_temp %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(field_uas_group == &quot;true positive&quot;) %&gt;% dplyr::group_by(field_uas_group) %&gt;% dplyr::mutate( plot_lab = paste0( field_uas_group ,&quot; (n=&quot;, scales::comma(dplyr::n(),accuracy=1),&quot;)&quot; ) , med = median(dbh_diff_pct, na.rm=T) , color_box = med&lt;0 ) %&gt;% ggplot(mapping = aes(x = dbh_diff_pct)) + # height_diff_pct geom_vline(xintercept = 0, color = &quot;gray22&quot;, lwd = 1) + geom_density(mapping = aes(fill = color_box), alpha = 0.8) + geom_vline(aes(xintercept = med), color = &quot;gray66&quot;, linetype = &quot;dashed&quot;) + # ymin = -Inf, ymax = Inf geom_text( aes(x = med, y = 0, label = paste0(&quot;median: &quot;,scales::percent(med, accuracy = 0.1))) , hjust = -0.1, vjust = 1 ) + scale_fill_manual(values = c(&quot;steelblue&quot;, &quot;coral&quot;)) + scale_x_continuous( labels = scales::percent_format() , breaks = scales::extended_breaks(n=8) , limits = c(-2,2) ) + scale_y_continuous(NULL, breaks = NULL) + labs( fill = &quot;&quot; , y = &quot;&quot; , x = &quot;Percent Difference in DBH&quot; , title = &quot;Detected Overstory DBH Difference&quot; , caption = &quot;-values = UAS&lt;field | +values = UAS&gt;field&quot; ) + theme_light() + theme( legend.position = &quot;none&quot; , axis.title.x = element_text(size=10, face = &quot;bold&quot;) , axis.title.y = element_blank() , axis.text.y = element_text(color = &quot;black&quot;,size=10, face = &quot;bold&quot;, hjust = 0) ) 5.7.11.1 Detected Overstory (\\(TP\\)) Reliability dbh_f_temp = field_uas_comparison_temp %&gt;% dplyr::filter(field_uas_group==&quot;true positive&quot;) %&gt;% dplyr::pull(field_dbh_cm) dbh_u_temp = field_uas_comparison_temp %&gt;% dplyr::filter(field_uas_group==&quot;true positive&quot;) %&gt;% dplyr::pull(uas_dbh_cm) ht_f_temp = field_uas_comparison_temp %&gt;% dplyr::filter(field_uas_group==&quot;true positive&quot;) %&gt;% dplyr::pull(field_tree_height_m) ht_u_temp = field_uas_comparison_temp %&gt;% dplyr::filter(field_uas_group==&quot;true positive&quot;) %&gt;% dplyr::pull(uas_tree_height_m) data.frame( mae_dbh = Metrics::mae( dbh_f_temp , dbh_u_temp ) , mape_dbh = Metrics::mape( dbh_f_temp , dbh_u_temp ) , rmse_dbh = Metrics::rmse( dbh_f_temp , dbh_u_temp ) ## height , mae_height = Metrics::mae( ht_f_temp , ht_u_temp ) , mape_height = Metrics::mape( ht_f_temp , ht_u_temp ) , rmse_height = Metrics::rmse( ht_f_temp , ht_u_temp ) ) %&gt;% tidyr::pivot_longer(dplyr::everything()) %&gt;% tidyr::separate_wider_delim(cols = name, delim = &quot;_&quot;, names = c(&quot;error&quot;, &quot;metric&quot;)) %&gt;% tidyr::pivot_wider(names_from = error, values_from = value) %&gt;% dplyr::mutate( metric = dplyr::case_when( metric == &quot;dbh&quot; ~ &quot;DBH (cm)&quot; , metric == &quot;height&quot; ~ &quot;Height (m)&quot; ) , n = field_uas_comparison_temp %&gt;% dplyr::filter(field_uas_group==&quot;true positive&quot;) %&gt;% nrow() ) %&gt;% kableExtra::kbl( caption = &quot;Detected overstory tree height and DBH prediction performance&quot; , col.names = c( &quot; &quot; , &quot;Mean Abs. Error&quot; , &quot;Mean Abs. Percent Error&quot; , &quot;Root Mean Squared Error&quot; , &quot;N&quot; ) , digits = 2 ) %&gt;% kableExtra::kable_styling() Table 5.1: Detected overstory tree height and DBH prediction performance Mean Abs. Error Mean Abs. Percent Error Root Mean Squared Error N DBH (cm) 4.90 0.24 6.64 227 Height (m) 0.56 0.07 0.73 227 5.8 Mapped validation for all sites Above, we reviewed the process for matching field mapped trees to UAS detected trees to determine true positive (TP) detections, commission (Co), and omission (Om) trees. Here, we visualize the location of the classified trees for each study site. We’re only going to use point clouds generated via Metashape with the “high” point cloud generation quality setting and the “mild” filtering setting. 5.8.1 Plotting Function Let’s define a plotting function to map sites over plt_validation_fn = function(my_site = study_site_list[1]){ ############################################ # validation plot boundary ############################################ plot_bound_temp = validation_plots %&gt;% dplyr::filter(study_site==my_site) ############################################ # field data ############################################ field_data_temp = read_field_data(my_study_site = my_site) ############################################ # orthomosaic ############################################ ortho_list = list.files( &quot;../data/field_validation/orthomosaic/&quot; , pattern = &quot;.*\\\\.(tif|tiff)$&quot; , full.names = T ) # load raster ortho_rast = ortho_list %&gt;% purrr::pluck( ortho_list %&gt;% toupper() %&gt;% stringr::str_which(pattern = my_site) %&gt;% .[1] ) %&gt;% terra::rast() # aggregate to lower resolution if needed if(terra::res(ortho_rast)[1]&lt;0.5){ ortho_rast = terra::aggregate( ortho_rast , fact = round(0.5/terra::res(ortho_rast)[1]) , fun = &quot;median&quot; , cores = round(parallel::detectCores()/2) ) } # convert to stars ortho_st = ortho_rast %&gt;% terra::subset(subset = c(1,2,3)) %&gt;% terra::crop( # stand %&gt;% plot_bound_temp %&gt;% sf::st_buffer(2) %&gt;% sf::st_bbox() %&gt;% sf::st_as_sfc() %&gt;% terra::vect() %&gt;% terra::project(terra::crs(ortho_rast)) ) %&gt;% stars::st_as_stars() # convert to rgb ortho_rgb = stars::st_rgb( ortho_st[,,,1:3] , dimension = 3 , use_alpha = FALSE # , stretch = &quot;histogram&quot; , probs = c(0.005, 0.995) , stretch = &quot;percent&quot; ) ############################################ # load validation data ftw ############################################ field_uas_comparison_temp = ptcld_validation_data %&gt;% dplyr::filter( study_site == my_site &amp; tolower(software) == &quot;metashape&quot; &amp; tolower(depth_maps_generation_quality) == &quot;high&quot; &amp; tolower(depth_maps_generation_filtering_mode) == &quot;mild&quot; ) %&gt;% dplyr::pull(validation_file_full_path) %&gt;% readr::read_csv() %&gt;% dplyr::mutate( field_uas_group = factor( field_uas_group , ordered = T , levels = c( &quot;true positive&quot; , &quot;commission&quot; , &quot;omission&quot; ) ) %&gt;% forcats::fct_rev() , overstory_understory_grp = overstory_understory_grp %&gt;% factor() , x = ifelse(!is.na(field_tree_utm_x), field_tree_utm_x, uas_tree_utm_x) , y = ifelse(!is.na(field_tree_utm_x), field_tree_utm_y, uas_tree_utm_y) ) %&gt;% sf::st_as_sf( coords = c(&quot;x&quot;, &quot;y&quot;) , crs = sf::st_crs(field_data_temp) , remove=T ) ############################################ # plot it all ############################################ # make a label hey_lab = ptcld_validation_data %&gt;% dplyr::filter( study_site == my_site &amp; tolower(software) == &quot;metashape&quot; &amp; tolower(depth_maps_generation_quality) == &quot;high&quot; &amp; tolower(depth_maps_generation_filtering_mode) == &quot;mild&quot; ) %&gt;% dplyr::mutate( hey_lab = paste0( &quot;true positive: &quot;, scales::comma(true_positive_n_trees, accuracy = 1) , &quot;\\ncommission: &quot;, scales::comma(commission_n_trees, accuracy = 1) , &quot;\\nomission: &quot;, scales::comma(omission_n_trees, accuracy = 1) , &quot;\\n(F-score: &quot;, scales::comma(f_score, accuracy = 0.01), &quot;)&quot; ) ) %&gt;% dplyr::pull(hey_lab) # ggplot rgb plt_rgb = ggplot() + stars::geom_stars(data = ortho_rgb[]) + scale_fill_identity(na.value = &quot;transparent&quot;) + # !!! don&#39;t take this out or RGB plot will kill your computer # add plot boundary geom_sf( data = plot_bound_temp %&gt;% terra::vect() %&gt;% terra::project(terra::crs(ortho_rast)) %&gt;% sf::st_as_sf() , alpha = 0 , lwd = 1.2 , color = &quot;blue&quot; ) + scale_x_continuous(expand = c(0, 0)) + scale_y_continuous(expand = c(0, 0)) + labs( x = &quot;&quot; , y = &quot;&quot; ) + theme_void() # combine plt_comparison_temp = plt_rgb + ggnewscale::new_scale_fill() + geom_sf( data = field_uas_comparison_temp %&gt;% terra::vect() %&gt;% terra::project(terra::crs(ortho_rast)) %&gt;% sf::st_as_sf() , mapping = aes(fill = field_uas_group) , color = &quot;black&quot; , shape = 21 , size = 1.4 ) + scale_fill_viridis_d(option = &quot;cividis&quot;, name = &quot;trees&quot;, drop = F, alpha = 0.8) + labs( title = paste0(&quot;plot: &quot;, my_site) , subtitle = hey_lab ) + theme(legend.position = &quot;bottom&quot;, legend.direction = &quot;horizontal&quot;) # return return(plt_comparison_temp) } # plt_validation_fn(study_site_list[5]) apply the function hey_list_temp = study_site_list %&gt;% purrr::map(plt_validation_fn) 5.8.2 Validation Maps hey_list_temp ## [[1]] ## ## [[2]] ## ## [[3]] ## ## [[4]] ## ## [[5]] 5.8.3 Validation Maps Combined # combine patchwork::wrap_plots(hey_list_temp, ncol = 2, guides = &quot;collect&quot;) &amp; theme(legend.position=&quot;bottom&quot;, legend.direction = &quot;horizontal&quot;, plot.title = element_text(size = 8), plot.subtitle = element_text(size = 7)) 5.9 Field Data Descriptive Statistics Load and combine all field data sets field_data = study_site_list %&gt;% purrr::map(function(x){ read_field_data(x) %&gt;% sf::st_drop_geometry() }) %&gt;% dplyr::bind_rows() %&gt;% dplyr::left_join( validation_plots %&gt;% dplyr::mutate(ha = sf::st_area(.) %&gt;% as.numeric() %&gt;% `/`(10000)) %&gt;% sf::st_drop_geometry() %&gt;% dplyr::select(study_site, ha) , by = dplyr::join_by(&quot;study_site&quot;) ) 5.9.1 Table of Height Summary Statistics field_data %&gt;% dplyr::group_by(study_site,ha) %&gt;% dplyr::summarise( n_trees = dplyr::n() , min_tree_height_m = min(field_tree_height_m, na.rm = T) , max_tree_height_m = max(field_tree_height_m, na.rm = T) , median_tree_height_m = median(field_tree_height_m, na.rm = T) , tree_height_m_25 = quantile(field_tree_height_m, probs = 0.25) , tree_height_m_75 = quantile(field_tree_height_m, probs = 0.75) ) %&gt;% dplyr::mutate( tph = (n_trees/ha) %&gt;% scales::comma(accuracy = 1) , n_trees = n_trees %&gt;% scales::comma(accuracy = 1) ) %&gt;% dplyr::relocate(tph, .after = n_trees) %&gt;% dplyr::select(-c(ha)) %&gt;% kableExtra::kbl( caption = &quot;Field Data: Table of Height Summary Statistics&quot; , col.names = c( &quot;Site&quot; , &quot;# trees&quot; , &quot;TPH&quot; , &quot;Minimum&quot; , &quot;Maximum&quot; , &quot;Median&quot; , &quot;25th percentile&quot; , &quot;75th percentile&quot; ) , digits = 1 ) %&gt;% kableExtra::add_header_above( c( &quot; &quot; = 3 , &quot;Tree Height (meters)&quot;=5 ) ) %&gt;% kableExtra::kable_styling() Table 5.2: Field Data: Table of Height Summary Statistics Tree Height (meters) Site # trees TPH Minimum Maximum Median 25th percentile 75th percentile KAIBAB_HIGH 1,001 574 2.1 32.3 11.8 6.8 17.9 KAIBAB_LOW 510 247 2.1 34.7 9.3 4.9 19.9 N1 1,012 639 2.0 26.6 4.9 2.9 14.1 SQ09_02 309 308 2.1 20.7 12.6 7.1 14.7 WA85_02 172 172 2.2 22.9 18.4 10.2 19.9 5.9.2 Table of DBH Summary Statistics field_data %&gt;% dplyr::group_by(study_site,ha) %&gt;% dplyr::summarise( n_trees = dplyr::n() , min_dbh_cm = min(field_dbh_cm, na.rm = T) , max_dbh_cm = max(field_dbh_cm, na.rm = T) , median_dbh_cm = median(field_dbh_cm, na.rm = T) , dbh_cm_25 = quantile(field_dbh_cm, probs = 0.25) , dbh_cm_75 = quantile(field_dbh_cm, probs = 0.75) ) %&gt;% dplyr::mutate( tph = (n_trees/ha) %&gt;% scales::comma(accuracy = 1) , n_trees = n_trees %&gt;% scales::comma(accuracy = 1) ) %&gt;% dplyr::relocate(tph, .after = n_trees) %&gt;% dplyr::select(-c(ha)) %&gt;% kableExtra::kbl( caption = &quot;Field Data: Table of DBH Summary Statistics&quot; , col.names = c( &quot;Site&quot; , &quot;# trees&quot; , &quot;TPH&quot; , &quot;Minimum&quot; , &quot;Maximum&quot; , &quot;Median&quot; , &quot;25th percentile&quot; , &quot;75th percentile&quot; ) , digits = 1 ) %&gt;% kableExtra::add_header_above( c( &quot; &quot; = 3 , &quot;Tree DBH (cm)&quot;=5 ) ) %&gt;% kableExtra::kable_styling() Table 5.3: Field Data: Table of DBH Summary Statistics Tree DBH (cm) Site # trees TPH Minimum Maximum Median 25th percentile 75th percentile KAIBAB_HIGH 1,001 574 1.8 106.7 18.8 11.2 32.5 KAIBAB_LOW 510 247 1.5 86.4 20.3 10.0 41.7 N1 1,012 639 1.0 63.2 7.1 3.3 25.7 SQ09_02 309 308 1.0 41.4 21.6 15.0 25.4 WA85_02 172 172 2.3 53.1 36.1 24.8 39.6 5.9.3 Height and DBH Distribution field_data %&gt;% dplyr::select(study_site, field_dbh_cm, field_tree_height_m) %&gt;% # tidyr::pivot_longer( cols = -c(study_site) ) %&gt;% dplyr::mutate( name = dplyr::case_when( name == &quot;field_dbh_cm&quot; ~ &quot;DBH (cm)&quot; , name == &quot;field_tree_height_m&quot; ~ &quot;Height (m)&quot; , T ~ &quot;error&quot; ) ) %&gt;% # plot ggplot(mapping = aes(x = value, y = study_site)) + geom_violin(mapping = aes(fill = name), color = NA) + geom_boxplot(width = 0.1, outlier.shape = NA, fill = NA, color = &quot;black&quot;) + facet_grid(cols = vars(name), scales = &quot;free_x&quot;) + scale_fill_manual(values = c(&quot;skyblue4&quot;, &quot;skyblue2&quot;)) + scale_x_continuous(breaks = scales::breaks_extended(8)) + labs(x = &quot;&quot;, y = &quot;&quot;) + theme_light() + theme(legend.position = &quot;none&quot;, strip.text = element_text(color = &quot;black&quot;, face = &quot;bold&quot;)) 5.10 Summary of Dependent Variables descriptive statistics of potential dependent variables ptcld_validation_data %&gt;% dplyr::select( f_score, basal_area_pct_error, basal_area_abs_pct_error , tree_height_m_me, tree_height_m_rmse, dbh_cm_me, dbh_cm_rmse ) %&gt;% dplyr::ungroup() %&gt;% dplyr::summarise( dplyr::across( .cols = tidyselect::everything() , .fns = list( mean = ~ mean(.x, na.rm=T) , median = ~ median(.x, na.rm=T) , sd = ~ sd(.x, na.rm=T) , min = ~ min(.x, na.rm=T) , max = ~ max(.x, na.rm=T) ) , .names = &quot;{.fn}_xxx_{.col}&quot; ) , n = dplyr::n() ) %&gt;% tidyr::pivot_longer(cols = -n) %&gt;% tidyr::separate(col = name, sep = &quot;_xxx_&quot;, into = c(&quot;stat&quot;, &quot;metric&quot;)) %&gt;% # format dplyr::mutate( value = dplyr::case_when( stringr::str_detect(metric, &quot;_pct_&quot;) ~ scales::percent(value, accuracy = 0.1) , metric == &quot;f_score&quot; ~ scales::number(value, accuracy = 0.01) , T ~ scales::number(value, accuracy = 0.1) ) ) %&gt;% tidyr::pivot_wider(names_from = stat, values_from = value) %&gt;% dplyr::relocate(c(metric, n)) %&gt;% # dplyr::mutate( # range = paste0( # min, &quot; to &quot;, max # ) # ) %&gt;% # select(-c(min, max)) kableExtra::kbl( digits = 2 , caption = &quot;SfM data set summary statistics of potential dependent variable metrics&quot; ) %&gt;% kableExtra::kable_styling() Table 5.4: SfM data set summary statistics of potential dependent variable metrics metric n mean median sd min max f_score 260 0.46 0.44 0.23 0.00 0.90 basal_area_pct_error 260 -13.1% -10.4% 33.8% -100.0% 51.9% basal_area_abs_pct_error 260 26.3% 19.0% 24.8% 0.3% 100.0% tree_height_m_me 260 0.1 0.2 0.4 -1.9 0.8 tree_height_m_rmse 260 0.8 0.8 0.2 0.4 1.9 dbh_cm_me 260 0.7 0.1 3.5 -9.7 8.5 dbh_cm_rmse 260 6.3 5.9 2.6 3.3 12.4 "],["stats_validation.html", "Section 6 Statistical Analysis: Tree Detection (F-Score) 6.1 Setup 6.2 Summary Statistics 6.3 One Nominal Predictor 6.4 The beta: Three Nominal Predictors + site effects 6.5 Bayesian p-value", " Section 6 Statistical Analysis: Tree Detection (F-Score) In this section, we’ll evaluate the influence of the processing parameters on UAS-derived tree detection and monitoring. The UAS and Field validation data was built and described in this section. The objective of this study is to determine the influence of different structure from motion (SfM) software (e.g. Agisoft Metashap, OpenDroneMap, Pix4D) and processing parameters on F-score which is a measure of overall tree detection performance. All of the predictor variables of interest in this study are categorical (a.k.a. factor or nominal) while the predicted variables are metric and include F-score (ranges from 0-1) and error (e.g. MAPE, RMSE). This type of statistical analysis is described in the second edition of Kruschke’s Doing Bayesian data analysis (2015) and here we will build a Bayesian approach based on Kruschke (2015). This analysis was greatly enhanced by A. Solomon Kurz’s ebook supplement to Kruschke (2015). This type of statistical analysis is described in the second edition of Kruschke’s Doing Bayesian data analysis (2015): This chapter considers data structures that consist of a metric predicted variable and two (or more) nominal predictors….Data structures of the type considered in this chapter are often encountered in real research. For example, we might want to predict monetary income from political party affiliation and religious affiliation, or we might want to predict galvanic skin response to different combinations of categories of visual stimulus and categories of auditory stimulus. As mentioned in the previous chapter, this type of data structure can arise from experiments or from observational studies. In experiments, the researcher assigns the categories (at random) to the experimental subjects. In observational studies, both the nominal predictor values and the metric predicted value are generated by processes outside the direct control of the researcher. The traditional treatment of this sort of data structure is called multifactor analysis of variance (ANOVA). Our Bayesian approach will be a hierarchical generalization of the traditional ANOVA model. The chapter also considers generalizations of the traditional models, because it is straight forward in Bayesian software to implement heavy-tailed distributions to accommodate outliers, along with hierarchical structure to accommodate heterogeneous variances in the different groups. Kruschke (2015, pp.583–584) 6.1 Setup first we’re going to define a function to ingest a formula as text and separate it into multiple rows based on the number of characters for plotting # function to pull the formula for labeling below get_frmla_text = function(frmla_chr, split_chrs = 100){ cumsum_group = function(x, threshold) { cumsum = 0 group = 1 result = numeric() for (i in 1:length(x)) { cumsum = cumsum + x[i] if (cumsum &gt; threshold) { group = group + 1 cumsum = x[i] } result = c(result, group) } return (result) } r = stringr::str_sub( frmla_chr , # get the two column matrix of start end frmla_chr %&gt;% stringr::str_locate_all(&quot;\\\\+&quot;) %&gt;% .[[1]] %&gt;% dplyr::as_tibble() %&gt;% dplyr::select(start) %&gt;% dplyr::mutate( len = dplyr::coalesce(start-dplyr::lag(start),0) , ld = dplyr::coalesce(dplyr::lead(start)-1, stringr::str_length(frmla_chr)) , cum = cumsum_group(len, split_chrs) , start = ifelse(dplyr::row_number()==1,1,start) ) %&gt;% dplyr::group_by(cum) %&gt;% dplyr::summarise(start = min(start), end = max(ld)) %&gt;% dplyr::ungroup() %&gt;% dplyr::select(-cum) %&gt;% as.matrix() ) %&gt;% stringr::str_squish() %&gt;% paste0(collapse = &quot;\\n&quot;) return(r) } 6.2 Summary Statistics What is this data? # load data if needed if(ls()[ls() %in% &quot;ptcld_validation_data&quot;] %&gt;% length()==0){ ptcld_validation_data = readr::read_csv(&quot;../data/ptcld_full_analysis_data.csv&quot;) %&gt;% dplyr::mutate( depth_maps_generation_quality = factor( depth_maps_generation_quality %&gt;% tolower() %&gt;% stringr::str_replace_all(&quot;ultrahigh&quot;, &quot;ultra high&quot;) , ordered = TRUE , levels = c( &quot;lowest&quot; , &quot;low&quot; , &quot;medium&quot; , &quot;high&quot; , &quot;ultra high&quot; ) ) %&gt;% forcats::fct_rev() , depth_maps_generation_filtering_mode = factor( depth_maps_generation_filtering_mode %&gt;% tolower() , ordered = TRUE , levels = c( &quot;disabled&quot; , &quot;mild&quot; , &quot;moderate&quot; , &quot;aggressive&quot; ) ) %&gt;% forcats::fct_rev() ) } # replace 0 F-score with very small positive to run models ptcld_validation_data = ptcld_validation_data %&gt;% dplyr::mutate(dplyr::across( .cols = tidyselect::ends_with(&quot;f_score&quot;) , .fns = ~ ifelse(.x==0,1e-4,.x) )) reminder of the data structure # what is this data? ptcld_validation_data %&gt;% dplyr::glimpse() ## Rows: 260 ## Columns: 114 ## $ tracking_file_full_path &lt;chr&gt; &quot;E:\\\\SfM_Software_Comparison\\\\Me… ## $ software &lt;chr&gt; &quot;METASHAPE&quot;, &quot;METASHAPE&quot;, &quot;METAS… ## $ study_site &lt;chr&gt; &quot;KAIBAB_HIGH&quot;, &quot;KAIBAB_HIGH&quot;, &quot;K… ## $ processing_attribute1 &lt;chr&gt; &quot;HIGH&quot;, &quot;HIGH&quot;, &quot;HIGH&quot;, &quot;HIGH&quot;, … ## $ processing_attribute2 &lt;chr&gt; &quot;AGGRESSIVE&quot;, &quot;DISABLED&quot;, &quot;MILD&quot;… ## $ processing_attribute3 &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, … ## $ file_name &lt;chr&gt; &quot;HIGH_AGGRESSIVE&quot;, &quot;HIGH_DISABLE… ## $ number_of_points &lt;int&gt; 52974294, 72549206, 69858217, 69… ## $ las_area_m2 &lt;dbl&gt; 86661.27, 87175.42, 86404.78, 86… ## $ timer_tile_time_mins &lt;dbl&gt; 0.63600698, 2.49318542, 0.841338… ## $ timer_class_dtm_norm_chm_time_mins &lt;dbl&gt; 3.6559556, 5.3289152, 5.1638296,… ## $ timer_treels_time_mins &lt;dbl&gt; 8.9065272, 19.2119663, 12.339179… ## $ timer_itd_time_mins &lt;dbl&gt; 0.02202115, 0.02449968, 0.037984… ## $ timer_competition_time_mins &lt;dbl&gt; 0.10590740, 0.17865245, 0.121248… ## $ timer_estdbh_time_mins &lt;dbl&gt; 0.02290262, 0.02382533, 0.021991… ## $ timer_silv_time_mins &lt;dbl&gt; 0.012565533, 0.015940932, 0.0150… ## $ timer_total_time_mins &lt;dbl&gt; 13.361886, 27.276985, 18.540606,… ## $ sttng_input_las_dir &lt;chr&gt; &quot;D:/Metashape_Testing_2024&quot;, &quot;D:… ## $ sttng_use_parallel_processing &lt;lgl&gt; FALSE, FALSE, FALSE, FALSE, FALS… ## $ sttng_desired_chm_res &lt;dbl&gt; 0.25, 0.25, 0.25, 0.25, 0.25, 0.… ## $ sttng_max_height_threshold_m &lt;int&gt; 60, 60, 60, 60, 60, 60, 60, 60, … ## $ sttng_minimum_tree_height_m &lt;int&gt; 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,… ## $ sttng_dbh_max_size_m &lt;int&gt; 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,… ## $ sttng_local_dbh_model &lt;chr&gt; &quot;rf&quot;, &quot;rf&quot;, &quot;rf&quot;, &quot;rf&quot;, &quot;rf&quot;, &quot;r… ## $ sttng_user_supplied_epsg &lt;lgl&gt; NA, NA, NA, NA, NA, NA, NA, NA, … ## $ sttng_accuracy_level &lt;int&gt; 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,… ## $ sttng_pts_m2_for_triangulation &lt;int&gt; 20, 20, 20, 20, 20, 20, 20, 20, … ## $ sttng_normalization_with &lt;chr&gt; &quot;triangulation&quot;, &quot;triangulation&quot;… ## $ sttng_competition_buffer_m &lt;int&gt; 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,… ## $ depth_maps_generation_quality &lt;ord&gt; high, high, high, high, low, low… ## $ depth_maps_generation_filtering_mode &lt;ord&gt; aggressive, disabled, mild, mode… ## $ total_sfm_time_min &lt;dbl&gt; 54.800000, 60.316667, 55.933333,… ## $ number_of_points_sfm &lt;dbl&gt; 52974294, 72549206, 69858217, 69… ## $ total_sfm_time_norm &lt;dbl&gt; 0.1117823680, 0.1237564664, 0.11… ## $ processed_data_dir &lt;chr&gt; &quot;E:/SfM_Software_Comparison/Meta… ## $ processing_id &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1… ## $ true_positive_n_trees &lt;dbl&gt; 229, 261, 260, 234, 220, 175, 23… ## $ commission_n_trees &lt;dbl&gt; 173, 222, 213, 193, 148, 223, 16… ## $ omission_n_trees &lt;dbl&gt; 772, 740, 741, 767, 781, 826, 77… ## $ f_score &lt;dbl&gt; 0.3264433, 0.3517520, 0.3527815,… ## $ tree_height_m_me &lt;dbl&gt; 0.270336679, 0.283568790, 0.3122… ## $ tree_height_m_mpe &lt;dbl&gt; 0.002357383, 0.013286785, 0.0142… ## $ tree_height_m_mae &lt;dbl&gt; 0.7873610, 0.6886235, 0.6914983,… ## $ tree_height_m_mape &lt;dbl&gt; 0.06624939, 0.06903969, 0.060550… ## $ tree_height_m_smape &lt;dbl&gt; 0.06776453, 0.06838733, 0.060410… ## $ tree_height_m_mse &lt;dbl&gt; 0.9842433, 0.8507862, 0.8259923,… ## $ tree_height_m_rmse &lt;dbl&gt; 0.9920904, 0.9223807, 0.9088412,… ## $ dbh_cm_me &lt;dbl&gt; 2.0551269, 1.2718827, 1.7505679,… ## $ dbh_cm_mpe &lt;dbl&gt; 0.077076168, 0.056392083, 0.0755… ## $ dbh_cm_mae &lt;dbl&gt; 5.091373, 4.375871, 4.674437, 4.… ## $ dbh_cm_mape &lt;dbl&gt; 0.2076874, 0.2185989, 0.2110014,… ## $ dbh_cm_smape &lt;dbl&gt; 0.1966263, 0.2081000, 0.1986588,… ## $ dbh_cm_mse &lt;dbl&gt; 44.38957, 35.29251, 38.33622, 38… ## $ dbh_cm_rmse &lt;dbl&gt; 6.662549, 5.940750, 6.191625, 6.… ## $ uas_basal_area_m2 &lt;dbl&gt; 55.75278, 60.26123, 58.67391, 57… ## $ field_basal_area_m2 &lt;dbl&gt; 69.04409, 69.04409, 69.04409, 69… ## $ uas_basal_area_m2_per_ha &lt;dbl&gt; 31.97437, 34.55997, 33.64964, 33… ## $ field_basal_area_m2_per_ha &lt;dbl&gt; 39.59697, 39.59697, 39.59697, 39… ## $ basal_area_m2_error &lt;dbl&gt; -13.291309, -8.782866, -10.37018… ## $ basal_area_m2_per_ha_error &lt;dbl&gt; -7.622601, -5.036997, -5.947326,… ## $ basal_area_pct_error &lt;dbl&gt; -0.19250466, -0.12720663, -0.150… ## $ basal_area_abs_pct_error &lt;dbl&gt; 0.19250466, 0.12720663, 0.150196… ## $ overstory_commission_n_trees &lt;dbl&gt; 141, 178, 178, 160, 95, 173, 120… ## $ understory_commission_n_trees &lt;dbl&gt; 32, 44, 35, 33, 53, 50, 43, 39, … ## $ overstory_omission_n_trees &lt;dbl&gt; 558, 560, 545, 556, 554, 598, 54… ## $ understory_omission_n_trees &lt;dbl&gt; 214, 180, 196, 211, 227, 228, 22… ## $ overstory_true_positive_n_trees &lt;dbl&gt; 185, 183, 198, 187, 189, 145, 19… ## $ understory_true_positive_n_trees &lt;dbl&gt; 44, 78, 62, 47, 31, 30, 33, 40, … ## $ overstory_f_score &lt;dbl&gt; 0.3461179, 0.3315217, 0.3538874,… ## $ understory_f_score &lt;dbl&gt; 0.2634731, 0.4105263, 0.3492958,… ## $ overstory_tree_height_m_me &lt;dbl&gt; 0.41693172, 0.44114110, 0.442167… ## $ understory_tree_height_m_me &lt;dbl&gt; -0.34602886, -0.08612009, -0.102… ## $ overstory_tree_height_m_mpe &lt;dbl&gt; 0.020790675, 0.024558478, 0.0241… ## $ understory_tree_height_m_mpe &lt;dbl&gt; -0.075146232, -0.013158341, -0.0… ## $ overstory_tree_height_m_mae &lt;dbl&gt; 0.8201433, 0.7820879, 0.7770369,… ## $ understory_tree_height_m_mae &lt;dbl&gt; 0.6495266, 0.4693415, 0.4183269,… ## $ overstory_tree_height_m_mape &lt;dbl&gt; 0.04662933, 0.04863237, 0.048708… ## $ understory_tree_height_m_mape &lt;dbl&gt; 0.14874284, 0.11691842, 0.098369… ## $ overstory_tree_height_m_smape &lt;dbl&gt; 0.04589942, 0.04776615, 0.047912… ## $ understory_tree_height_m_smape &lt;dbl&gt; 0.15969736, 0.11676780, 0.100322… ## $ overstory_tree_height_m_mse &lt;dbl&gt; 1.0623763, 1.0055835, 0.9739823,… ## $ understory_tree_height_m_mse &lt;dbl&gt; 0.6557300, 0.4876080, 0.3533791,… ## $ overstory_tree_height_m_rmse &lt;dbl&gt; 1.0307164, 1.0027878, 0.9869054,… ## $ understory_tree_height_m_rmse &lt;dbl&gt; 0.8097715, 0.6982893, 0.5944570,… ## $ overstory_dbh_cm_me &lt;dbl&gt; 2.88225065, 2.37098111, 2.694675… ## $ understory_dbh_cm_me &lt;dbl&gt; -1.4225525, -1.3067712, -1.26448… ## $ overstory_dbh_cm_mpe &lt;dbl&gt; 0.11199444, 0.09928650, 0.110477… ## $ understory_dbh_cm_mpe &lt;dbl&gt; -0.06973931, -0.04424482, -0.035… ## $ overstory_dbh_cm_mae &lt;dbl&gt; 5.753010, 5.298094, 5.472454, 5.… ## $ understory_dbh_cm_mae &lt;dbl&gt; 2.309487, 2.212192, 2.125931, 2.… ## $ overstory_dbh_cm_mape &lt;dbl&gt; 0.1862021, 0.1848729, 0.1898205,… ## $ understory_dbh_cm_mape &lt;dbl&gt; 0.2980235, 0.2977254, 0.2786439,… ## $ overstory_dbh_cm_smape &lt;dbl&gt; 0.1686851, 0.1699578, 0.1735200,… ## $ understory_dbh_cm_smape &lt;dbl&gt; 0.3141064, 0.2975874, 0.2789409,… ## $ overstory_dbh_cm_mse &lt;dbl&gt; 52.78250, 46.57941, 47.70797, 46… ## $ understory_dbh_cm_mse &lt;dbl&gt; 9.101103, 8.811704, 8.407077, 9.… ## $ overstory_dbh_cm_rmse &lt;dbl&gt; 7.265156, 6.824911, 6.907095, 6.… ## $ understory_dbh_cm_rmse &lt;dbl&gt; 3.016803, 2.968451, 2.899496, 3.… ## $ overstory_uas_basal_area_m2 &lt;dbl&gt; 55.49096, 59.79139, 58.30184, 57… ## $ understory_uas_basal_area_m2 &lt;dbl&gt; 0.2618258, 0.4698415, 0.3720740,… ## $ overstory_field_basal_area_m2 &lt;dbl&gt; 67.50326, 67.50326, 67.50326, 67… ## $ understory_field_basal_area_m2 &lt;dbl&gt; 1.540832, 1.540832, 1.540832, 1.… ## $ overstory_uas_basal_area_m2_per_ha &lt;dbl&gt; 31.82421, 34.29052, 33.43626, 32… ## $ understory_uas_basal_area_m2_per_ha &lt;dbl&gt; 0.15015781, 0.26945534, 0.213385… ## $ overstory_field_basal_area_m2_per_ha &lt;dbl&gt; 38.7133, 38.7133, 38.7133, 38.71… ## $ understory_field_basal_area_m2_per_ha &lt;dbl&gt; 0.883671, 0.883671, 0.883671, 0.… ## $ overstory_basal_area_m2_per_ha_error &lt;dbl&gt; -6.889088, -4.422782, -5.277041,… ## $ understory_basal_area_m2_per_ha_error &lt;dbl&gt; -0.7335132, -0.6142157, -0.67028… ## $ overstory_basal_area_pct_error &lt;dbl&gt; -0.17795146, -0.11424450, -0.136… ## $ understory_basal_area_pct_error &lt;dbl&gt; -0.8300750, -0.6950728, -0.75852… ## $ overstory_basal_area_abs_pct_error &lt;dbl&gt; 0.17795146, 0.11424450, 0.136310… ## $ understory_basal_area_abs_pct_error &lt;dbl&gt; 0.8300750, 0.6950728, 0.7585239,… ## $ validation_file_full_path &lt;chr&gt; &quot;E:/SfM_Software_Comparison/Meta… ## $ overstory_ht_m &lt;dbl&gt; 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,… # a row is unique by... identical( nrow(ptcld_validation_data) , ptcld_validation_data %&gt;% dplyr::distinct( study_site, software , depth_maps_generation_quality , depth_maps_generation_filtering_mode , processing_attribute3 # need to align all by software so this will go away or be filled ) %&gt;% nrow() ) ## [1] TRUE Summary by metrics of interest sum_stats_dta = function(my_var){ sum_fns = list( n = ~sum(ifelse(is.na(.x), 0, 1)) , min = ~min(.x, na.rm = TRUE) , max = ~max(.x, na.rm = TRUE) , mean = ~mean(.x, na.rm = TRUE) , median = ~median(.x, na.rm = TRUE) , sd = ~sd(.x, na.rm = TRUE) ) # plot ( ggplot( data = ptcld_validation_data %&gt;% dplyr::group_by(.data[[my_var]]) %&gt;% dplyr::mutate(m = median(f_score)) , mapping = aes( y = .data[[my_var]] , x = f_score, fill = m) ) + geom_violin(color = NA) + geom_boxplot(width = 0.1, outlier.shape = NA, fill = NA, color = &quot;black&quot;) + geom_rug() + scale_fill_viridis_c(option = &quot;mako&quot;, begin = 0.3, end = 0.9, direction = -1) + labs( x = &quot;F-score&quot; , y = stringr::str_replace_all(my_var, pattern = &quot;_&quot;, replacement = &quot; &quot;) , subtitle = stringr::str_replace_all(my_var, pattern = &quot;_&quot;, replacement = &quot; &quot;) %&gt;% stringr::str_to_title() ) + theme_light() + theme(legend.position = &quot;none&quot;) ) # # summarize data # ( # ptcld_validation_data %&gt;% # dplyr::group_by(dplyr::across(dplyr::all_of(my_var))) %&gt;% # dplyr::summarise( # dplyr::across(f_score, sum_fns) # , .groups = &#39;drop_last&#39; # ) %&gt;% # kableExtra::kbl() %&gt;% # kableExtra::kable_styling() # ) } # sum_stats_dta(&quot;software&quot;) summarize for all variables of interest c(&quot;software&quot;, &quot;study_site&quot; , &quot;depth_maps_generation_quality&quot; , &quot;depth_maps_generation_filtering_mode&quot; ) %&gt;% purrr::map(sum_stats_dta) ## [[1]] ## ## [[2]] ## ## [[3]] ## ## [[4]] 6.3 One Nominal Predictor As an introduction, we’ll start by exploring the influence of the depth map generation quality parameter on the SfM-derived tree detection performance based on the F-score. 6.3.1 Summary Statistics Summary statistics by group: ptcld_validation_data %&gt;% dplyr::group_by(depth_maps_generation_quality) %&gt;% dplyr::summarise( mean_f_score = mean(f_score, na.rm = T) # , med_f_score = median(f_score, na.rm = T) , sd_f_score = sd(f_score, na.rm = T) , n = dplyr::n() ) %&gt;% kableExtra::kbl(digits = 2, caption = &quot;summary statistics: F-score by dense cloud quality&quot;) %&gt;% kableExtra::kable_styling() Table 6.1: summary statistics: F-score by dense cloud quality depth_maps_generation_quality mean_f_score sd_f_score n ultra high 0.58 0.21 55 high 0.54 0.21 55 medium 0.47 0.22 55 low 0.40 0.20 55 lowest 0.27 0.19 40 6.3.2 Bayesian Kruschke (2015) notes: The terminology, “analysis of variance,” comes from a decomposition of overall data variance into within-group variance and between-group variance (Fisher, 1925). Algebraically, the sum of squared deviations of the scores from their overall mean equals the sum of squared deviations of the scores from their respective group means plus the sum of squared deviations of the group means from the overall mean. In other words, the total variance can be partitioned into within-group variance plus between-group variance. Because one definition of the word “analysis” is separation into constituent parts, the term ANOVA accurately describes the underlying algebra in the traditional methods. That algebraic relation is not used in the hierarchical Bayesian approach presented here. The Bayesian method can estimate component variances, however. Therefore, the Bayesian approach is not ANOVA, but is analogous to ANOVA. (p. 556) and see section 19 from Kurz’s ebook supplement The metric predicted variable with one nominal predictor variable model has the form: \\[\\begin{align*} y_{i} &amp;\\sim \\operatorname{Normal} \\bigl(\\mu_{i}, \\sigma_{y} \\bigr) \\\\ \\mu_{i} &amp;= \\beta_0 + \\sum_{j=1}^{J} \\beta_{1[j]} x_{1[j]} \\bigl(i\\bigr) \\\\ \\beta_{0} &amp;\\sim \\operatorname{Normal}(0,10) \\\\ \\beta_{1[j]} &amp;\\sim \\operatorname{Normal}(0,\\sigma_{\\beta_{1}}) \\\\ \\sigma_{\\beta_{1}} &amp;\\sim {\\sf uniform} (0,100) \\\\ \\sigma_{y} &amp;\\sim {\\sf uniform} (0,100) \\\\ \\end{align*}\\] , where \\(j\\) is the depth map generation quality setting corresponding to observation \\(i\\) to start, we’ll use the default brms::brm prior settings which may not match those described in the model specification above brms_f_mod1 = brms::brm( formula = f_score ~ 1 + (1 | depth_maps_generation_quality) , data = ptcld_validation_data , family = brms::brmsfamily(family = &quot;gaussian&quot;) , iter = 4000, warmup = 2000, chains = 4 , cores = round(parallel::detectCores()/2) , file = paste0(rootdir, &quot;/fits/brms_f_mod1&quot;) ) check the trace plots for problems with convergence of the Markov chains plot(brms_f_mod1) check the prior distributions # check priors brms::prior_summary(brms_f_mod1) %&gt;% kableExtra::kbl() %&gt;% kableExtra::kable_styling() prior class coef group resp dpar nlpar lb ub source student_t(3, 0.4, 2.5) Intercept default student_t(3, 0, 2.5) sd 0 default sd depth_maps_generation_quality default sd Intercept depth_maps_generation_quality default student_t(3, 0, 2.5) sigma 0 default The brms::brm model summary brms_f_mod1 %&gt;% brms::posterior_summary() %&gt;% as.data.frame() %&gt;% tibble::rownames_to_column(var = &quot;parameter&quot;) %&gt;% dplyr::rename_with(tolower) %&gt;% dplyr::filter( stringr::str_starts(parameter, &quot;b_&quot;) | stringr::str_starts(parameter, &quot;r_&quot;) | parameter == &quot;sigma&quot; ) %&gt;% dplyr::mutate( parameter = parameter %&gt;% stringr::str_remove_all(&quot;b_depth_maps_generation_quality&quot;) %&gt;% stringr::str_remove_all(&quot;r_depth_maps_generation_quality&quot;) ) %&gt;% kableExtra::kbl(digits = 2, caption = &quot;Bayesian one nominal predictor: F-score by dense cloud quality&quot;) %&gt;% kableExtra::kable_styling() Table 6.2: Bayesian one nominal predictor: F-score by dense cloud quality parameter estimate est.error q2.5 q97.5 b_Intercept 0.46 0.08 0.29 0.65 sigma 0.21 0.01 0.19 0.23 [ultra.high,Intercept] 0.11 0.09 -0.08 0.29 [high,Intercept] 0.08 0.09 -0.12 0.25 [medium,Intercept] 0.01 0.09 -0.19 0.18 [low,Intercept] -0.05 0.09 -0.25 0.12 [lowest,Intercept] -0.17 0.09 -0.37 0.00 With the stats::coef function, we can get the group-level summaries in a “non-deflection” metric. In the model, the group means represented by \\(\\beta_{1[j]}\\) are deflections from overall baseline, such that the deflections sum to zero (see Kruschke (2015, p.554)). Summaries of the group-specific deflections are available via the brms::ranef function. stats::coef(brms_f_mod1) %&gt;% as.data.frame() %&gt;% tibble::rownames_to_column(var = &quot;group&quot;) %&gt;% dplyr::rename_with( .cols = -c(&quot;group&quot;) , .fn = ~ stringr::str_remove_all(.x, &quot;depth_maps_generation_quality.&quot;) ) %&gt;% kableExtra::kbl(digits = 2, caption = &quot;brms::brm model: F-score by dense cloud quality&quot;) %&gt;% kableExtra::kable_styling() Table 6.3: brms::brm model: F-score by dense cloud quality group Estimate.Intercept Est.Error.Intercept Q2.5.Intercept Q97.5.Intercept ultra high 0.57 0.03 0.51 0.62 high 0.53 0.03 0.48 0.59 medium 0.47 0.03 0.41 0.52 low 0.40 0.03 0.35 0.46 lowest 0.28 0.03 0.22 0.35 We can look at the model noise standard deviation \\(\\sigma_y\\) # get formula form_temp = brms_f_mod1$formula$formula[3] %&gt;% as.character() %&gt;% get_frmla_text() %&gt;% stringr::str_replace_all(&quot;depth_maps_generation_quality&quot;, &quot;quality&quot;) %&gt;% stringr::str_replace_all(&quot;depth_maps_generation_filtering_mode&quot;, &quot;filtering&quot;) # extract the posterior draws brms::as_draws_df(brms_f_mod1) %&gt;% # plot ggplot(aes(x = sigma, y = 0)) + tidybayes::stat_dotsinterval( point_interval = median_hdi, .width = .95 , justification = -0.04 , shape = 21, point_size = 3 , quantiles = 100 ) + scale_y_continuous(NULL, breaks = NULL) + labs( x = latex2exp::TeX(&quot;$\\\\sigma_y$&quot;) , caption = form_temp ) + theme_light() plot the posterior predictive distributions of the conditional means with the median F-score and the 95% highest posterior density interval (HDI) ptcld_validation_data %&gt;% dplyr::distinct(depth_maps_generation_quality) %&gt;% tidybayes::add_epred_draws(brms_f_mod1) %&gt;% dplyr::mutate(value = .epred) %&gt;% # plot ggplot( mapping = aes( x = value, y = depth_maps_generation_quality , fill = depth_maps_generation_quality ) ) + tidybayes::stat_halfeye( point_interval = median_hdi, .width = .95 , interval_color = &quot;gray66&quot; , shape = 21, point_color = &quot;gray66&quot;, point_fill = &quot;black&quot; , justification = -0.01 ) + scale_fill_viridis_d(option = &quot;inferno&quot;, drop = F) + scale_x_continuous(breaks = scales::extended_breaks(n=8)) + labs( y = &quot;quality&quot;, x = &quot;F-score&quot; , subtitle = &quot;posterior predictive distribution of F-score with 95% HDI&quot; , caption = form_temp ) + theme_light() + theme(legend.position = &quot;none&quot;) we can also make pairwise comparisons # first we need to define the contrasts to make contrast_list = tidyr::crossing( x1 = unique(ptcld_validation_data$depth_maps_generation_quality) , x2 = unique(ptcld_validation_data$depth_maps_generation_quality) ) %&gt;% dplyr::mutate( dplyr::across( dplyr::everything() , .fns = function(x){factor( x, ordered = T , levels = levels(ptcld_validation_data$depth_maps_generation_quality) )} ) ) %&gt;% dplyr::filter(x1&lt;x2) %&gt;% dplyr::arrange(x1,x2) %&gt;% dplyr::mutate(dplyr::across(dplyr::everything(), as.character)) %&gt;% purrr::transpose() # contrast_list # obtain posterior draws and calculate contrasts using tidybayes::compare_levels brms_contrast_temp = brms_f_mod1 %&gt;% tidybayes::spread_draws(r_depth_maps_generation_quality[depth_maps_generation_quality]) %&gt;% dplyr::mutate( depth_maps_generation_quality = depth_maps_generation_quality %&gt;% stringr::str_replace_all(&quot;\\\\.&quot;, &quot; &quot;) %&gt;% factor( levels = levels(ptcld_validation_data$depth_maps_generation_quality) , ordered = T ) ) %&gt;% dplyr::rename(value = r_depth_maps_generation_quality) %&gt;% tidybayes::compare_levels( value , by = depth_maps_generation_quality , comparison = contrast_list # tidybayes::emmeans_comparison(&quot;revpairwise&quot;) #&quot;pairwise&quot; ) # generate the contrast column for creating an ordered factor brms_contrast_temp = brms_contrast_temp %&gt;% dplyr::ungroup() %&gt;% tidyr::separate_wider_delim( cols = depth_maps_generation_quality , delim = &quot; - &quot; , names = paste0( &quot;sorter&quot; , 1:(max(stringr::str_count(brms_contrast_temp$depth_maps_generation_quality, &quot;-&quot;))+1) ) , too_few = &quot;align_start&quot; , cols_remove = F ) %&gt;% dplyr::filter(sorter1!=sorter2) %&gt;% dplyr::mutate( dplyr::across( tidyselect::starts_with(&quot;sorter&quot;) , .fns = function(x){factor( x, ordered = T , levels = levels(ptcld_validation_data$depth_maps_generation_quality) )} ) , contrast = depth_maps_generation_quality %&gt;% forcats::fct_reorder( paste0(as.numeric(sorter1), as.numeric(sorter2)) %&gt;% as.numeric() ) ) # median_hdi summary for coloring brms_contrast_temp = brms_contrast_temp %&gt;% dplyr::group_by(contrast) %&gt;% dplyr::mutate( # get median_hdi median_hdi_est = tidybayes::median_hdi(value)$y , median_hdi_lower = tidybayes::median_hdi(value)$ymin , median_hdi_upper = tidybayes::median_hdi(value)$ymax # check probability of contrast , pr_gt_zero = mean(value &gt; 0) %&gt;% scales::percent(accuracy = 1) , pr_lt_zero = mean(value &lt; 0) %&gt;% scales::percent(accuracy = 1) # check probability that this direction is true , is_diff_dir = dplyr::case_when( median_hdi_est &gt;= 0 ~ value &gt; 0 , median_hdi_est &lt; 0 ~ value &lt; 0 ) , pr_diff = mean(is_diff_dir) # make a label , pr_diff_lab = dplyr::case_when( median_hdi_est &gt; 0 ~ paste0( &quot;Pr(&quot; , stringr::word(contrast, 1, sep = fixed(&quot;-&quot;)) %&gt;% stringr::str_squish() , &quot;&gt;&quot; , stringr::word(contrast, 2, sep = fixed(&quot;-&quot;)) %&gt;% stringr::str_squish() , &quot;)=&quot; , pr_diff %&gt;% scales::percent(accuracy = 1) ) , median_hdi_est &lt; 0 ~ paste0( &quot;Pr(&quot; , stringr::word(contrast, 2, sep = fixed(&quot;-&quot;)) %&gt;% stringr::str_squish() , &quot;&gt;&quot; , stringr::word(contrast, 1, sep = fixed(&quot;-&quot;)) %&gt;% stringr::str_squish() , &quot;)=&quot; , pr_diff %&gt;% scales::percent(accuracy = 1) ) ) # make a SMALLER label , pr_diff_lab_sm = dplyr::case_when( median_hdi_est &gt;= 0 ~ paste0( &quot;Pr(&gt;0)=&quot; , pr_diff %&gt;% scales::percent(accuracy = 1) ) , median_hdi_est &lt; 0 ~ paste0( &quot;Pr(&lt;0)=&quot; , pr_diff %&gt;% scales::percent(accuracy = 1) ) ) , pr_diff_lab_pos = dplyr::case_when( median_hdi_est &gt; 0 ~ median_hdi_upper , median_hdi_est &lt; 0 ~ median_hdi_lower ) * 1.09 , sig_level = dplyr::case_when( pr_diff &gt; 0.99 ~ 0 , pr_diff &gt; 0.95 ~ 1 , pr_diff &gt; 0.9 ~ 2 , pr_diff &gt; 0.8 ~ 3 , T ~ 4 ) %&gt;% factor(levels = c(0:4), labels = c(&quot;&gt;99%&quot;,&quot;95%&quot;,&quot;90%&quot;,&quot;80%&quot;,&quot;&lt;80%&quot;), ordered = T) ) # what? brms_contrast_temp %&gt;% dplyr::ungroup() %&gt;% dplyr::count(contrast, median_hdi_est, pr_diff_lab,pr_diff_lab_sm) ## # A tibble: 10 × 5 ## contrast median_hdi_est pr_diff_lab pr_diff_lab_sm n ## &lt;fct&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 ultra high - high 0.0370 Pr(ultra high&gt;high)=… Pr(&gt;0)=83% 8000 ## 2 ultra high - medium 0.105 Pr(ultra high&gt;medium… Pr(&gt;0)=100% 8000 ## 3 ultra high - low 0.165 Pr(ultra high&gt;low)=1… Pr(&gt;0)=100% 8000 ## 4 ultra high - lowest 0.287 Pr(ultra high&gt;lowest… Pr(&gt;0)=100% 8000 ## 5 high - medium 0.0670 Pr(high&gt;medium)=95% Pr(&gt;0)=95% 8000 ## 6 high - low 0.128 Pr(high&gt;low)=100% Pr(&gt;0)=100% 8000 ## 7 high - lowest 0.250 Pr(high&gt;lowest)=100% Pr(&gt;0)=100% 8000 ## 8 medium - low 0.0607 Pr(medium&gt;low)=95% Pr(&gt;0)=95% 8000 ## 9 medium - lowest 0.183 Pr(medium&gt;lowest)=10… Pr(&gt;0)=100% 8000 ## 10 low - lowest 0.121 Pr(low&gt;lowest)=100% Pr(&gt;0)=100% 8000 plot it # plot, finally brms_contrast_temp %&gt;% ggplot(aes(x = value, y = contrast, fill = pr_diff)) + tidybayes::stat_halfeye( point_interval = median_hdi, .width = c(0.5,0.95) # , slab_fill = &quot;gray22&quot;, slab_alpha = 1 , interval_color = &quot;black&quot;, point_color = &quot;black&quot;, point_fill = &quot;black&quot; , justification = -0.01 ) + geom_vline(xintercept = 0, linetype = &quot;dashed&quot;, color = &quot;gray44&quot;) + geom_text( data = brms_contrast_temp %&gt;% dplyr::ungroup() %&gt;% dplyr::count(contrast, pr_diff_lab, pr_diff_lab_pos, pr_diff) , mapping = aes(x = pr_diff_lab_pos, label = pr_diff_lab) , vjust = -1, hjust = 0, size = 2.5 ) + scale_fill_fermenter( n.breaks = 10, palette = &quot;PuOr&quot; , direction = 1 , limits = c(0,1) , labels = scales::percent ) + scale_x_continuous(breaks = scales::extended_breaks(n=8), expand = expansion(mult = c(0.1,0.2))) + labs( y = &quot;quality&quot; , x = &quot;constrast (F-score)&quot; , fill = &quot;Pr(contrast)&quot; , subtitle = &quot;posterior predictive distribution of group constrasts with 95% &amp; 50% HDI&quot; , caption = form_temp ) + theme_light() + theme( legend.text = element_text(size = 7) , legend.title = element_text(size = 8) ) + guides(fill = guide_colorbar(theme = theme( legend.key.width = unit(1, &quot;lines&quot;), legend.key.height = unit(12, &quot;lines&quot;) ))) and summarize these contrasts # # can also use the following as substitute for the &quot;tidybayes::spread_draws&quot; used above to get same result brms_contrast_temp %&gt;% dplyr::group_by(contrast) %&gt;% tidybayes::median_hdi(value) %&gt;% select(-c(.point,.interval, .width)) %&gt;% dplyr::arrange(desc(contrast)) %&gt;% kableExtra::kbl( digits = 2 , caption = &quot;brms::brm model: 95% HDI of the posterior predictive distribution of group constrasts in F-score&quot; , col.names = c( &quot;quality contrast&quot; , &quot;difference (F-score)&quot; , &quot;HDI low&quot;, &quot;HDI high&quot; ) ) %&gt;% kableExtra::kable_styling() Table 6.4: brms::brm model: 95% HDI of the posterior predictive distribution of group constrasts in F-score quality contrast difference (F-score) HDI low HDI high low - lowest 0.12 0.04 0.21 medium - lowest 0.18 0.10 0.27 medium - low 0.06 -0.02 0.13 high - lowest 0.25 0.16 0.33 high - low 0.13 0.05 0.20 high - medium 0.07 -0.01 0.15 ultra high - lowest 0.29 0.20 0.37 ultra high - low 0.16 0.09 0.24 ultra high - medium 0.10 0.03 0.18 ultra high - high 0.04 -0.04 0.11 Before we move on to the next section, look above at how many arguments we fiddled with to configure our tidybayes::stat_halfeye() plot. Given how many more contrast plots we have looming in our not-too-distant future, we might go ahead and save these settings as a new function. We’ll call it plt_contrast(). plt_contrast &lt;- function( my_data , x = &quot;value&quot; , y = &quot;contrast&quot; , fill = &quot;pr_diff&quot; , label = &quot;pr_diff_lab&quot; , label_pos = &quot;pr_diff_lab_pos&quot; , label_size = 3 , x_expand = c(0.1, 0.1) , facet = NA , y_axis_title = &quot;&quot; , caption_text = &quot;&quot; # form_temp , annotate_size = 2.2 ) { # df for annotation get_annotation_df &lt;- function( my_text_list = c( &quot;Bottom Left (h0,v0)&quot;,&quot;Top Left (h0,v1)&quot; ,&quot;Bottom Right h1,v0&quot;,&quot;Top Right h1,v1&quot; ) , hjust = c(0,0,1,1) # higher values = right, lower values = left , vjust = c(0,1.3,0,1.3) # higher values = down, lower values = up ){ df = data.frame( xpos = c(-Inf,-Inf,Inf,Inf) , ypos = c(-Inf, Inf,-Inf,Inf) , annotate_text = my_text_list , hjustvar = hjust , vjustvar = vjust ) return(df) } # plot plt = my_data %&gt;% ggplot(aes(x = .data[[x]], y = .data[[y]])) + geom_vline(xintercept = 0, linetype = &quot;solid&quot;, color = &quot;gray33&quot;, lwd = 1.1) + tidybayes::stat_halfeye( mapping = aes(fill = .data[[fill]]) , point_interval = median_hdi, .width = c(0.5,0.95) # , slab_fill = &quot;gray22&quot;, slab_alpha = 1 , interval_color = &quot;black&quot;, point_color = &quot;black&quot;, point_fill = &quot;black&quot; , point_size = 0.9 , justification = -0.01 ) + geom_text( data = get_annotation_df( my_text_list = c( &quot;&quot;,&quot;L.H.S. &lt; R.H.S.&quot; ,&quot;&quot;,&quot;L.H.S. &gt; R.H.S.&quot; ) ) , mapping = aes( x = xpos, y = ypos , hjust = hjustvar, vjust = vjustvar , label = annotate_text , fontface = &quot;bold&quot; ) , size = annotate_size , color = &quot;gray30&quot; # &quot;#2d2a4d&quot; #&quot;#204445&quot; ) + # scale_fill_fermenter( # n.breaks = 5 # 10 use 10 if can go full range 0-1 # , palette = &quot;PuOr&quot; # &quot;RdYlBu&quot; # , direction = 1 # , limits = c(0.5,1) # use c(0,1) if can go full range 0-1 # , labels = scales::percent # ) + scale_fill_stepsn( n.breaks = 5 # 10 use 10 if can go full range 0-1 , colors = RColorBrewer::brewer.pal(11,&quot;PuOr&quot;)[c(3,4,8,10,11)] , limits = c(0.5,1) # use c(0,1) if can go full range 0-1 , labels = scales::percent ) + scale_x_continuous(expand = expansion(mult = x_expand)) + labs( y = y_axis_title , x = &quot;constrast (F-score)&quot; , fill = &quot;Pr(contrast)&quot; , subtitle = &quot;posterior predictive distribution of group constrasts with 95% &amp; 50% HDI&quot; , caption = caption_text ) + theme_light() + theme( legend.text = element_text(size = 7) , legend.title = element_text(size = 8) , axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1.05) , strip.text = element_text(color = &quot;black&quot;, face = &quot;bold&quot;) ) + guides(fill = guide_colorbar(theme = theme( legend.key.width = unit(1, &quot;lines&quot;), legend.key.height = unit(12, &quot;lines&quot;) ))) # return facet or not if(max(is.na(facet))==0){ return( plt + geom_text( data = my_data %&gt;% dplyr::filter(pr_diff_lab_pos&gt;=0) %&gt;% dplyr::ungroup() %&gt;% dplyr::select(tidyselect::all_of(c( y , fill , label , label_pos , facet ))) %&gt;% dplyr::distinct() , mapping = aes(x = .data[[label_pos]], label = .data[[label]]) , vjust = -1, hjust = 0, size = label_size ) + geom_text( data = my_data %&gt;% dplyr::filter(pr_diff_lab_pos&lt;0) %&gt;% dplyr::ungroup() %&gt;% dplyr::select(tidyselect::all_of(c( y , fill , label , label_pos , facet ))) %&gt;% dplyr::distinct() , mapping = aes(x = .data[[label_pos]], label = .data[[label]]) , vjust = -1, hjust = +1, size = label_size ) + facet_grid(cols = vars(.data[[facet]])) ) } else{ return( plt + geom_text( data = my_data %&gt;% dplyr::filter(pr_diff_lab_pos&gt;=0) %&gt;% dplyr::ungroup() %&gt;% dplyr::select(tidyselect::all_of(c( y , fill , label , label_pos ))) %&gt;% dplyr::distinct() , mapping = aes(x = .data[[label_pos]], label = .data[[label]]) , vjust = -1, hjust = 0, size = label_size )+ geom_text( data = my_data %&gt;% dplyr::filter(pr_diff_lab_pos&lt;0) %&gt;% dplyr::ungroup() %&gt;% dplyr::select(tidyselect::all_of(c( y , fill , label , label_pos ))) %&gt;% dplyr::distinct() , mapping = aes(x = .data[[label_pos]], label = .data[[label]]) , vjust = -1, hjust = +1, size = label_size ) ) } } # plt_contrast(brms_contrast_temp, label = &quot;pr_diff_lab_sm&quot;) We’ll also create a function to create all of the probability labeling columns in the contrast data called make_contrast_vars() Note, here we use tidybayes::median_hdci() to avoid potential for returning multiple rows by group if our data is grouped. See the documentation for the ggdist package which notes that “If the distribution is multimodal, hdi may return multiple intervals for each probability level (these will be spread over rows).” make_contrast_vars = function(my_data){ my_data %&gt;% dplyr::mutate( # get median_hdi median_hdi_est = tidybayes::median_hdci(value)$y , median_hdi_lower = tidybayes::median_hdci(value)$ymin , median_hdi_upper = tidybayes::median_hdci(value)$ymax # check probability of contrast , pr_gt_zero = mean(value &gt; 0) %&gt;% scales::percent(accuracy = 1) , pr_lt_zero = mean(value &lt; 0) %&gt;% scales::percent(accuracy = 1) # check probability that this direction is true , is_diff_dir = dplyr::case_when( median_hdi_est &gt;= 0 ~ value &gt; 0 , median_hdi_est &lt; 0 ~ value &lt; 0 ) , pr_diff = mean(is_diff_dir) # make a label , pr_diff_lab = dplyr::case_when( median_hdi_est &gt; 0 ~ paste0( &quot;Pr(&quot; , stringr::word(contrast, 1, sep = fixed(&quot;-&quot;)) %&gt;% stringr::str_squish() , &quot;&gt;&quot; , stringr::word(contrast, 2, sep = fixed(&quot;-&quot;)) %&gt;% stringr::str_squish() , &quot;)=&quot; , pr_diff %&gt;% scales::percent(accuracy = 1) ) , median_hdi_est &lt; 0 ~ paste0( &quot;Pr(&quot; , stringr::word(contrast, 2, sep = fixed(&quot;-&quot;)) %&gt;% stringr::str_squish() , &quot;&gt;&quot; , stringr::word(contrast, 1, sep = fixed(&quot;-&quot;)) %&gt;% stringr::str_squish() , &quot;)=&quot; , pr_diff %&gt;% scales::percent(accuracy = 1) ) ) %&gt;% stringr::str_replace_all(&quot;OPENDRONEMAP&quot;, &quot;ODM&quot;) %&gt;% stringr::str_replace_all(&quot;METASHAPE&quot;, &quot;MtaShp&quot;) %&gt;% stringr::str_replace_all(&quot;PIX4D&quot;, &quot;Pix4D&quot;) # make a SMALLER label , pr_diff_lab_sm = dplyr::case_when( median_hdi_est &gt;= 0 ~ paste0( &quot;Pr(&gt;0)=&quot; , pr_diff %&gt;% scales::percent(accuracy = 1) ) , median_hdi_est &lt; 0 ~ paste0( &quot;Pr(&lt;0)=&quot; , pr_diff %&gt;% scales::percent(accuracy = 1) ) ) , pr_diff_lab_pos = dplyr::case_when( median_hdi_est &gt; 0 ~ median_hdi_upper , median_hdi_est &lt; 0 ~ median_hdi_lower ) * 1.075 , sig_level = dplyr::case_when( pr_diff &gt; 0.99 ~ 0 , pr_diff &gt; 0.95 ~ 1 , pr_diff &gt; 0.9 ~ 2 , pr_diff &gt; 0.8 ~ 3 , T ~ 4 ) %&gt;% factor(levels = c(0:4), labels = c(&quot;&gt;99%&quot;,&quot;95%&quot;,&quot;90%&quot;,&quot;80%&quot;,&quot;&lt;80%&quot;), ordered = T) ) } # brms_contrast_temp %&gt;% dplyr::group_by(contrast) %&gt;% make_contrast_vars() %&gt;% dplyr::glimpse() 6.4 The beta: Three Nominal Predictors + site effects To this point, we have been modelling F-score presuming a Gaussian likelihood. However, the beta likelihood more accurately represents the F-score data which is continuous and restricted within the range of \\((0,1)\\). We borrow here from the excellent series on causal inference by A. Solomon Kurz. We also utilize the guide to Bayesian beta models by Andrew Heiss while Nicole Knight posted about the Beta for ecological data. 6.4.1 Summary Statistics let’s check our underlying data for F-score (our dependent or \\(y\\) variable) # distribution ptcld_validation_data %&gt;% ggplot(mapping = aes(x = f_score)) + geom_hline(yintercept = 0) + geom_vline(xintercept = c(0,1)) + geom_density(fill = &quot;lightblue&quot;, alpha = 0.7, color = NA) + labs(y=&quot;&quot;,x=&quot;F-score&quot;) + scale_y_continuous(breaks = c(0)) + scale_x_continuous(breaks = scales::extended_breaks(10)) + theme_light() + theme(panel.grid = element_blank()) and the summary statistics ptcld_validation_data %&gt;% dplyr::ungroup() %&gt;% dplyr::select(f_score) %&gt;% dplyr::summarise( dplyr::across( dplyr::everything() , .fns = list( mean = ~ mean(.x,na.rm=T), median = ~ median(.x,na.rm=T), sd = ~ sd(.x,na.rm=T) , min = ~ min(.x,na.rm=T), max = ~ max(.x,na.rm=T) , q25 = ~ quantile(.x, 0.25, na.rm = T) , q75 = ~ quantile(.x, 0.75, na.rm = T) ) , .names = &quot;{.fn}&quot; ) ) %&gt;% tidyr::pivot_longer(everything()) %&gt;% kableExtra::kbl(caption = &quot;summary: `f_score`&quot;, digits = 3, col.names = NULL) %&gt;% kableExtra::kable_styling() Table 6.5: summary: f_score mean 0.461 median 0.442 sd 0.229 min 0.000 max 0.900 q25 0.298 q75 0.622 6.4.2 Bayesian With the beta likelihood our model with three nominal predictor variables and subject-level effects the model becomes: \\[\\begin{align*} y_{i} \\sim &amp; \\operatorname{Beta} \\bigl(\\mu_{i}, \\phi \\bigr) \\\\ \\operatorname{logit}(\\mu_{i}) = &amp; \\beta_0 \\\\ &amp; + \\sum_{j=1}^{J=5} \\beta_{1[j]} x_{1[j]} + \\sum_{k=1}^{K=4} \\beta_{2[k]} x_{2[k]} + \\sum_{f=1}^{F=3} \\beta_{3[f]} x_{3[f]} + \\sum_{s=1}^{S=5} \\beta_{4[s]} x_{4[s]} \\\\ &amp; + \\sum_{j,k} \\beta_{1\\times2[j,k]} x_{1\\times2[j,k]} + \\sum_{j,f} \\beta_{1\\times3[j,f]} x_{1\\times3[j,f]} + \\sum_{k,f} \\beta_{2\\times3[k,f]} x_{2\\times3[k,f]} \\\\ &amp; + \\sum_{j,k,f} \\beta_{1\\times2\\times3[j,k,f]} x_{1\\times2\\times3[j,k,f]} \\\\ \\beta_{0} \\sim &amp; \\operatorname{Normal}(0,1) \\\\ \\beta_{1[j]} \\sim &amp; \\operatorname{Normal}(0,\\sigma_{\\beta_{1}}) \\\\ \\beta_{2[k]} \\sim &amp; \\operatorname{Normal}(0,\\sigma_{\\beta_{2}}) \\\\ \\beta_{3[f]} \\sim &amp; \\operatorname{Normal}(0,\\sigma_{\\beta_{3}}) \\\\ \\beta_{4[s]} \\sim &amp; \\operatorname{Normal}(0,\\sigma_{\\beta_{4}}) \\\\ \\beta_{1\\times2[j,k]} \\sim &amp; \\operatorname{Normal}(0,\\sigma_{\\beta_{1\\times2}}) \\\\ \\beta_{1\\times3[j,f]} \\sim &amp; \\operatorname{Normal}(0,\\sigma_{\\beta_{1\\times3}}) \\\\ \\beta_{2\\times3[k,f]} \\sim &amp; \\operatorname{Normal}(0,\\sigma_{\\beta_{2\\times3}}) \\\\ \\sigma_{\\beta_{1}} \\sim &amp; \\operatorname{Student T}(3,0,2.5) \\\\ \\sigma_{\\beta_{2}} \\sim &amp; \\operatorname{Student T}(3,0,2.5) \\\\ \\sigma_{\\beta_{3}} \\sim &amp; \\operatorname{Student T}(3,0,2.5) \\\\ \\sigma_{\\beta_{4}} \\sim &amp; \\operatorname{Student T}(3,0,2.5) \\\\ \\sigma_{\\beta_{1\\times2}} \\sim &amp; \\operatorname{Student T}(3,0,2.5) \\\\ \\sigma_{\\beta_{1\\times3}} \\sim &amp; \\operatorname{Student T}(3,0,2.5) \\\\ \\sigma_{\\beta_{2\\times3}} \\sim &amp; \\operatorname{Student T}(3,0,2.5) \\\\ \\phi \\sim &amp; \\operatorname{Gamma}(0.1,0.1) \\\\ \\end{align*}\\] , where \\(j\\) is the depth map generation quality setting corresponding to observation \\(i\\), \\(k\\) is the depth map filtering mode setting corresponding to observation \\(i\\), \\(f\\) is the processing software corresponding to observation \\(i\\), and \\(s\\) is the study site corresponding to observation \\(i\\) Per brms, our \\(y\\) is \\(\\operatorname{Beta}\\) distributed with the mean as \\(\\mu\\) and the concentration as \\(\\phi\\) which is sometimes called the concentration, sample size or precision. We can think of mean (\\(\\mu\\)) and precision (\\(\\phi\\)) just like with a normal distribution and its mean and standard deviation. brms allows us to model the precision (\\(\\phi\\)) but it is not required. If \\(\\phi\\) is not modeled, you still get a precision component, but it is universal across all the different coefficients (it doesn’t vary across any variables in the model). Heiss explains that: for whatever mathy reasons, when you don’t explicitly model the precision, the resulting coefficient in the table isn’t on the log scale—it’s a regular non-logged number, so there’s no need to exponentiate. in thie brms community post it is similarly noted that: If you don’t predict the parameters, you give priors for them on non-transformed scale. When you predict them, the predictors become linear coefficients as any other and work on the transformed scale - the transformations are specified by the link_XX parameters of the families (and you can change them if you need). 6.4.2.1 Prior distributions #### setting priors # required libraries: tidyverse, tidybayes, brms, palettetown, latex2exp brms_f_mod5_priors_temp &lt;- c( brms::prior(normal(0, 1), class = &quot;Intercept&quot;) , brms::prior(student_t(3, 0, 2.5), class = &quot;sd&quot;) , brms::prior(gamma(0.1, 0.1), class = phi) ) # plot brms_f_mod5_priors_temp %&gt;% tidybayes::parse_dist() %&gt;% tidybayes::marginalize_lkjcorr(K = 2) %&gt;% mutate( distrib = case_when( prior == &quot;student_t(3, 0, 2.5)&quot; ~ latex2exp::TeX(r&#39;($\\sigma \\sim Student\\,T(3, 0, 2.5)$)&#39;, output = &quot;character&quot;), prior == &quot;normal(0, 1)&quot; ~ latex2exp::TeX(r&#39;($\\beta \\sim Normal(0, 1)$)&#39;, output = &quot;character&quot;), prior == &quot;gamma(0.1, 0.1)&quot; ~ latex2exp::TeX(r&#39;($\\phi \\sim$ Gamma(0.1, 0.1))&#39;, output = &quot;character&quot;) )) %&gt;% ggplot(., aes(dist = .dist, args = .args)) + facet_wrap(vars(distrib), scales = &quot;free&quot;, labeller = label_parsed) + ggdist::stat_halfeye( aes(fill = prior), n = 10e2, show.legend = F , fill = &quot;slategray&quot; ) + coord_flip() + theme_light() + theme( strip.text = element_text(face = &quot;bold&quot;, color = &quot;black&quot;), axis.text.y = element_blank(), axis.ticks = element_blank() , plot.subtitle = element_text(size = 8) , plot.title = element_text(size = 9) )+ labs( x = &quot;&quot;, title = &quot;Priors: F-Score&quot;, y = &quot;Log Odds&quot; ) 6.4.2.2 Fit the model Now fit the model. brms_f_mod5 = brms::brm( formula = f_score ~ # baseline 1 + # main effects (1 | depth_maps_generation_quality) + (1 | depth_maps_generation_filtering_mode) + (1 | software) + (1 | study_site) + # only fitting main effects of site and not interactions # two-way interactions (1 | depth_maps_generation_quality:depth_maps_generation_filtering_mode) + (1 | depth_maps_generation_quality:software) + (1 | depth_maps_generation_filtering_mode:software) + # three-way interactions (1 | depth_maps_generation_quality:depth_maps_generation_filtering_mode:software) , data = ptcld_validation_data , family = Beta(link = &quot;logit&quot;) # priors , prior = brms_f_mod5_priors_temp # mcmc , iter = 20000, warmup = 10000, chains = 4 , control = list(adapt_delta = 0.999, max_treedepth = 13) , cores = round(parallel::detectCores()/2) , file = paste0(rootdir, &quot;/fits/brms_f_mod5&quot;) ) # brms::make_stancode(brms_f_mod5) # brms::prior_summary(brms_f_mod5) # print(brms_f_mod5) # brms::neff_ratio(brms_f_mod5) # brms::rhat(brms_f_mod5) # brms::nuts_params(brms_f_mod5) check the prior distributions # check priors brms::prior_summary(brms_f_mod5) %&gt;% kableExtra::kbl() %&gt;% kableExtra::kable_styling() prior class coef group resp dpar nlpar lb ub source normal(0, 1) Intercept user gamma(0.1, 0.1) phi 0 user student_t(3, 0, 2.5) sd 0 user sd depth_maps_generation_filtering_mode default sd Intercept depth_maps_generation_filtering_mode default sd depth_maps_generation_filtering_mode:software default sd Intercept depth_maps_generation_filtering_mode:software default sd depth_maps_generation_quality default sd Intercept depth_maps_generation_quality default sd depth_maps_generation_quality:depth_maps_generation_filtering_mode default sd Intercept depth_maps_generation_quality:depth_maps_generation_filtering_mode default sd depth_maps_generation_quality:depth_maps_generation_filtering_mode:software default sd Intercept depth_maps_generation_quality:depth_maps_generation_filtering_mode:software default sd depth_maps_generation_quality:software default sd Intercept depth_maps_generation_quality:software default sd software default sd Intercept software default sd study_site default sd Intercept study_site default The brms::brm model summary We won’t clutter the output here but this can be run if you are following along on your own brms_f_mod5 %&gt;% brms::posterior_summary() %&gt;% as.data.frame() %&gt;% tibble::rownames_to_column(var = &quot;parameter&quot;) %&gt;% dplyr::rename_with(tolower) %&gt;% dplyr::filter( stringr::str_starts(parameter, &quot;b_&quot;) | stringr::str_starts(parameter, &quot;r_&quot;) | stringr::str_starts(parameter, &quot;sd_&quot;) | parameter == &quot;phi&quot; ) %&gt;% dplyr::mutate( parameter = parameter %&gt;% stringr::str_replace_all(&quot;depth_maps_generation_quality&quot;, &quot;quality&quot;) %&gt;% stringr::str_replace_all(&quot;depth_maps_generation_filtering_mode&quot;, &quot;filtering&quot;) ) %&gt;% kableExtra::kbl(digits = 2, caption = &quot;Bayesian final model for F-score&quot;) %&gt;% kableExtra::kable_styling() %&gt;% kableExtra::scroll_box(height = &quot;8in&quot;) 6.4.2.3 Posterior Predictive Checks Markov chain Monte Carlo (MCMC) simulations were conducted using the brms package (Bürkner 2017) to estimate posterior predictive distributions of the parameters of interest. We ran three chains of 100,000 iterations with the first 50,000 discarded as burn-in. Trace-plots were utilized to visually assess model convergence. check the trace plots for problems with convergence of the Markov chains plot(brms_f_mod5) Sufficient convergence was checked with \\(\\hat{R}\\) values near 1 (Brooks &amp; Gelman, 1998). check our \\(\\hat{R}\\) values brms::mcmc_plot(brms_f_mod5, type = &quot;rhat_hist&quot;) + theme_light() + theme( legend.position = &quot;top&quot;, legend.direction = &quot;horizontal&quot; ) and another check of our \\(\\hat{R}\\) values brms_f_mod5 %&gt;% brms::rhat() %&gt;% as.data.frame() %&gt;% tibble::rownames_to_column(var = &quot;parameter&quot;) %&gt;% dplyr::rename_with(tolower) %&gt;% dplyr::rename(rhat = 2) %&gt;% dplyr::filter( stringr::str_starts(parameter, &quot;b_&quot;) | stringr::str_starts(parameter, &quot;r_&quot;) | stringr::str_starts(parameter, &quot;sd_&quot;) | parameter == &quot;phi&quot; ) %&gt;% dplyr::mutate( parameter = parameter %&gt;% stringr::str_replace_all(&quot;depth_maps_generation_quality&quot;, &quot;quality&quot;) %&gt;% stringr::str_replace_all(&quot;depth_maps_generation_filtering_mode&quot;, &quot;filtering&quot;) , chk = (rhat &lt;= 1*0.998 | rhat &gt;= 1*1.002) ) %&gt;% ggplot(aes(x = rhat, y = parameter, color = chk, fill = chk)) + geom_vline(xintercept = 1, linetype = &quot;dashed&quot;, color = &quot;gray44&quot;, lwd = 1.2) + geom_vline(xintercept = 1*0.998, lwd = 1.5) + geom_vline(xintercept = 1*1.002, lwd = 1.5) + geom_vline(xintercept = 1*0.999, lwd = 1.2, color = &quot;gray33&quot;) + geom_vline(xintercept = 1*1.001, lwd = 1.2, color = &quot;gray33&quot;) + geom_point() + scale_fill_manual(values = c(&quot;navy&quot;, &quot;firebrick&quot;)) + scale_color_manual(values = c(&quot;navy&quot;, &quot;firebrick&quot;)) + scale_y_discrete(NULL, breaks = NULL) + labs( x = latex2exp::TeX(&quot;$\\\\hat{R}$&quot;) , subtitle = latex2exp::TeX(&quot;MCMC chain convergence check for $\\\\hat{R}$ values&quot;) , title = &quot;F-Score&quot; ) + theme_light() + theme( legend.position = &quot;none&quot; , axis.text.y = element_text(size = 4) , panel.grid.major.x = element_blank() , panel.grid.minor.x = element_blank() , plot.subtitle = element_text(size = 8) , plot.title = element_text(size = 9) ) The effective length of an MCMC chain is indicated by the effective sample size (ESS), which refers to the sample size of the MCMC chain not to the sample size of the data Kruschke (2015) notes: One simple guideline is this: For reasonably accurate and stable estimates of the limits of the 95% HDI, an ESS of 10,000 is recommended. This is merely a heuristic based on experience with practical applications, it is not a requirement. If accuracy of the HDI limits is not crucial for your application, then a smaller ESS may be sufficient. (p.184) # get ess values from model summary dplyr::bind_rows( summary(brms_f_mod5) %&gt;% purrr::pluck(&quot;random&quot;) %&gt;% purrr::flatten() %&gt;% purrr::keep_at(~ .x == &quot;Bulk_ESS&quot;) %&gt;% unlist() %&gt;% dplyr::as_tibble() , summary(brms_f_mod5) %&gt;% purrr::pluck(&quot;fixed&quot;) %&gt;% purrr::flatten() %&gt;% purrr::keep_at(~ .x == &quot;Bulk_ESS&quot;) %&gt;% unlist() %&gt;% dplyr::as_tibble() ) %&gt;% dplyr::rename(ess = 1) %&gt;% dplyr::mutate(parameter = dplyr::row_number(), chk = ess&lt;10000) %&gt;% ggplot(aes(x = ess, y = parameter, color = chk, fill = chk)) + geom_vline(xintercept = 10000, linetype = &quot;dashed&quot;, color = &quot;gray44&quot;, lwd = 1.2) + geom_segment( aes(x = 0, xend=ess, yend=parameter), color=&quot;black&quot;) + geom_point() + scale_fill_manual(values = c(&quot;blue4&quot;, &quot;blue3&quot;)) + scale_color_manual(values = c(&quot;blue4&quot;, &quot;blue3&quot;)) + scale_y_continuous(NULL, breaks = NULL) + scale_x_continuous(labels = scales::comma) + labs( x = &quot;ESS&quot; , subtitle = &quot;MCMC chain resolution check for effective sample size (ESS) values&quot; , y = &quot;&quot; , title = &quot;F-Score&quot; ) + theme_light() + theme( legend.position = &quot;none&quot; , axis.text.y = element_text(size = 4) , panel.grid.major.x = element_blank() , panel.grid.minor.x = element_blank() , plot.subtitle = element_text(size = 8) , plot.title = element_text(size = 9) ) and another effective sample size check brms::mcmc_plot(brms_f_mod5, type = &quot;neff_hist&quot;) + theme_light() + theme( legend.position = &quot;top&quot;, legend.direction = &quot;horizontal&quot; ) Posterior predictive checks were used to evaluate model goodness-of-fit by comparing data simulated from the model with the observed data used to estimate the model parameters (Hobbs &amp; Hooten, 2015). Calculating the proportion of MCMC iterations in which the test statistic (i.e., mean and sum of squares) from the simulated data and observed data are more extreme than one another provides the Bayesian p-value. Lack of fit is indicated by a value close to 0 or 1 while a value of 0.5 indicates perfect fit (Hobbs &amp; Hooten, 2015). To learn more about this approach to posterior predictive checks, check out Gabry’s (2022) vignette, Graphical posterior predictive checks using the bayesplot package. posterior-predictive check to make sure the model does an okay job simulating data that resemble the sample data # posterior predictive check brms::pp_check( brms_f_mod5 , type = &quot;dens_overlay&quot; , ndraws = 100 ) + labs(subtitle = &quot;posterior-predictive check (overlaid densities)&quot;) + theme_light() + scale_y_continuous(NULL, breaks = NULL) + theme( legend.position = &quot;top&quot;, legend.direction = &quot;horizontal&quot; , legend.text = element_text(size = 14) , plot.subtitle = element_text(size = 8) , plot.title = element_text(size = 9) ) ggplot2::ggsave(&quot;../data/ppchk_ovrll_mod5.png&quot;, height = 7, width = 10.5) another way brms::pp_check(brms_f_mod5, type = &quot;ecdf_overlay&quot;, ndraws = 100) + labs(subtitle = &quot;posterior-predictive check (ECDF: empirical cumulative distribution function)&quot;) + theme_light() + theme( legend.position = &quot;top&quot;, legend.direction = &quot;horizontal&quot; , legend.text = element_text(size = 14) ) and another posterior predictive check for the overall model # means p1_temp = brms::pp_check( brms_f_mod5 , type = &quot;stat&quot; , stat = &quot;mean&quot; ) + scale_y_continuous(NULL, breaks = c(NULL)) + labs(subtitle = &quot;means&quot;) + theme_light() # sds p2_temp = brms::pp_check( brms_f_mod5 , type = &quot;stat&quot; , stat = &quot;sd&quot; ) + scale_y_continuous(NULL, breaks = c(NULL)) + labs(subtitle = &quot;sd&#39;s&quot;) + theme_light() # combine (p1_temp + p2_temp) &amp; theme(legend.position = &quot;none&quot;) &amp; plot_annotation( title = &quot;Posterior-predictive statistical checks\\noverall model&quot; , subtitle = expression( &quot;The dark blue lines are &quot;*italic(T(y))*&quot;, and the light blue bars are for &quot;*italic(T)(italic(y)[rep])*&quot;.&quot;) ) and another posterior predictive check for the overall model combining mean and sd brms::pp_check(brms_f_mod5, type = &quot;stat_2d&quot;) + theme_light() + labs(title = &quot;F-Score&quot;) + theme( legend.position = &quot;top&quot;, legend.direction = &quot;horizontal&quot; , legend.text = element_text(size = 8) , plot.title = element_text(size = 9) ) How’d we do capturing the conditional means and standard deviations by depth map generation quality? # means p1_temp = brms::pp_check( brms_f_mod5 , type = &quot;stat_grouped&quot; # &quot;dens_overlay_grouped&quot; , stat = &quot;mean&quot; , group = &quot;depth_maps_generation_quality&quot; ) + scale_y_continuous(NULL, breaks = c(NULL)) + labs(subtitle = &quot;means&quot;) + facet_grid(cols = vars(group), scales = &quot;free&quot;) + theme_light() # sds p2_temp = brms::pp_check( brms_f_mod5 , type = &quot;stat_grouped&quot; # &quot;dens_overlay_grouped&quot; , stat = &quot;sd&quot; , group = &quot;depth_maps_generation_quality&quot; ) + scale_y_continuous(NULL, breaks = c(NULL)) + labs(subtitle = &quot;sd&#39;s&quot;) + facet_grid(cols = vars(group), scales = &quot;free&quot;) + theme_light() # combine (p1_temp / p2_temp) &amp; theme(legend.position = &quot;none&quot;) &amp; plot_annotation( title = &quot;Posterior-predictive statistical checks\\nby dense cloud quality&quot; , subtitle = expression( &quot;The dark blue lines are &quot;*italic(T(y))*&quot;, and the light blue bars are for &quot;*italic(T)(italic(y)[rep])*&quot;.&quot;) ) ggplot2::ggsave(&quot;../data/ppchk_qlty_mod5.png&quot;, height = 7, width = 10.5) Both the means and sd’s of the F-score are well represented across the different levels of dense cloud quality What about for the software? pp_check(brms_f_mod5, &quot;dens_overlay_grouped&quot;, group = &quot;software&quot;, ndraws = 100) + labs(subtitle = &quot;posterior-predictive check (overlaid densities)\\nby software&quot;) + theme_light() + scale_y_continuous(NULL, breaks = NULL) + theme( legend.position = &quot;top&quot;, legend.direction = &quot;horizontal&quot; , legend.text = element_text(size = 14) ) ggplot2::ggsave(&quot;../data/ppchk_sftwr_mod5.png&quot;, height = 7, width = 10.5) and what about for the filtering mode? pp_check(brms_f_mod5, &quot;dens_overlay_grouped&quot;, group = &quot;depth_maps_generation_filtering_mode&quot;, ndraws = 100) + labs(subtitle = &quot;posterior-predictive check (overlaid densities)\\nby filtering mode&quot;) + theme_light() + scale_y_continuous(NULL, breaks = NULL) + theme( legend.position = &quot;top&quot;, legend.direction = &quot;horizontal&quot; , legend.text = element_text(size = 14) ) It looks like our model is making predictions that are consistent with our original data, which is what we want. We can look at the model noise standard deviation (concentration) \\(\\phi\\) and the intercept We can think of mean (\\(\\mu\\)) and precision (\\(\\phi\\)) just like with a normal distribution and its mean and standard deviation. # get formula form_temp = brms_f_mod5$formula$formula[3] %&gt;% as.character() %&gt;% get_frmla_text() %&gt;% stringr::str_replace_all(&quot;depth_maps_generation_quality&quot;, &quot;quality&quot;) %&gt;% stringr::str_replace_all(&quot;depth_maps_generation_filtering_mode&quot;, &quot;filtering&quot;) # extract the posterior draws brms::as_draws_df(brms_f_mod5) %&gt;% # plot ggplot(aes(x = phi, y = 0)) + tidybayes::stat_dotsinterval( point_interval = median_hdi, .width = .95 , justification = -0.04 , shape = 21, point_size = 3 , quantiles = 100 ) + scale_y_continuous(NULL, breaks = NULL) + labs( x = latex2exp::TeX(&quot;$\\\\phi$&quot;) # , caption = form_temp ) + theme_light() ggplot2::ggsave(&quot;../data/phi_posterior_mod5.png&quot;, height = 7, width = 10.5) 6.4.2.4 Quality:Filtering - interaction Are there differences in F-score based on dense point cloud generation quality within each level of filtering mode? Here, we collapse across the study site and software to compare the combined dense cloud quality and filtering mode effect. In a hierarchical model structure, we have to make use of the re_formula argument within tidybayes::add_epred_draws qlty_filter_draws_temp = ptcld_validation_data %&gt;% dplyr::distinct(depth_maps_generation_quality, depth_maps_generation_filtering_mode) %&gt;% tidybayes::add_epred_draws( brms_f_mod5, allow_new_levels = T # this part is crucial , re_formula = ~ (1 | depth_maps_generation_quality) + (1 | depth_maps_generation_filtering_mode) + (1 | depth_maps_generation_quality:depth_maps_generation_filtering_mode) ) %&gt;% dplyr::rename(value = .epred) %&gt;% dplyr::mutate(med = tidybayes::median_hdci(value)$y) # plot qlty_filter_draws_temp %&gt;% dplyr::mutate(depth_maps_generation_quality = depth_maps_generation_quality %&gt;% forcats::fct_rev()) %&gt;% # plot ggplot( mapping = aes( y = value, x = depth_maps_generation_filtering_mode # , fill = depth_maps_generation_filtering_mode , fill = med ) ) + tidybayes::stat_eye( point_interval = median_hdi, .width = .95 , slab_alpha = 0.95 , interval_color = &quot;black&quot;, linewidth = 1 , point_color = &quot;black&quot;, point_fill = &quot;black&quot;, point_size = 1 ) + # scale_fill_viridis_d(option = &quot;plasma&quot;, drop = F) + scale_fill_viridis_c(option = &quot;mako&quot;, direction=-1, begin = 0.2, end = 0.8, limits = c(0,1)) + scale_y_continuous(limits = c(0,1), breaks = scales::extended_breaks(n=8)) + facet_grid(cols = vars(depth_maps_generation_quality)) + labs( x = &quot;filtering mode&quot;, y = &quot;F-score&quot; , subtitle = &quot;posterior predictive distribution of F-score with 95% HDI\\nby dense cloud quality&quot; , fill = &quot;Filtering Mode&quot; # , caption = form_temp ) + theme_light() + theme( legend.position = &quot;none&quot; , legend.direction = &quot;horizontal&quot; , axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1) , strip.text = element_text(color = &quot;black&quot;, face = &quot;bold&quot;) ) ggplot2::ggsave( &quot;../data/qlty_fltr_mod5.png&quot; , plot = ggplot2::last_plot() + labs(subtitle = &quot;&quot;) , height = 7, width = 10.5 ) and a table of these 95% HDI values table_temp = qlty_filter_draws_temp %&gt;% tidybayes::median_hdi(value) %&gt;% dplyr::select(-c(.point,.interval, .width,.row)) %&gt;% dplyr::arrange(depth_maps_generation_quality, depth_maps_generation_filtering_mode) table_temp %&gt;% dplyr::select(-c(depth_maps_generation_quality)) %&gt;% kableExtra::kbl( digits = 2 , caption = &quot;F-score&lt;br&gt;95% HDI of the posterior predictive distribution&quot; , col.names = c( &quot;filtering mode&quot; , &quot;F-score&lt;br&gt;median&quot; , &quot;HDI low&quot;, &quot;HDI high&quot; ) , escape = F ) %&gt;% kableExtra::kable_styling() %&gt;% kableExtra::pack_rows(index = table(forcats::fct_inorder(table_temp$depth_maps_generation_quality))) %&gt;% kableExtra::scroll_box(height = &quot;8in&quot;) Table 6.6: F-score95% HDI of the posterior predictive distribution filtering mode F-scoremedian HDI low HDI high ultra high aggressive 0.54 0.27 0.79 moderate 0.55 0.28 0.80 mild 0.57 0.30 0.82 disabled 0.56 0.29 0.81 high aggressive 0.51 0.25 0.78 moderate 0.52 0.26 0.78 mild 0.54 0.28 0.80 disabled 0.54 0.28 0.80 medium aggressive 0.44 0.20 0.71 moderate 0.46 0.22 0.73 mild 0.48 0.23 0.75 disabled 0.48 0.22 0.73 low aggressive 0.39 0.15 0.65 moderate 0.41 0.17 0.67 mild 0.44 0.19 0.70 disabled 0.43 0.19 0.70 lowest aggressive 0.26 0.07 0.54 moderate 0.28 0.07 0.55 mild 0.30 0.09 0.59 disabled 0.30 0.08 0.59 we can also make pairwise comparisons so long as we continue using tidybayes::add_epred_draws with the re_formula argument brms_contrast_temp = qlty_filter_draws_temp %&gt;% tidybayes::compare_levels( value , by = depth_maps_generation_quality , comparison = contrast_list # tidybayes::emmeans_comparison(&quot;revpairwise&quot;) #&quot;pairwise&quot; ) %&gt;% dplyr::rename(contrast = depth_maps_generation_quality) # separate contrast brms_contrast_temp = brms_contrast_temp %&gt;% dplyr::ungroup() %&gt;% tidyr::separate_wider_delim( cols = contrast , delim = &quot; - &quot; , names = paste0( &quot;sorter&quot; , 1:(max(stringr::str_count(brms_contrast_temp$contrast, &quot;-&quot;))+1) ) , too_few = &quot;align_start&quot; , cols_remove = F ) %&gt;% dplyr::filter(sorter1!=sorter2) %&gt;% dplyr::mutate( dplyr::across( tidyselect::starts_with(&quot;sorter&quot;) , .fns = function(x){factor( x, ordered = T , levels = levels(ptcld_validation_data$depth_maps_generation_quality) )} ) , contrast = contrast %&gt;% forcats::fct_reorder( paste0(as.numeric(sorter1), as.numeric(sorter2)) %&gt;% as.numeric() ) , depth_maps_generation_filtering_mode = depth_maps_generation_filtering_mode %&gt;% factor( levels = levels(ptcld_validation_data$depth_maps_generation_filtering_mode) , ordered = T ) ) %&gt;% # median_hdi summary for coloring dplyr::group_by(contrast,depth_maps_generation_filtering_mode) %&gt;% make_contrast_vars() what is this contrast data? # what? brms_contrast_temp %&gt;% dplyr::glimpse() ## Rows: 1,600,000 ## Columns: 19 ## Groups: contrast, depth_maps_generation_filtering_mode [40] ## $ depth_maps_generation_filtering_mode &lt;ord&gt; aggressive, aggressive, aggressiv… ## $ .chain &lt;int&gt; NA, NA, NA, NA, NA, NA, NA, NA, N… ## $ .iteration &lt;int&gt; NA, NA, NA, NA, NA, NA, NA, NA, N… ## $ .draw &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11… ## $ sorter1 &lt;ord&gt; ultra high, ultra high, ultra hig… ## $ sorter2 &lt;ord&gt; high, high, high, high, high, hig… ## $ contrast &lt;fct&gt; ultra high - high, ultra high - h… ## $ value &lt;dbl&gt; 0.083223039, -0.003290295, 0.0391… ## $ median_hdi_est &lt;dbl&gt; 0.02335122, 0.02335122, 0.0233512… ## $ median_hdi_lower &lt;dbl&gt; -0.1508205, -0.1508205, -0.150820… ## $ median_hdi_upper &lt;dbl&gt; 0.206113, 0.206113, 0.206113, 0.2… ## $ pr_gt_zero &lt;chr&gt; &quot;62%&quot;, &quot;62%&quot;, &quot;62%&quot;, &quot;62%&quot;, &quot;62%&quot;… ## $ pr_lt_zero &lt;chr&gt; &quot;38%&quot;, &quot;38%&quot;, &quot;38%&quot;, &quot;38%&quot;, &quot;38%&quot;… ## $ is_diff_dir &lt;lgl&gt; TRUE, FALSE, TRUE, FALSE, TRUE, T… ## $ pr_diff &lt;dbl&gt; 0.615375, 0.615375, 0.615375, 0.6… ## $ pr_diff_lab &lt;chr&gt; &quot;Pr(ultra high&gt;high)=62%&quot;, &quot;Pr(ul… ## $ pr_diff_lab_sm &lt;chr&gt; &quot;Pr(&gt;0)=62%&quot;, &quot;Pr(&gt;0)=62%&quot;, &quot;Pr(&gt;… ## $ pr_diff_lab_pos &lt;dbl&gt; 0.2215714, 0.2215714, 0.2215714, … ## $ sig_level &lt;ord&gt; &lt;80%, &lt;80%, &lt;80%, &lt;80%, &lt;80%, &lt;80… plot it plt_contrast( brms_contrast_temp # , caption_text = form_temp , y_axis_title = &quot;quality&quot; , facet = &quot;depth_maps_generation_filtering_mode&quot; , label_size = 2.0 , x_expand = c(0,0.6) ) + labs( subtitle = &quot;posterior predictive distribution of group constrasts with 95% &amp; 50% HDI\\nby filtering mode&quot; ) + theme( axis.text.x = element_text(size = 7) ) ggplot2::ggsave( &quot;../data/qlty_fltr_comp_mod5.png&quot; , plot = ggplot2::last_plot() + labs(subtitle = &quot;&quot;) , height = 7, width = 10.5 ) and summarize these contrasts table_temp = brms_contrast_temp %&gt;% dplyr::group_by(contrast, depth_maps_generation_filtering_mode, pr_gt_zero) %&gt;% tidybayes::median_hdi(value) %&gt;% dplyr::arrange(contrast, depth_maps_generation_filtering_mode) %&gt;% dplyr::select(contrast, depth_maps_generation_filtering_mode, value, .lower, .upper, pr_gt_zero) %&gt;% dplyr::arrange(contrast, depth_maps_generation_filtering_mode) table_temp %&gt;% dplyr::select(-c(contrast)) %&gt;% kableExtra::kbl( digits = 2 , caption = &quot;brms::brm model: 95% HDI of the posterior predictive distribution of group constrasts&quot; , col.names = c( &quot;filtering mode&quot; , &quot;median difference&lt;br&gt;F-score&quot; , &quot;HDI low&quot;, &quot;HDI high&quot; , &quot;Pr(diff&gt;0)&quot; ) , escape = F ) %&gt;% kableExtra::kable_styling() %&gt;% kableExtra::pack_rows(index = table(forcats::fct_inorder(table_temp$contrast))) %&gt;% kableExtra::scroll_box(height = &quot;8in&quot;) Table 6.7: brms::brm model: 95% HDI of the posterior predictive distribution of group constrasts filtering mode median differenceF-score HDI low HDI high Pr(diff&gt;0) ultra high - high aggressive 0.02 -0.15 0.21 62% moderate 0.02 -0.15 0.20 62% mild 0.02 -0.15 0.20 62% disabled 0.02 -0.15 0.20 60% ultra high - medium aggressive 0.08 -0.09 0.27 82% moderate 0.08 -0.09 0.27 82% mild 0.08 -0.10 0.26 81% disabled 0.08 -0.10 0.26 81% ultra high - low aggressive 0.13 -0.05 0.32 92% moderate 0.14 -0.05 0.32 92% mild 0.12 -0.07 0.30 89% disabled 0.12 -0.07 0.31 89% ultra high - lowest aggressive 0.26 -0.01 0.47 97% moderate 0.26 -0.01 0.47 97% mild 0.25 -0.02 0.46 96% disabled 0.25 -0.03 0.46 95% high - medium aggressive 0.06 -0.12 0.24 75% moderate 0.05 -0.12 0.24 75% mild 0.05 -0.13 0.23 73% disabled 0.05 -0.12 0.24 74% high - low aggressive 0.11 -0.07 0.30 88% moderate 0.11 -0.08 0.29 88% mild 0.10 -0.08 0.28 85% disabled 0.10 -0.09 0.28 85% high - lowest aggressive 0.23 -0.02 0.44 96% moderate 0.23 -0.02 0.44 96% mild 0.23 -0.03 0.43 95% disabled 0.22 -0.04 0.43 95% medium - low aggressive 0.05 -0.12 0.23 73% moderate 0.05 -0.12 0.23 73% mild 0.04 -0.12 0.23 70% disabled 0.04 -0.14 0.21 69% medium - lowest aggressive 0.17 -0.04 0.37 94% moderate 0.17 -0.04 0.37 94% mild 0.17 -0.05 0.37 92% disabled 0.16 -0.05 0.37 92% low - lowest aggressive 0.11 -0.07 0.31 89% moderate 0.12 -0.08 0.31 89% mild 0.12 -0.08 0.32 88% disabled 0.12 -0.08 0.32 88% 6.4.2.5 Software:Quality - interaction It might be more important to understand the difference in F-score by dense cloud quality and software rather than filtering mode since filtering mode had such a small effect on the SfM predictive ability Are there differences in F-score based on dense point cloud generation quality within each different processing software? We will also address the similar but slightly different question of “are there differences in F-score based on the processing software used at a given dense point cloud generation quality?” Here, we collapse across the study site and filtering mode to compare the combined dense cloud quality and software effect. In a hierarchical model structure, we have to make use of the re_formula argument within tidybayes::add_epred_draws # get draws qlty_sftwr_draws_temp = tidyr::crossing( depth_maps_generation_quality = unique(ptcld_validation_data$depth_maps_generation_quality) , software = unique(ptcld_validation_data$software) ) %&gt;% tidybayes::add_epred_draws( brms_f_mod5, allow_new_levels = T # this part is crucial , re_formula = ~ (1 | depth_maps_generation_quality) + (1 | software) + (1 | depth_maps_generation_quality:software) ) %&gt;% dplyr::rename(value = .epred) %&gt;% dplyr::mutate( med = tidybayes::median_hdci(value)$y ) # plot qlty_sftwr_draws_temp %&gt;% # remove out-of-sample obs dplyr::inner_join( ptcld_validation_data %&gt;% dplyr::distinct(depth_maps_generation_quality, software) , by = dplyr::join_by(depth_maps_generation_quality, software) ) %&gt;% dplyr::mutate( depth_maps_generation_quality = depth_maps_generation_quality %&gt;% forcats::fct_rev() ) %&gt;% # plot ggplot( mapping = aes( y = value, x = software # , fill = software , fill = med ) ) + tidybayes::stat_eye( point_interval = median_hdi, .width = .95 , slab_alpha = 0.95 , interval_color = &quot;black&quot;, linewidth = 1 , point_color = &quot;black&quot;, point_fill = &quot;black&quot;, point_size = 1 ) + # scale_fill_viridis_d(option = &quot;rocket&quot;, begin = 0.3, end = 0.9, drop = F) + scale_fill_viridis_c(option = &quot;mako&quot;, direction=-1, begin = 0.2, end = 0.8, limits = c(0,1)) + scale_y_continuous(limits = c(0,1), breaks = scales::extended_breaks(n=8)) + facet_grid(cols = vars(depth_maps_generation_quality)) + labs( x = &quot;software&quot;, y = &quot;F-score&quot; , subtitle = &quot;posterior predictive distribution of F-score with 95% HDI\\nby dense cloud quality&quot; # , caption = form_temp ) + theme_light() + theme( legend.position = &quot;none&quot; , legend.direction = &quot;horizontal&quot; , axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1) , strip.text = element_text(color = &quot;black&quot;, face = &quot;bold&quot;) ) and a table of these 95% HDI values table_temp = qlty_sftwr_draws_temp %&gt;% tidybayes::median_hdi(value) %&gt;% # remove out-of-sample obs dplyr::inner_join( ptcld_validation_data %&gt;% dplyr::distinct(depth_maps_generation_quality, software) , by = dplyr::join_by(depth_maps_generation_quality, software) ) %&gt;% dplyr::select(-c(.point,.interval, .width,.row)) %&gt;% dplyr::arrange(software,depth_maps_generation_quality) table_temp %&gt;% dplyr::select(-c(software)) %&gt;% kableExtra::kbl( digits = 2 , caption = &quot;F-score&lt;br&gt;95% HDI of the posterior predictive distribution&quot; , col.names = c( &quot;quality&quot; , &quot;F-score&lt;br&gt;median&quot; , &quot;HDI low&quot;, &quot;HDI high&quot; ) , escape = F ) %&gt;% kableExtra::kable_styling() %&gt;% kableExtra::pack_rows(index = table(forcats::fct_inorder(table_temp$software))) %&gt;% kableExtra::scroll_box(height = &quot;8in&quot;) Table 6.8: F-score95% HDI of the posterior predictive distribution quality F-scoremedian HDI low HDI high METASHAPE ultra high 0.61 0.39 0.81 high 0.59 0.38 0.80 medium 0.54 0.32 0.76 low 0.40 0.20 0.63 lowest 0.15 0.05 0.29 OPENDRONEMAP ultra high 0.59 0.37 0.80 high 0.50 0.29 0.73 medium 0.33 0.15 0.55 low 0.33 0.16 0.56 lowest 0.32 0.14 0.53 PIX4D ultra high 0.55 0.31 0.76 high 0.54 0.32 0.76 medium 0.54 0.31 0.76 low 0.47 0.25 0.70 we can also make pairwise comparisons so long as we continue using tidybayes::add_epred_draws with the re_formula argument # calculate contrast brms_contrast_temp = qlty_sftwr_draws_temp %&gt;% tidybayes::compare_levels( value , by = depth_maps_generation_quality , comparison = contrast_list ) %&gt;% dplyr::rename(contrast = depth_maps_generation_quality) # separate contrast brms_contrast_temp = brms_contrast_temp %&gt;% dplyr::ungroup() %&gt;% tidyr::separate_wider_delim( cols = contrast , delim = &quot; - &quot; , names = paste0( &quot;sorter&quot; , 1:(max(stringr::str_count(brms_contrast_temp$contrast, &quot;-&quot;))+1) ) , too_few = &quot;align_start&quot; , cols_remove = F ) %&gt;% dplyr::filter(sorter1!=sorter2) %&gt;% dplyr::mutate( dplyr::across( tidyselect::starts_with(&quot;sorter&quot;) , .fns = function(x){factor( x, ordered = T , levels = levels(ptcld_validation_data$depth_maps_generation_quality) )} ) , contrast = contrast %&gt;% forcats::fct_reorder( paste0(as.numeric(sorter1), as.numeric(sorter2)) %&gt;% as.numeric() ) ) %&gt;% # median_hdi summary for coloring dplyr::group_by(contrast, software) %&gt;% make_contrast_vars() # remove out-of-sample obs brms_contrast_temp = brms_contrast_temp %&gt;% dplyr::inner_join( ptcld_validation_data %&gt;% dplyr::distinct(software, depth_maps_generation_quality) , by = dplyr::join_by(software, sorter1 == depth_maps_generation_quality) ) %&gt;% dplyr::inner_join( ptcld_validation_data %&gt;% dplyr::distinct(software, depth_maps_generation_quality) , by = dplyr::join_by(software, sorter2 == depth_maps_generation_quality) ) what is this contrast data? # what? brms_contrast_temp %&gt;% dplyr::glimpse() ## Rows: 1,040,000 ## Columns: 19 ## Groups: contrast, software [26] ## $ software &lt;chr&gt; &quot;METASHAPE&quot;, &quot;METASHAPE&quot;, &quot;METASHAPE&quot;, &quot;METASHAPE&quot;, &quot;… ## $ .chain &lt;int&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N… ## $ .iteration &lt;int&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N… ## $ .draw &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16… ## $ sorter1 &lt;ord&gt; ultra high, ultra high, ultra high, ultra high, ultra… ## $ sorter2 &lt;ord&gt; high, high, high, high, high, high, high, high, high,… ## $ contrast &lt;fct&gt; ultra high - high, ultra high - high, ultra high - hi… ## $ value &lt;dbl&gt; 0.041920792, -0.026803663, 0.071755845, -0.048138613,… ## $ median_hdi_est &lt;dbl&gt; 0.016348, 0.016348, 0.016348, 0.016348, 0.016348, 0.0… ## $ median_hdi_lower &lt;dbl&gt; -0.07970382, -0.07970382, -0.07970382, -0.07970382, -… ## $ median_hdi_upper &lt;dbl&gt; 0.1179741, 0.1179741, 0.1179741, 0.1179741, 0.1179741… ## $ pr_gt_zero &lt;chr&gt; &quot;63%&quot;, &quot;63%&quot;, &quot;63%&quot;, &quot;63%&quot;, &quot;63%&quot;, &quot;63%&quot;, &quot;63%&quot;, &quot;63%… ## $ pr_lt_zero &lt;chr&gt; &quot;37%&quot;, &quot;37%&quot;, &quot;37%&quot;, &quot;37%&quot;, &quot;37%&quot;, &quot;37%&quot;, &quot;37%&quot;, &quot;37%… ## $ is_diff_dir &lt;lgl&gt; TRUE, FALSE, TRUE, FALSE, TRUE, TRUE, TRUE, TRUE, TRU… ## $ pr_diff &lt;dbl&gt; 0.63185, 0.63185, 0.63185, 0.63185, 0.63185, 0.63185,… ## $ pr_diff_lab &lt;chr&gt; &quot;Pr(ultra high&gt;high)=63%&quot;, &quot;Pr(ultra high&gt;high)=63%&quot;,… ## $ pr_diff_lab_sm &lt;chr&gt; &quot;Pr(&gt;0)=63%&quot;, &quot;Pr(&gt;0)=63%&quot;, &quot;Pr(&gt;0)=63%&quot;, &quot;Pr(&gt;0)=63%… ## $ pr_diff_lab_pos &lt;dbl&gt; 0.1268222, 0.1268222, 0.1268222, 0.1268222, 0.1268222… ## $ sig_level &lt;ord&gt; &lt;80%, &lt;80%, &lt;80%, &lt;80%, &lt;80%, &lt;80%, &lt;80%, &lt;80%, &lt;80%,… plot it plt_contrast( brms_contrast_temp # , caption_text = form_temp , y_axis_title = &quot;quality&quot; , facet = &quot;software&quot; , label_size = 2.0 , x_expand = c(0.56,0.9) # c(0,0.7) ) + labs( subtitle = &quot;posterior predictive distribution of group constrasts with 95% &amp; 50% HDI\\nby software&quot; ) ggplot2::ggsave( &quot;../data/qlty_sftwr_comp_mod5.png&quot; , plot = ggplot2::last_plot() + labs(subtitle = &quot;&quot;) , height = 7, width = 10.5 ) create plot for combining with other contrasts for publication ptchwrk_qlty_sftwr_comp = plt_contrast( brms_contrast_temp , y_axis_title = &quot;quality contrast&quot; , facet = &quot;software&quot; , label_size = 1.35 , label = &quot;pr_diff_lab_sm&quot; , annotate_size = 1.75 ) + labs( subtitle = &quot;&quot; , x = &quot;F-score contrast&quot; ) + theme( legend.position=&quot;none&quot; , axis.title.y = element_text(size = 10, face = &quot;bold&quot;) , axis.title.x = element_text(size = 8) ) # ptchwrk_qlty_sftwr_comp and summarize these contrasts table_temp = brms_contrast_temp %&gt;% dplyr::group_by(contrast, software, pr_gt_zero) %&gt;% tidybayes::median_hdi(value) %&gt;% dplyr::arrange(contrast, software) %&gt;% dplyr::select(contrast, software, value, .lower, .upper, pr_gt_zero) %&gt;% dplyr::arrange(software, contrast) table_temp %&gt;% dplyr::select(-c(software)) %&gt;% kableExtra::kbl( digits = 2 , caption = &quot;brms::brm model: 95% HDI of the posterior predictive distribution of group constrasts&quot; , col.names = c( &quot;quality contrast&quot; , &quot;median difference&lt;br&gt;F-score&quot; , &quot;HDI low&quot;, &quot;HDI high&quot; , &quot;Pr(diff&gt;0)&quot; ) , escape = F ) %&gt;% kableExtra::kable_styling() %&gt;% kableExtra::pack_rows(index = table(forcats::fct_inorder(table_temp$software))) %&gt;% kableExtra::scroll_box(height = &quot;8in&quot;) Table 6.9: brms::brm model: 95% HDI of the posterior predictive distribution of group constrasts quality contrast median differenceF-score HDI low HDI high Pr(diff&gt;0) METASHAPE ultra high - high 0.02 -0.08 0.12 63% ultra high - medium 0.07 -0.03 0.17 92% ultra high - low 0.20 0.10 0.30 100% ultra high - lowest 0.46 0.32 0.57 100% high - medium 0.05 -0.04 0.16 86% high - low 0.18 0.08 0.28 100% high - lowest 0.44 0.30 0.56 100% medium - low 0.13 0.03 0.23 99% medium - lowest 0.38 0.25 0.51 100% low - lowest 0.25 0.13 0.38 100% OPENDRONEMAP ultra high - high 0.08 -0.02 0.18 94% ultra high - medium 0.24 0.14 0.35 100% ultra high - low 0.24 0.14 0.35 100% ultra high - lowest 0.26 0.15 0.36 100% high - medium 0.16 0.06 0.27 100% high - low 0.16 0.06 0.27 100% high - lowest 0.18 0.07 0.28 100% medium - low 0.00 -0.10 0.09 50% medium - lowest 0.01 -0.08 0.12 62% low - lowest 0.01 -0.09 0.11 61% PIX4D ultra high - high 0.01 -0.11 0.12 54% ultra high - medium 0.01 -0.11 0.12 55% ultra high - low 0.07 -0.04 0.19 89% high - medium 0.00 -0.11 0.12 51% high - low 0.07 -0.05 0.18 87% medium - low 0.06 -0.05 0.18 87% The contrasts above address the question “are there differences in F-score based on dense point cloud generation quality within each software?”. To address the different question of “are there differences in F-score based on the processing software used at a given dense point cloud generation quality?” we need to utilize a different formulation of the comparison parameter within our call to the tidybayes::compare_levels function and calculate the contrast by software instead # calculate contrast brms_contrast_temp = qlty_sftwr_draws_temp %&gt;% tidybayes::compare_levels( value , by = software , comparison = &quot;pairwise&quot; ) %&gt;% dplyr::rename(contrast = software) %&gt;% # median_hdi summary for coloring dplyr::group_by(contrast, depth_maps_generation_quality) %&gt;% make_contrast_vars() # remove out-of-sample obs brms_contrast_temp = brms_contrast_temp %&gt;% tidyr::separate_wider_delim( cols = contrast , delim = &quot; - &quot; , names = paste0( &quot;sorter&quot; , 1:(max(stringr::str_count(brms_contrast_temp$contrast, &quot;-&quot;))+1) ) , too_few = &quot;align_start&quot; , cols_remove = F ) %&gt;% dplyr::filter(sorter1!=sorter2) %&gt;% dplyr::inner_join( ptcld_validation_data %&gt;% dplyr::distinct(software, depth_maps_generation_quality) , by = dplyr::join_by(sorter1 == software, depth_maps_generation_quality) ) %&gt;% dplyr::inner_join( ptcld_validation_data %&gt;% dplyr::distinct(software, depth_maps_generation_quality) , by = dplyr::join_by(sorter2 == software, depth_maps_generation_quality) ) what is this contrast data? # what? brms_contrast_temp %&gt;% dplyr::glimpse() ## Rows: 520,000 ## Columns: 19 ## Groups: contrast, depth_maps_generation_quality [13] ## $ depth_maps_generation_quality &lt;ord&gt; ultra high, ultra high, ultra high, ultr… ## $ .chain &lt;int&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, … ## $ .iteration &lt;int&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, … ## $ .draw &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 1… ## $ sorter1 &lt;chr&gt; &quot;OPENDRONEMAP&quot;, &quot;OPENDRONEMAP&quot;, &quot;OPENDRO… ## $ sorter2 &lt;chr&gt; &quot;METASHAPE&quot;, &quot;METASHAPE&quot;, &quot;METASHAPE&quot;, &quot;… ## $ contrast &lt;chr&gt; &quot;OPENDRONEMAP - METASHAPE&quot;, &quot;OPENDRONEMA… ## $ value &lt;dbl&gt; -0.142911054, -0.020900126, -0.056272385… ## $ median_hdi_est &lt;dbl&gt; -0.0244408, -0.0244408, -0.0244408, -0.0… ## $ median_hdi_lower &lt;dbl&gt; -0.1463941, -0.1463941, -0.1463941, -0.1… ## $ median_hdi_upper &lt;dbl&gt; 0.1008942, 0.1008942, 0.1008942, 0.10089… ## $ pr_gt_zero &lt;chr&gt; &quot;34%&quot;, &quot;34%&quot;, &quot;34%&quot;, &quot;34%&quot;, &quot;34%&quot;, &quot;34%&quot;… ## $ pr_lt_zero &lt;chr&gt; &quot;66%&quot;, &quot;66%&quot;, &quot;66%&quot;, &quot;66%&quot;, &quot;66%&quot;, &quot;66%&quot;… ## $ is_diff_dir &lt;lgl&gt; TRUE, TRUE, TRUE, TRUE, FALSE, TRUE, FAL… ## $ pr_diff &lt;dbl&gt; 0.6613, 0.6613, 0.6613, 0.6613, 0.6613, … ## $ pr_diff_lab &lt;chr&gt; &quot;Pr(MtaShp&gt;ODM)=66%&quot;, &quot;Pr(MtaShp&gt;ODM)=66… ## $ pr_diff_lab_sm &lt;chr&gt; &quot;Pr(&lt;0)=66%&quot;, &quot;Pr(&lt;0)=66%&quot;, &quot;Pr(&lt;0)=66%&quot;… ## $ pr_diff_lab_pos &lt;dbl&gt; -0.1573737, -0.1573737, -0.1573737, -0.1… ## $ sig_level &lt;ord&gt; &lt;80%, &lt;80%, &lt;80%, &lt;80%, &lt;80%, &lt;80%, &lt;80%… plot it plt_contrast( brms_contrast_temp # , caption_text = form_temp , y_axis_title = &quot;software&quot; , facet = &quot;depth_maps_generation_quality&quot; , label_size = 2.0 , x_expand = c(0.17,0.14) ) + facet_wrap(facets = vars(depth_maps_generation_quality), ncol = 2) + labs( subtitle = &quot;posterior predictive distribution of group constrasts with 95% &amp; 50% HDI\\nby dense cloud quality&quot; ) + theme( legend.position = c(.75, .13) ) + guides(fill = guide_colorbar(theme = theme( legend.key.width = unit(1, &quot;lines&quot;), legend.key.height = unit(7, &quot;lines&quot;) ))) ggplot2::ggsave( &quot;../data/sftwr_qlty_comp_mod5.png&quot; , plot = ggplot2::last_plot() + labs(subtitle = &quot;&quot;) , height = 7, width = 10.5 ) create plot for combining with other contrasts for publication ptchwrk_sftwr_qlty_comp = plt_contrast( brms_contrast_temp , y_axis_title = &quot;software contrast&quot; , facet = &quot;depth_maps_generation_quality&quot; , label_size = 1.7 , label = &quot;pr_diff_lab_sm&quot; , annotate_size = 1.8 ) + facet_wrap(facets = vars(depth_maps_generation_quality), ncol = 3) + labs( subtitle = &quot;&quot; , x = &quot;F-score constrast&quot; ) + theme( legend.position = &quot;inside&quot; , legend.position.inside = c(.8, .11) , axis.title.y = element_text(size = 10, face = &quot;bold&quot;) , axis.title.x = element_text(size = 8) ) + guides(fill = guide_colorbar(theme = theme( legend.key.width = unit(1, &quot;lines&quot;), legend.key.height = unit(7, &quot;lines&quot;) ))) # ptchwrk_sftwr_qlty_comp and summarize these contrasts table_temp = brms_contrast_temp %&gt;% dplyr::group_by(contrast, depth_maps_generation_quality, pr_gt_zero) %&gt;% tidybayes::median_hdi(value) %&gt;% dplyr::arrange(contrast, depth_maps_generation_quality) %&gt;% dplyr::select(contrast, depth_maps_generation_quality, value, .lower, .upper, pr_gt_zero) table_temp %&gt;% dplyr::select(-c(contrast)) %&gt;% kableExtra::kbl( digits = 2 , caption = &quot;brms::brm model: 95% HDI of the posterior predictive distribution of group constrasts&quot; , col.names = c( &quot;quality&quot; , &quot;median difference&lt;br&gt;F-score&quot; , &quot;HDI low&quot;, &quot;HDI high&quot; , &quot;Pr(diff&gt;0)&quot; ) , escape = F ) %&gt;% kableExtra::kable_styling() %&gt;% kableExtra::pack_rows(index = table(forcats::fct_inorder(table_temp$contrast))) %&gt;% kableExtra::scroll_box(height = &quot;8in&quot;) Table 6.10: brms::brm model: 95% HDI of the posterior predictive distribution of group constrasts quality median differenceF-score HDI low HDI high Pr(diff&gt;0) OPENDRONEMAP - METASHAPE ultra high -0.02 -0.15 0.10 34% high -0.09 -0.22 0.04 8% medium -0.20 -0.33 -0.07 0% low -0.07 -0.19 0.06 13% lowest 0.17 0.05 0.29 100% PIX4D - METASHAPE ultra high -0.06 -0.20 0.07 17% high -0.05 -0.19 0.08 22% medium 0.00 -0.13 0.14 50% low 0.07 -0.07 0.20 83% PIX4D - OPENDRONEMAP ultra high -0.04 -0.18 0.09 29% high 0.03 -0.10 0.17 70% medium 0.20 0.06 0.34 100% low 0.13 0.00 0.27 97% 6.4.2.6 Software:Filtering - interaction Are there differences in F-score based on dense point cloud filtering mode within each processing software? Here, we collapse across the study site and depth map generation quality to compare the combined filtering mode and software effect. In a hierarchical model structure, we have to make use of the re_formula argument within tidybayes::add_epred_draws Even though filtering mode had a small effect on the SfM predictive ability when averaging across all softwares, there might still be differences in filtering mode within software when we average across all depth map generation quality settings. Let’s check the difference in F-score by depth map filtering mode and software. # get draws fltr_sftwr_draws_temp = ptcld_validation_data %&gt;% dplyr::distinct(depth_maps_generation_filtering_mode, software) %&gt;% tidybayes::add_epred_draws( brms_f_mod5, allow_new_levels = T # this part is crucial , re_formula = ~ (1 | depth_maps_generation_filtering_mode) + (1 | software) + (1 | depth_maps_generation_filtering_mode:software) ) %&gt;% dplyr::rename(value = .epred) %&gt;% dplyr::mutate(med = tidybayes::median_hdci(value)$y) # plot fltr_sftwr_draws_temp %&gt;% ggplot( mapping = aes( y = value, x = software # , fill = software , fill = med ) ) + tidybayes::stat_eye( point_interval = median_hdi, .width = .95 , slab_alpha = 0.95 , interval_color = &quot;black&quot;, linewidth = 1 , point_color = &quot;black&quot;, point_fill = &quot;black&quot;, point_size = 1 ) + # scale_fill_viridis_d(option = &quot;rocket&quot;, begin = 0.3, end = 0.9, drop = F) + scale_fill_viridis_c(option = &quot;mako&quot;, direction=-1, begin = 0.2, end = 0.8, limits = c(0,1)) + scale_y_continuous(limits = c(0,1), breaks = scales::extended_breaks(n=8)) + facet_grid(cols = vars(depth_maps_generation_filtering_mode)) + labs( x = &quot;software&quot;, y = &quot;F-score&quot; , subtitle = &quot;posterior predictive distribution of F-score with 95% HDI\\nby filtering mode&quot; # , caption = form_temp ) + theme_light() + theme( legend.position = &quot;none&quot; , legend.direction = &quot;horizontal&quot; , axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1) , strip.text = element_text(color = &quot;black&quot;, face = &quot;bold&quot;) ) and a table of these 95% HDI values table_temp = fltr_sftwr_draws_temp %&gt;% tidybayes::median_hdi(value) %&gt;% dplyr::select(-c(.point,.interval, .width,.row)) %&gt;% dplyr::arrange(software,depth_maps_generation_filtering_mode) table_temp %&gt;% dplyr::select(-c(software)) %&gt;% kableExtra::kbl( digits = 2 , caption = &quot;F-score&lt;br&gt;95% HDI of the posterior predictive distribution&quot; , col.names = c( &quot;filtering mode&quot; , &quot;F-score&lt;br&gt;median&quot; , &quot;HDI low&quot;, &quot;HDI high&quot; ) , escape = F ) %&gt;% kableExtra::kable_styling() %&gt;% kableExtra::pack_rows(index = table(forcats::fct_inorder(table_temp$software))) %&gt;% kableExtra::scroll_box(height = &quot;8in&quot;) Table 6.11: F-score95% HDI of the posterior predictive distribution filtering mode F-scoremedian HDI low HDI high METASHAPE aggressive 0.35 0.14 0.59 moderate 0.43 0.20 0.68 mild 0.51 0.25 0.75 disabled 0.50 0.25 0.75 OPENDRONEMAP aggressive 0.44 0.21 0.70 moderate 0.42 0.19 0.67 mild 0.42 0.19 0.67 disabled 0.41 0.18 0.67 PIX4D moderate 0.46 0.22 0.72 mild 0.49 0.24 0.74 disabled 0.49 0.24 0.74 we can also make pairwise comparisons so long as we continue using tidybayes::add_epred_draws with the re_formula argument # calculate contrast brms_contrast_temp = fltr_sftwr_draws_temp %&gt;% tidybayes::compare_levels( value , by = depth_maps_generation_filtering_mode , comparison = &quot;pairwise&quot; ) %&gt;% dplyr::rename(contrast = depth_maps_generation_filtering_mode) # separate contrast brms_contrast_temp = brms_contrast_temp %&gt;% dplyr::ungroup() %&gt;% tidyr::separate_wider_delim( cols = contrast , delim = &quot; - &quot; , names = paste0( &quot;sorter&quot; , 1:(max(stringr::str_count(brms_contrast_temp$contrast, &quot;-&quot;))+1) ) , too_few = &quot;align_start&quot; , cols_remove = F ) %&gt;% dplyr::filter(sorter1!=sorter2) %&gt;% dplyr::mutate( dplyr::across( tidyselect::starts_with(&quot;sorter&quot;) , .fns = function(x){factor( x, ordered = T , levels = levels(ptcld_validation_data$depth_maps_generation_filtering_mode) )} ) , contrast = contrast %&gt;% forcats::fct_reorder( paste0(as.numeric(sorter1), as.numeric(sorter2)) %&gt;% as.numeric() ) %&gt;% # re order for filtering mode forcats::fct_rev() ) %&gt;% # median_hdi summary for coloring dplyr::group_by(contrast, software) %&gt;% make_contrast_vars() what is this constrast data? # what? brms_contrast_temp %&gt;% dplyr::glimpse() ## Rows: 600,000 ## Columns: 19 ## Groups: contrast, software [15] ## $ software &lt;chr&gt; &quot;METASHAPE&quot;, &quot;METASHAPE&quot;, &quot;METASHAPE&quot;, &quot;METASHAPE&quot;, &quot;… ## $ .chain &lt;int&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N… ## $ .iteration &lt;int&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N… ## $ .draw &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16… ## $ sorter1 &lt;ord&gt; moderate, moderate, moderate, moderate, moderate, mod… ## $ sorter2 &lt;ord&gt; aggressive, aggressive, aggressive, aggressive, aggre… ## $ contrast &lt;fct&gt; moderate - aggressive, moderate - aggressive, moderat… ## $ value &lt;dbl&gt; 0.132672033, 0.139348910, 0.084762144, 0.105346391, 0… ## $ median_hdi_est &lt;dbl&gt; 0.07968804, 0.07968804, 0.07968804, 0.07968804, 0.079… ## $ median_hdi_lower &lt;dbl&gt; -0.004604482, -0.004604482, -0.004604482, -0.00460448… ## $ median_hdi_upper &lt;dbl&gt; 0.1688837, 0.1688837, 0.1688837, 0.1688837, 0.1688837… ## $ pr_gt_zero &lt;chr&gt; &quot;97%&quot;, &quot;97%&quot;, &quot;97%&quot;, &quot;97%&quot;, &quot;97%&quot;, &quot;97%&quot;, &quot;97%&quot;, &quot;97%… ## $ pr_lt_zero &lt;chr&gt; &quot;3%&quot;, &quot;3%&quot;, &quot;3%&quot;, &quot;3%&quot;, &quot;3%&quot;, &quot;3%&quot;, &quot;3%&quot;, &quot;3%&quot;, &quot;3%&quot;,… ## $ is_diff_dir &lt;lgl&gt; TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE,… ## $ pr_diff &lt;dbl&gt; 0.97215, 0.97215, 0.97215, 0.97215, 0.97215, 0.97215,… ## $ pr_diff_lab &lt;chr&gt; &quot;Pr(moderate&gt;aggressive)=97%&quot;, &quot;Pr(moderate&gt;aggressiv… ## $ pr_diff_lab_sm &lt;chr&gt; &quot;Pr(&gt;0)=97%&quot;, &quot;Pr(&gt;0)=97%&quot;, &quot;Pr(&gt;0)=97%&quot;, &quot;Pr(&gt;0)=97%… ## $ pr_diff_lab_pos &lt;dbl&gt; 0.18155, 0.18155, 0.18155, 0.18155, 0.18155, 0.18155,… ## $ sig_level &lt;ord&gt; 95%, 95%, 95%, 95%, 95%, 95%, 95%, 95%, 95%, 95%, 95%… plot it plt_contrast( brms_contrast_temp # , caption_text = form_temp , y_axis_title = &quot;filtering mode&quot; , facet = &quot;software&quot; , label_size = 2.0 , x_expand = c(1.8,1.8) # c(1,1.4) ) + labs( subtitle = &quot;posterior predictive distribution of group constrasts with 95% &amp; 50% HDI\\nby software&quot; ) ggplot2::ggsave( &quot;../data/fltr_sftwr_comp_mod5.png&quot; , plot = ggplot2::last_plot() + labs(subtitle = &quot;&quot;) , height = 7, width = 10.5 ) create plot for combining with other RMSE contrasts for publication ptchwrk_fltr_sftwr_comp = plt_contrast( brms_contrast_temp , y_axis_title = &quot;filtering mode contrast&quot; , facet = &quot;software&quot; , label_size = 1.7 , label = &quot;pr_diff_lab_sm&quot; , annotate_size = 1.8 ) + labs( subtitle = &quot;&quot; # &quot;constrast Height RMSE (m)&quot; , x = &quot;F-score constrast&quot; ) + theme( legend.position=&quot;none&quot; , axis.title.y = element_text(size = 10, face = &quot;bold&quot;) , axis.title.x = element_text(size = 8) ) # ptchwrk_fltr_sftwr_comp and summarize these contrasts table_temp = brms_contrast_temp %&gt;% dplyr::group_by(contrast, software, pr_gt_zero) %&gt;% tidybayes::median_hdi(value) %&gt;% dplyr::arrange(contrast, software) %&gt;% dplyr::select(contrast, software, value, .lower, .upper, pr_gt_zero) %&gt;% dplyr::arrange(software, contrast) table_temp %&gt;% dplyr::select(-c(software)) %&gt;% kableExtra::kbl( digits = 2 , caption = &quot;brms::brm model: 95% HDI of the posterior predictive distribution of group constrasts&quot; , col.names = c( &quot;filtering contrast&quot; , &quot;median difference&lt;br&gt;F-score&quot; , &quot;HDI low&quot;, &quot;HDI high&quot; , &quot;Pr(diff&gt;0)&quot; ) , escape = F ) %&gt;% kableExtra::kable_styling() %&gt;% kableExtra::pack_rows(index = table(forcats::fct_inorder(table_temp$software))) %&gt;% kableExtra::scroll_box(height = &quot;8in&quot;) Table 6.12: brms::brm model: 95% HDI of the posterior predictive distribution of group constrasts filtering contrast median differenceF-score HDI low HDI high Pr(diff&gt;0) METASHAPE disabled - mild -0.01 -0.09 0.08 44% disabled - moderate 0.06 -0.02 0.15 94% disabled - aggressive 0.15 0.05 0.25 100% mild - moderate 0.07 -0.02 0.16 95% mild - aggressive 0.15 0.05 0.26 100% moderate - aggressive 0.08 0.00 0.17 97% OPENDRONEMAP disabled - mild -0.01 -0.09 0.07 44% disabled - moderate -0.01 -0.09 0.08 45% disabled - aggressive -0.03 -0.12 0.06 26% mild - moderate 0.00 -0.08 0.08 51% mild - aggressive -0.02 -0.11 0.07 31% moderate - aggressive -0.02 -0.11 0.06 30% PIX4D disabled - mild 0.00 -0.09 0.09 49% disabled - moderate 0.03 -0.05 0.13 78% mild - moderate 0.04 -0.05 0.13 79% 6.4.2.7 Software:Quality:Filtering - interaction The contrasts immediately above address the question “are there differences in F-score based on dense point cloud filtering mode within each software?”. Although the impact of filtering mode is small, it is highly probable when averaging across all quality settings. What if we don’t average out the impact of quality and instead get the full, three-way interaction between software, quality, and filtering mode? Let’s get the model’s answer to the question “For each software, are there differences in F-score based on dense point cloud filtering mode within each point cloud generation quality?”. Here, we collapse across the study site to compare the dense cloud quality, filtering mode, and software effect. In a hierarchical model structure, we have to make use of the re_formula argument within tidybayes::add_epred_draws # get draws fltr_sftwr_draws_temp = tidyr::crossing( depth_maps_generation_quality = unique(ptcld_validation_data$depth_maps_generation_quality) , depth_maps_generation_filtering_mode = unique(ptcld_validation_data$depth_maps_generation_filtering_mode) , software = unique(ptcld_validation_data$software) ) %&gt;% tidybayes::add_epred_draws( brms_f_mod5, allow_new_levels = T # this part is crucial , re_formula = ~ (1 | depth_maps_generation_quality) + # main effects (1 | depth_maps_generation_quality) + (1 | depth_maps_generation_filtering_mode) + (1 | software) + # two-way interactions (1 | depth_maps_generation_quality:depth_maps_generation_filtering_mode) + (1 | depth_maps_generation_quality:software) + (1 | depth_maps_generation_filtering_mode:software) + # three-way interactions (1 | depth_maps_generation_quality:depth_maps_generation_filtering_mode:software) ) %&gt;% dplyr::rename(value = .epred) %&gt;% dplyr::mutate(med = tidybayes::median_hdci(value)$y) # let&#39;s add the grand mean to the plot for reference grand_mean_temp = brms::posterior_summary(brms_f_mod5) %&gt;% as.data.frame() %&gt;% tibble::rownames_to_column(var = &quot;parameter&quot;) %&gt;% dplyr::rename_with(tolower) %&gt;% dplyr::filter( parameter == &quot;Intercept&quot; ) %&gt;% dplyr::mutate(dplyr::across(-c(parameter), ~plogis(.))) %&gt;% dplyr::pull(estimate) # plot fltr_sftwr_draws_temp %&gt;% dplyr::inner_join( ptcld_validation_data %&gt;% dplyr::distinct(software, depth_maps_generation_quality, depth_maps_generation_filtering_mode) , by = dplyr::join_by(software, depth_maps_generation_quality, depth_maps_generation_filtering_mode) ) %&gt;% dplyr::mutate(depth_maps_generation_quality = depth_maps_generation_quality %&gt;% forcats::fct_rev()) %&gt;% ggplot( mapping = aes( y = value , x = depth_maps_generation_filtering_mode # , fill = depth_maps_generation_filtering_mode , fill = med ) ) + geom_hline(yintercept = grand_mean_temp, color = &quot;gray33&quot;) + tidybayes::stat_eye( point_interval = median_hdi, .width = .95 , slab_alpha = 0.95 , interval_color = &quot;black&quot;, linewidth = 1 , point_color = &quot;black&quot;, point_fill = &quot;black&quot;, point_size = 1 ) + # scale_fill_viridis_d(option = &quot;plasma&quot;, drop = F) + scale_fill_viridis_c(option = &quot;mako&quot;, direction=-1, begin = 0.2, end = 0.8, limits = c(0,1)) + scale_y_continuous(limits = c(0,1), breaks = scales::extended_breaks(n=8)) + facet_grid( rows = vars(software) , cols = vars(depth_maps_generation_quality) # , switch = &quot;y&quot; ) + labs( fill = &quot;&quot; , x = &quot;filtering mode&quot;, y = &quot;F-score&quot; # , subtitle = &quot;posterior predictive distribution of F-score with 95% HDI\\nby dense cloud quality and software&quot; , subtitle = &quot;quality&quot; # , caption = form_temp ) + theme_light() + theme( legend.position = &quot;none&quot; , legend.direction = &quot;horizontal&quot; , axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1) , strip.text = element_text(color = &quot;black&quot;, face = &quot;bold&quot;) , plot.subtitle = element_text(hjust = 0.5) , panel.grid = element_blank() # , strip.placement = &quot;outside&quot; ) + guides( fill = guide_legend(override.aes = list(shape = NA, size = 6, alpha = 0.9, lwd = NA)) ) ggplot2::ggsave( &quot;../data/qlty_fltr_sftwr_mod5.png&quot; , plot = ggplot2::last_plot() + labs(subtitle = &quot;&quot;) , height = 7, width = 10.5 ) let’s add a table of the results table_temp = fltr_sftwr_draws_temp %&gt;% tidybayes::median_hdi(value) %&gt;% dplyr::inner_join( ptcld_validation_data %&gt;% dplyr::distinct(software, depth_maps_generation_quality, depth_maps_generation_filtering_mode) , by = dplyr::join_by(software, depth_maps_generation_quality, depth_maps_generation_filtering_mode) ) %&gt;% dplyr::mutate(depth_maps_generation_quality = depth_maps_generation_quality %&gt;% forcats::fct_rev()) %&gt;% dplyr::select(c( software, depth_maps_generation_quality, depth_maps_generation_filtering_mode , value, .lower, .upper )) %&gt;% dplyr::ungroup() %&gt;% dplyr::arrange(software, depth_maps_generation_quality, depth_maps_generation_filtering_mode) table_temp %&gt;% # dplyr::select(-c(software)) %&gt;% kableExtra::kbl( digits = 2 , caption = &quot;brms::brm model: 95% HDI of the posterior predictive distribution&quot; , col.names = c( &quot;software&quot;, &quot;quality&quot;, &quot;filtering mode&quot; , &quot;F-score&lt;br&gt;median&quot; , &quot;HDI low&quot;, &quot;HDI high&quot; ) , escape = F ) %&gt;% kableExtra::kable_styling() %&gt;% # kableExtra::pack_rows(index = table(forcats::fct_inorder(table_temp$software))) %&gt;% kableExtra::collapse_rows(columns = 1:2, valign = &quot;top&quot;) %&gt;% kableExtra::scroll_box(height = &quot;8in&quot;) Table 6.13: brms::brm model: 95% HDI of the posterior predictive distribution software quality filtering mode F-scoremedian HDI low HDI high METASHAPE lowest aggressive 0.09 0.03 0.19 moderate 0.13 0.04 0.25 mild 0.18 0.07 0.34 disabled 0.18 0.07 0.34 low aggressive 0.30 0.13 0.49 moderate 0.38 0.20 0.60 mild 0.47 0.26 0.68 disabled 0.46 0.25 0.68 medium aggressive 0.43 0.23 0.65 moderate 0.52 0.31 0.73 mild 0.60 0.39 0.80 disabled 0.59 0.38 0.79 high aggressive 0.49 0.28 0.71 moderate 0.58 0.38 0.79 mild 0.65 0.45 0.84 disabled 0.64 0.44 0.83 ultra high aggressive 0.52 0.31 0.74 moderate 0.60 0.39 0.80 mild 0.66 0.46 0.84 disabled 0.66 0.45 0.84 OPENDRONEMAP lowest aggressive 0.32 0.15 0.53 moderate 0.30 0.14 0.51 mild 0.31 0.14 0.51 disabled 0.31 0.14 0.51 low aggressive 0.34 0.16 0.55 moderate 0.32 0.15 0.52 mild 0.33 0.15 0.53 disabled 0.32 0.15 0.52 medium aggressive 0.34 0.17 0.56 moderate 0.32 0.15 0.53 mild 0.32 0.15 0.52 disabled 0.31 0.14 0.52 high aggressive 0.52 0.31 0.73 moderate 0.49 0.28 0.71 mild 0.49 0.28 0.70 disabled 0.48 0.28 0.70 ultra high aggressive 0.60 0.40 0.80 moderate 0.58 0.37 0.78 mild 0.57 0.36 0.78 disabled 0.56 0.35 0.77 PIX4D low moderate 0.45 0.24 0.67 mild 0.50 0.28 0.71 disabled 0.50 0.29 0.72 medium moderate 0.53 0.31 0.74 mild 0.56 0.35 0.77 disabled 0.56 0.35 0.77 high moderate 0.53 0.32 0.74 mild 0.56 0.35 0.77 disabled 0.56 0.36 0.78 ultra high moderate 0.54 0.32 0.75 mild 0.57 0.36 0.77 disabled 0.56 0.35 0.77 we can also make pairwise comparisons so long as we continue using tidybayes::add_epred_draws with the re_formula argument # calculate contrast brms_contrast_temp = fltr_sftwr_draws_temp %&gt;% tidybayes::compare_levels( value , by = depth_maps_generation_filtering_mode , comparison = &quot;pairwise&quot; ) %&gt;% dplyr::rename(contrast = depth_maps_generation_filtering_mode) # separate contrast brms_contrast_temp = brms_contrast_temp %&gt;% dplyr::ungroup() %&gt;% tidyr::separate_wider_delim( cols = contrast , delim = &quot; - &quot; , names = paste0( &quot;sorter&quot; , 1:(max(stringr::str_count(brms_contrast_temp$contrast, &quot;-&quot;))+1) ) , too_few = &quot;align_start&quot; , cols_remove = F ) %&gt;% dplyr::filter(sorter1!=sorter2) %&gt;% dplyr::mutate( dplyr::across( tidyselect::starts_with(&quot;sorter&quot;) , .fns = function(x){factor( x, ordered = T , levels = levels(ptcld_validation_data$depth_maps_generation_filtering_mode) )} ) , contrast = contrast %&gt;% forcats::fct_reorder( paste0(as.numeric(sorter1), as.numeric(sorter2)) %&gt;% as.numeric() ) %&gt;% # re order for filtering mode forcats::fct_rev() ) %&gt;% # median_hdi summary for coloring dplyr::group_by(contrast, software, depth_maps_generation_quality) %&gt;% make_contrast_vars() # remove out-of-sample obs brms_contrast_temp = brms_contrast_temp %&gt;% dplyr::inner_join( ptcld_validation_data %&gt;% dplyr::distinct(software, depth_maps_generation_quality, depth_maps_generation_filtering_mode) , by = dplyr::join_by(software, depth_maps_generation_quality, sorter1==depth_maps_generation_filtering_mode) ) %&gt;% dplyr::inner_join( ptcld_validation_data %&gt;% dplyr::distinct(software, depth_maps_generation_quality, depth_maps_generation_filtering_mode) , by = dplyr::join_by(software, depth_maps_generation_quality, sorter2==depth_maps_generation_filtering_mode) ) %&gt;% dplyr::mutate(depth_maps_generation_quality = depth_maps_generation_quality %&gt;% forcats::fct_rev()) # what? brms_contrast_temp %&gt;% dplyr::glimpse() ## Rows: 2,880,000 ## Columns: 20 ## Groups: contrast, software, depth_maps_generation_quality [72] ## $ depth_maps_generation_quality &lt;ord&gt; ultra high, ultra high, ultra high, ultr… ## $ software &lt;chr&gt; &quot;METASHAPE&quot;, &quot;METASHAPE&quot;, &quot;METASHAPE&quot;, &quot;… ## $ .chain &lt;int&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, … ## $ .iteration &lt;int&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, … ## $ .draw &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 1… ## $ sorter1 &lt;ord&gt; moderate, moderate, moderate, moderate, … ## $ sorter2 &lt;ord&gt; aggressive, aggressive, aggressive, aggr… ## $ contrast &lt;fct&gt; moderate - aggressive, moderate - aggres… ## $ value &lt;dbl&gt; -0.002393165, 0.133903077, 0.109068878, … ## $ median_hdi_est &lt;dbl&gt; 0.08350163, 0.08350163, 0.08350163, 0.08… ## $ median_hdi_lower &lt;dbl&gt; -0.01846083, -0.01846083, -0.01846083, -… ## $ median_hdi_upper &lt;dbl&gt; 0.1871318, 0.1871318, 0.1871318, 0.18713… ## $ pr_gt_zero &lt;chr&gt; &quot;95%&quot;, &quot;95%&quot;, &quot;95%&quot;, &quot;95%&quot;, &quot;95%&quot;, &quot;95%&quot;… ## $ pr_lt_zero &lt;chr&gt; &quot;5%&quot;, &quot;5%&quot;, &quot;5%&quot;, &quot;5%&quot;, &quot;5%&quot;, &quot;5%&quot;, &quot;5%&quot;… ## $ is_diff_dir &lt;lgl&gt; FALSE, TRUE, TRUE, TRUE, TRUE, TRUE, TRU… ## $ pr_diff &lt;dbl&gt; 0.946275, 0.946275, 0.946275, 0.946275, … ## $ pr_diff_lab &lt;chr&gt; &quot;Pr(moderate&gt;aggressive)=95%&quot;, &quot;Pr(moder… ## $ pr_diff_lab_sm &lt;chr&gt; &quot;Pr(&gt;0)=95%&quot;, &quot;Pr(&gt;0)=95%&quot;, &quot;Pr(&gt;0)=95%&quot;… ## $ pr_diff_lab_pos &lt;dbl&gt; 0.2011667, 0.2011667, 0.2011667, 0.20116… ## $ sig_level &lt;ord&gt; 90%, 90%, 90%, 90%, 90%, 90%, 90%, 90%, … plot it brms_contrast_temp %&gt;% plt_contrast( facet = c(&quot;depth_maps_generation_quality&quot;, &quot;software&quot;) , y_axis_title = &quot;filtering mode&quot; , label_size = 0 , x_expand = c(-0.1,-0.1) ) + facet_grid( rows = vars(software) , cols = vars(depth_maps_generation_quality) ) + labs( subtitle = &quot;posterior predictive distribution of group constrasts with 95% &amp; 50% HDI\\nby dense cloud quality and software&quot; ) ggplot2::ggsave( &quot;../data/qlty_fltr_sftwr_comp_mod5.png&quot; , plot = ggplot2::last_plot() + labs(subtitle = &quot;&quot;) , height = 7, width = 10.5 ) 6.4.2.8 Quality - main effect let’s collapse across the filtering mode, software, and study site to compare the dense cloud quality setting effect. In a hierarchical model structure, we have to make use of the re_formula argument within tidybayes::add_epred_draws ptcld_validation_data %&gt;% dplyr::distinct(depth_maps_generation_quality) %&gt;% tidybayes::add_epred_draws( brms_f_mod5 # this part is crucial , re_formula = ~ (1 | depth_maps_generation_quality) ) %&gt;% dplyr::rename(value = .epred) %&gt;% dplyr::mutate(med = tidybayes::median_hdci(value)$y) %&gt;% # plot ggplot( mapping = aes( x = value, y = depth_maps_generation_quality # , fill = depth_maps_generation_quality , fill = med ) ) + tidybayes::stat_halfeye( point_interval = median_hdi, .width = .95 , interval_color = &quot;gray66&quot; , shape = 21, point_color = &quot;gray66&quot;, point_fill = &quot;black&quot; , justification = -0.01 ) + # scale_fill_viridis_d(option = &quot;inferno&quot;, drop = F) + scale_fill_viridis_c(option = &quot;mako&quot;, direction=-1, begin = 0.2, end = 0.8, limits = c(0,1)) + scale_x_continuous(limits = c(0,1), breaks = scales::extended_breaks(n=8)) + # scale_x_continuous(breaks = scales::extended_breaks(n=8)) + labs( y = &quot;quality&quot;, x = &quot;F-score&quot; , subtitle = &quot;posterior predictive distribution of F-score with 95% HDI&quot; # , caption = form_temp ) + theme_light() + theme(legend.position = &quot;none&quot;) we can also perform pairwise comparisons after collapsing across the filtering mode, software, and study site to compare the dense cloud quality setting effect brms_contrast_temp = ptcld_validation_data %&gt;% dplyr::distinct(depth_maps_generation_quality) %&gt;% tidybayes::add_epred_draws( brms_f_mod5, allow_new_levels = T # this part is crucial , re_formula = ~ (1 | depth_maps_generation_quality) ) %&gt;% dplyr::rename(value = .epred) %&gt;% tidybayes::compare_levels( value , by = depth_maps_generation_quality , comparison = contrast_list # tidybayes::emmeans_comparison(&quot;revpairwise&quot;) #&quot;pairwise&quot; ) %&gt;% dplyr::rename(contrast = depth_maps_generation_quality) # separate contrast brms_contrast_temp = brms_contrast_temp %&gt;% dplyr::ungroup() %&gt;% tidyr::separate_wider_delim( cols = contrast , delim = &quot; - &quot; , names = paste0( &quot;sorter&quot; , 1:(max(stringr::str_count(brms_contrast_temp$contrast, &quot;-&quot;))+1) ) , too_few = &quot;align_start&quot; , cols_remove = F ) %&gt;% dplyr::filter(sorter1!=sorter2) %&gt;% dplyr::mutate( dplyr::across( tidyselect::starts_with(&quot;sorter&quot;) , .fns = function(x){factor( x, ordered = T , levels = levels(ptcld_validation_data$depth_maps_generation_quality) )} ) , contrast = contrast %&gt;% forcats::fct_reorder( paste0(as.numeric(sorter1), as.numeric(sorter2)) %&gt;% as.numeric() ) ) %&gt;% # median_hdi summary for coloring dplyr::group_by(contrast) %&gt;% make_contrast_vars() # what? brms_contrast_temp %&gt;% dplyr::glimpse() ## Rows: 400,000 ## Columns: 18 ## Groups: contrast [10] ## $ .chain &lt;int&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N… ## $ .iteration &lt;int&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N… ## $ .draw &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16… ## $ sorter1 &lt;ord&gt; ultra high, ultra high, ultra high, ultra high, ultra… ## $ sorter2 &lt;ord&gt; high, high, high, high, high, high, high, high, high,… ## $ contrast &lt;fct&gt; ultra high - high, ultra high - high, ultra high - hi… ## $ value &lt;dbl&gt; 0.068046752, -0.006442012, 0.044209582, -0.020760847,… ## $ median_hdi_est &lt;dbl&gt; 0.02135537, 0.02135537, 0.02135537, 0.02135537, 0.021… ## $ median_hdi_lower &lt;dbl&gt; -0.153334, -0.153334, -0.153334, -0.153334, -0.153334… ## $ median_hdi_upper &lt;dbl&gt; 0.1938218, 0.1938218, 0.1938218, 0.1938218, 0.1938218… ## $ pr_gt_zero &lt;chr&gt; &quot;61%&quot;, &quot;61%&quot;, &quot;61%&quot;, &quot;61%&quot;, &quot;61%&quot;, &quot;61%&quot;, &quot;61%&quot;, &quot;61%… ## $ pr_lt_zero &lt;chr&gt; &quot;39%&quot;, &quot;39%&quot;, &quot;39%&quot;, &quot;39%&quot;, &quot;39%&quot;, &quot;39%&quot;, &quot;39%&quot;, &quot;39%… ## $ is_diff_dir &lt;lgl&gt; TRUE, FALSE, TRUE, FALSE, TRUE, TRUE, TRUE, TRUE, TRU… ## $ pr_diff &lt;dbl&gt; 0.612875, 0.612875, 0.612875, 0.612875, 0.612875, 0.6… ## $ pr_diff_lab &lt;chr&gt; &quot;Pr(ultra high&gt;high)=61%&quot;, &quot;Pr(ultra high&gt;high)=61%&quot;,… ## $ pr_diff_lab_sm &lt;chr&gt; &quot;Pr(&gt;0)=61%&quot;, &quot;Pr(&gt;0)=61%&quot;, &quot;Pr(&gt;0)=61%&quot;, &quot;Pr(&gt;0)=61%… ## $ pr_diff_lab_pos &lt;dbl&gt; 0.2083584, 0.2083584, 0.2083584, 0.2083584, 0.2083584… ## $ sig_level &lt;ord&gt; &lt;80%, &lt;80%, &lt;80%, &lt;80%, &lt;80%, &lt;80%, &lt;80%, &lt;80%, &lt;80%,… plot it plt_contrast( brms_contrast_temp # , caption_text = form_temp , y_axis_title = &quot;quality&quot; ) and summarize these contrasts brms_contrast_temp %&gt;% dplyr::group_by(contrast, pr_gt_zero) %&gt;% tidybayes::median_hdi(value) %&gt;% dplyr::arrange(contrast) %&gt;% dplyr::select(contrast, value, .lower, .upper, pr_gt_zero) %&gt;% kableExtra::kbl( digits = 2 , caption = &quot;brms::brm model: 95% HDI of the posterior predictive distribution of group constrasts&quot; , col.names = c( &quot;quality contrast&quot; , &quot;difference (F-score)&quot; , &quot;HDI low&quot;, &quot;HDI high&quot; , &quot;Pr(diff&gt;0)&quot; ) ) %&gt;% kableExtra::kable_styling() Table 6.14: brms::brm model: 95% HDI of the posterior predictive distribution of group constrasts quality contrast difference (F-score) HDI low HDI high Pr(diff&gt;0) ultra high - high 0.02 -0.15 0.19 61% ultra high - medium 0.08 -0.09 0.26 82% ultra high - low 0.13 -0.06 0.31 91% ultra high - lowest 0.26 -0.01 0.46 96% high - medium 0.05 -0.12 0.24 74% high - low 0.10 -0.07 0.29 87% high - lowest 0.23 -0.02 0.43 96% medium - low 0.04 -0.12 0.22 71% medium - lowest 0.17 -0.04 0.37 93% low - lowest 0.12 -0.07 0.31 89% 6.4.2.9 Filtering - main effect let’s collapse across the dense cloud quality, software, and study site to compare the dense cloud quality setting effect. In a hierarchical model structure, we have to make use of the re_formula argument within tidybayes::add_epred_draws ptcld_validation_data %&gt;% dplyr::distinct(depth_maps_generation_filtering_mode) %&gt;% tidybayes::add_epred_draws( brms_f_mod5 # this part is crucial , re_formula = ~ (1 | depth_maps_generation_filtering_mode) ) %&gt;% dplyr::rename(value = .epred) %&gt;% dplyr::mutate(med = tidybayes::median_hdci(value)$y) %&gt;% # plot ggplot( mapping = aes( x = value, y = depth_maps_generation_filtering_mode # , fill = depth_maps_generation_filtering_mode , fill = med ) ) + tidybayes::stat_halfeye( point_interval = median_hdi, .width = .95 , interval_color = &quot;gray66&quot; , shape = 21, point_color = &quot;gray66&quot;, point_fill = &quot;black&quot; , justification = -0.01 ) + # scale_fill_viridis_d(option = &quot;plasma&quot;, drop = F) + scale_fill_viridis_c(option = &quot;mako&quot;, direction=-1, begin = 0.2, end = 0.8, limits = c(0,1)) + scale_x_continuous(limits = c(0,1), breaks = scales::extended_breaks(n=8)) + labs( y = &quot;filtering mode&quot;, x = &quot;F-score&quot; , subtitle = &quot;posterior predictive distribution of F-score with 95% HDI&quot; # , caption = form_temp ) + theme_light() + theme(legend.position = &quot;none&quot;) we can also perform pairwise comparisons after collapsing across the dense cloud quality, software, and study site to compare the filtering mode setting effect. brms_contrast_temp = ptcld_validation_data %&gt;% dplyr::distinct(depth_maps_generation_filtering_mode) %&gt;% tidybayes::add_epred_draws( brms_f_mod5, allow_new_levels = T # this part is crucial , re_formula = ~ (1 | depth_maps_generation_filtering_mode) ) %&gt;% dplyr::rename(value = .epred) %&gt;% tidybayes::compare_levels( value , by = depth_maps_generation_filtering_mode , comparison = &quot;pairwise&quot; ) %&gt;% dplyr::rename(contrast = depth_maps_generation_filtering_mode) # separate contrast brms_contrast_temp = brms_contrast_temp %&gt;% dplyr::ungroup() %&gt;% tidyr::separate_wider_delim( cols = contrast , delim = &quot; - &quot; , names = paste0( &quot;sorter&quot; , 1:(max(stringr::str_count(brms_contrast_temp$contrast, &quot;-&quot;))+1) ) , too_few = &quot;align_start&quot; , cols_remove = F ) %&gt;% dplyr::filter(sorter1!=sorter2) %&gt;% dplyr::mutate( dplyr::across( tidyselect::starts_with(&quot;sorter&quot;) , .fns = function(x){factor( x, ordered = T , levels = levels(ptcld_validation_data$depth_maps_generation_filtering_mode) )} ) , contrast = contrast %&gt;% forcats::fct_reorder( paste0(as.numeric(sorter1), as.numeric(sorter2)) %&gt;% as.numeric() ) %&gt;% # re order for filtering mode forcats::fct_rev() ) %&gt;% # median_hdi summary for coloring dplyr::group_by(contrast) %&gt;% make_contrast_vars() # what? brms_contrast_temp %&gt;% dplyr::glimpse() ## Rows: 240,000 ## Columns: 18 ## Groups: contrast [6] ## $ .chain &lt;int&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N… ## $ .iteration &lt;int&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N… ## $ .draw &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16… ## $ sorter1 &lt;ord&gt; moderate, moderate, moderate, moderate, moderate, mod… ## $ sorter2 &lt;ord&gt; aggressive, aggressive, aggressive, aggressive, aggre… ## $ contrast &lt;fct&gt; moderate - aggressive, moderate - aggressive, moderat… ## $ value &lt;dbl&gt; 0.0394275712, 0.0706529336, -0.0512250680, 0.00390565… ## $ median_hdi_est &lt;dbl&gt; 0.007269812, 0.007269812, 0.007269812, 0.007269812, 0… ## $ median_hdi_lower &lt;dbl&gt; -0.07146747, -0.07146747, -0.07146747, -0.07146747, -… ## $ median_hdi_upper &lt;dbl&gt; 0.1126929, 0.1126929, 0.1126929, 0.1126929, 0.1126929… ## $ pr_gt_zero &lt;chr&gt; &quot;62%&quot;, &quot;62%&quot;, &quot;62%&quot;, &quot;62%&quot;, &quot;62%&quot;, &quot;62%&quot;, &quot;62%&quot;, &quot;62%… ## $ pr_lt_zero &lt;chr&gt; &quot;38%&quot;, &quot;38%&quot;, &quot;38%&quot;, &quot;38%&quot;, &quot;38%&quot;, &quot;38%&quot;, &quot;38%&quot;, &quot;38%… ## $ is_diff_dir &lt;lgl&gt; TRUE, TRUE, FALSE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE… ## $ pr_diff &lt;dbl&gt; 0.62465, 0.62465, 0.62465, 0.62465, 0.62465, 0.62465,… ## $ pr_diff_lab &lt;chr&gt; &quot;Pr(moderate&gt;aggressive)=62%&quot;, &quot;Pr(moderate&gt;aggressiv… ## $ pr_diff_lab_sm &lt;chr&gt; &quot;Pr(&gt;0)=62%&quot;, &quot;Pr(&gt;0)=62%&quot;, &quot;Pr(&gt;0)=62%&quot;, &quot;Pr(&gt;0)=62%… ## $ pr_diff_lab_pos &lt;dbl&gt; 0.1211449, 0.1211449, 0.1211449, 0.1211449, 0.1211449… ## $ sig_level &lt;ord&gt; &lt;80%, &lt;80%, &lt;80%, &lt;80%, &lt;80%, &lt;80%, &lt;80%, &lt;80%, &lt;80%,… plot it plt_contrast( brms_contrast_temp # , caption_text = form_temp , y_axis_title = &quot;filtering mode&quot; ) and summarize these contrasts brms_contrast_temp %&gt;% dplyr::group_by(contrast, pr_gt_zero) %&gt;% tidybayes::median_hdi(value) %&gt;% dplyr::arrange(contrast) %&gt;% dplyr::select(contrast, value, .lower, .upper, pr_gt_zero) %&gt;% kableExtra::kbl( digits = 2 , caption = &quot;brms::brm model: 95% HDI of the posterior predictive distribution of group constrasts&quot; , col.names = c( &quot;filtering mode contrast&quot; , &quot;difference (F-score)&quot; , &quot;HDI low&quot;, &quot;HDI high&quot; , &quot;Pr(diff&gt;0)&quot; ) ) %&gt;% kableExtra::kable_styling() Table 6.15: brms::brm model: 95% HDI of the posterior predictive distribution of group constrasts filtering mode contrast difference (F-score) HDI low HDI high Pr(diff&gt;0) disabled - mild 0.00 -0.10 -0.09 47% disabled - mild 0.00 -0.09 0.08 47% disabled - moderate 0.01 -0.06 0.11 66% disabled - aggressive 0.02 -0.06 -0.05 74% disabled - aggressive 0.02 -0.05 0.14 74% mild - moderate 0.01 -0.06 -0.06 68% mild - moderate 0.01 -0.06 0.11 68% mild - moderate 0.01 0.12 0.12 68% mild - aggressive 0.02 -0.05 0.14 76% mild - aggressive 0.02 0.15 0.15 76% moderate - aggressive 0.01 -0.07 -0.07 62% moderate - aggressive 0.01 -0.07 0.11 62% 6.4.2.10 Software - main effect to address one of our main questions, let’s also collapse across the study site, dense cloud quality, and filtering mode setting to compare the software effect. In a hierarchical model structure, we have to make use of the re_formula argument within tidybayes::add_epred_draws ptcld_validation_data %&gt;% dplyr::distinct(software) %&gt;% tidybayes::add_epred_draws( brms_f_mod5 # this part is crucial , re_formula = ~ (1 | software) ) %&gt;% dplyr::rename(value = .epred) %&gt;% dplyr::mutate(med = tidybayes::median_hdci(value)$y) %&gt;% # plot ggplot( mapping = aes( x = value, y = software # , fill = software , fill = med ) ) + tidybayes::stat_halfeye( point_interval = median_hdi, .width = .95 , interval_color = &quot;gray66&quot; , shape = 21, point_color = &quot;gray66&quot;, point_fill = &quot;black&quot; , justification = -0.01 ) + # scale_fill_viridis_d(option = &quot;rocket&quot;, begin = 0.3, end = 0.9, drop = F) + scale_fill_viridis_c(option = &quot;mako&quot;, direction=-1, begin = 0.2, end = 0.8, limits = c(0,1)) + scale_x_continuous(limits = c(0,1), breaks = scales::extended_breaks(n=8)) + labs( y = &quot;software&quot;, x = &quot;F-score&quot; , subtitle = &quot;posterior predictive distribution of F-score with 95% HDI&quot; # , caption = form_temp ) + theme_light() + theme(legend.position = &quot;none&quot;) we can also perform pairwise comparisons after collapsing across the filtering mode, dense cloud quality setting, and study site to compare the software main effect brms_contrast_temp = ptcld_validation_data %&gt;% dplyr::distinct(software) %&gt;% tidybayes::add_epred_draws( brms_f_mod5, allow_new_levels = T # this part is crucial , re_formula = ~ (1 | software) ) %&gt;% dplyr::rename(value = .epred) %&gt;% tidybayes::compare_levels( value , by = software , comparison = &quot;pairwise&quot; ) %&gt;% dplyr::rename(contrast = software) %&gt;% # median_hdi summary for coloring dplyr::group_by(contrast) %&gt;% make_contrast_vars() # what? brms_contrast_temp %&gt;% dplyr::glimpse() ## Rows: 120,000 ## Columns: 16 ## Groups: contrast [3] ## $ .chain &lt;int&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N… ## $ .iteration &lt;int&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N… ## $ .draw &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16… ## $ contrast &lt;chr&gt; &quot;OPENDRONEMAP - METASHAPE&quot;, &quot;OPENDRONEMAP - METASHAPE… ## $ value &lt;dbl&gt; 3.895523e-02, -1.090878e-01, -2.264508e-02, 4.896502e… ## $ median_hdi_est &lt;dbl&gt; -0.008625779, -0.008625779, -0.008625779, -0.00862577… ## $ median_hdi_lower &lt;dbl&gt; -0.1641601, -0.1641601, -0.1641601, -0.1641601, -0.16… ## $ median_hdi_upper &lt;dbl&gt; 0.1155234, 0.1155234, 0.1155234, 0.1155234, 0.1155234… ## $ pr_gt_zero &lt;chr&gt; &quot;40%&quot;, &quot;40%&quot;, &quot;40%&quot;, &quot;40%&quot;, &quot;40%&quot;, &quot;40%&quot;, &quot;40%&quot;, &quot;40%… ## $ pr_lt_zero &lt;chr&gt; &quot;60%&quot;, &quot;60%&quot;, &quot;60%&quot;, &quot;60%&quot;, &quot;60%&quot;, &quot;60%&quot;, &quot;60%&quot;, &quot;60%… ## $ is_diff_dir &lt;lgl&gt; FALSE, TRUE, TRUE, FALSE, FALSE, TRUE, TRUE, TRUE, TR… ## $ pr_diff &lt;dbl&gt; 0.598325, 0.598325, 0.598325, 0.598325, 0.598325, 0.5… ## $ pr_diff_lab &lt;chr&gt; &quot;Pr(MtaShp&gt;ODM)=60%&quot;, &quot;Pr(MtaShp&gt;ODM)=60%&quot;, &quot;Pr(MtaSh… ## $ pr_diff_lab_sm &lt;chr&gt; &quot;Pr(&lt;0)=60%&quot;, &quot;Pr(&lt;0)=60%&quot;, &quot;Pr(&lt;0)=60%&quot;, &quot;Pr(&lt;0)=60%… ## $ pr_diff_lab_pos &lt;dbl&gt; -0.1764721, -0.1764721, -0.1764721, -0.1764721, -0.17… ## $ sig_level &lt;ord&gt; &lt;80%, &lt;80%, &lt;80%, &lt;80%, &lt;80%, &lt;80%, &lt;80%, &lt;80%, &lt;80%,… plot it plt_contrast( brms_contrast_temp # , caption_text = form_temp , y_axis_title = &quot;software&quot; ) and summarize these contrasts brms_contrast_temp %&gt;% dplyr::group_by(contrast, pr_gt_zero) %&gt;% tidybayes::median_hdi(value) %&gt;% dplyr::arrange(contrast) %&gt;% dplyr::select(contrast, value, .lower, .upper, pr_gt_zero) %&gt;% kableExtra::kbl( digits = 2 , caption = &quot;brms::brm model: 95% HDI of the posterior predictive distribution of group constrasts&quot; , col.names = c( &quot;software contrast&quot; , &quot;difference (F-score)&quot; , &quot;HDI low&quot;, &quot;HDI high&quot; , &quot;Pr(diff&gt;0)&quot; ) ) %&gt;% kableExtra::kable_styling() Table 6.16: brms::brm model: 95% HDI of the posterior predictive distribution of group constrasts software contrast difference (F-score) HDI low HDI high Pr(diff&gt;0) OPENDRONEMAP - METASHAPE -0.01 -0.16 0.12 40% PIX4D - METASHAPE 0.01 -0.12 0.18 60% PIX4D - OPENDRONEMAP 0.02 -0.10 0.21 69% 6.4.2.11 \\(\\sigma\\) posteriors Finally, we can quantify the variation in F-score by comparing the \\(\\sigma\\) (sd) posteriors unsure about the scale of the \\(\\sigma\\) parameters are on in the beta model. Here, we invert the logit sd values from the model using plogis() which converts the parameter values to a probability/proportion (e.g.; 0-1) because they are parameters of the intercept and interaction effects so must be on the transformed (link = \"logit\") scale…double check For a phenomenally excellent overview of binary logistic regression and how to interpret coefficients, see Steven Miller’s most excellent lab script here # tidybayes::get_variables(brms_f_mod5) # extract the posterior draws # extract the posterior draws brms::as_draws_df(brms_f_mod5) %&gt;% dplyr::select(c(tidyselect::starts_with(&quot;sd_&quot;))) %&gt;% tidyr::pivot_longer(dplyr::everything()) %&gt;% # dplyr::group_by(name) %&gt;% # tidybayes::median_hdi(value) %&gt;% dplyr::mutate( name = name %&gt;% stringr::str_replace_all(&quot;depth_maps_generation_quality&quot;, &quot;quality&quot;) %&gt;% stringr::str_replace_all(&quot;depth_maps_generation_filtering_mode&quot;, &quot;filtering&quot;) %&gt;% stringr::str_remove_all(&quot;sd_&quot;) %&gt;% stringr::str_remove_all(&quot;__Intercept&quot;) %&gt;% stringr::str_replace_all(&quot;_&quot;, &quot; &quot;) %&gt;% forcats::fct_reorder(value) ) %&gt;% # plot ggplot(aes(x = value, y = name)) + tidybayes::stat_dotsinterval( point_interval = median_hdi, .width = .95 , justification = -0.04 , shape = 21 #, point_size = 3 , quantiles = 100 ) + scale_x_continuous(breaks = NULL) + labs(x = &quot;&quot;, y = &quot;&quot; , subtitle = latex2exp::TeX(&quot;$\\\\sigma_\\\\beta$ posterior distributions&quot;) , title = &quot;F-Score&quot; ) + theme_light() + theme( plot.subtitle = element_text(size = 8) , plot.title = element_text(size = 9) ) Variance of study site is stronger than variance of depth map generation quality, but the posterior predictive distributions overlap a good deal. The study site (the “subjects” in our study) seems to have the overall strongest effect, but this comes with high uncertainty. Taken alone, the influence of quality, filtering, and software comes with huge uncertainty. This makes sense as the influence of software largely depends on the depth map generation quality, of which we are fairly certain. Filtering mode has the overall weakest effect on tree detection and this comes with relatively high certainty, especially conditional on the depth map generation quality. 6.4.2.12 Additional Plots for Export patchwork of F-score contrasts layout_temp = c( # area(t, l, b, r) patchwork::area(2, 1, 2, 1) , patchwork::area(2, 3, 2, 3) , patchwork::area(4, 1, 4, 3) ) # check the layout # plot(layout_temp) ############################ # patchwork for height ############################ ptchwrk_qlty_sftwr_comp + labs(subtitle = &quot;A: Quality Contrast by Software&quot;) + theme(plot.background = element_rect(colour = &quot;gray88&quot;, fill=NA, size=3)) + ptchwrk_fltr_sftwr_comp + labs(subtitle = &quot;B: Filtering Mode Contrast by Software&quot;) + theme(plot.background = element_rect(colour = &quot;gray88&quot;, fill=NA, size=3)) + patchwork::free( ptchwrk_sftwr_qlty_comp + labs(subtitle = &quot;C: Software Contrast by Quality&quot;) + theme(plot.background = element_rect(colour = &quot;gray88&quot;, fill=NA, size=3)) ) + # plot_annotation(tag_levels = list(c(&#39;#&#39;, &#39;&amp;&#39;), &#39;1&#39;)) + patchwork::plot_layout( design = layout_temp , widths = c(1,0.01,1) , heights = c(0.01,1,0.01,1,0.01) ) &amp; scale_x_continuous( limits = c(-0.58,0.96) , breaks = seq(-0.8,0.8,0.4) , labels = seq(-0.8,0.8,0.4) %&gt;% scales::number(accuracy = 0.1) ) &amp; theme( axis.title.y = element_blank() , plot.subtitle = element_text(face = &quot;bold&quot;, hjust = 0.0) # , plot.background = element_rect(colour = &quot;gray88&quot;, fill=NA, size=3) ) ggplot2::ggsave( filename = paste0(&quot;../data/all_fscore_contrasts.jpeg&quot;) , plot = ggplot2::last_plot() , width = 11 , height = 8.5 , units = &quot;in&quot; , dpi = &quot;print&quot; ) 6.5 Bayesian p-value The Bayesian p-value is the probability that a test statistic in the reference distribution exceeds its value in the data. The Bayesian p-value is calculated from the posterior predictive distribution of the new data and the distribution of the observed data. We estimate the probability that the test statistic calculated from “new” data arising from our model (\\(y_{new}\\)) is more extreme than the test statistic calculated from the observed data (\\(y\\)): \\(\\text{P-value}(y) = Pr(T(y_{new}) &gt; T(y))\\) where the test statistic \\(T(y)\\) describes the distribution of the data as a summary of the data; it could be the mean, variance, the coefﬁcient of variation, the kurtosis, the maximum, or the minimum of the observed data set, or it might be an “omnibus” statistic like a squared discrepancy or a chi-square value Hobbs and Hooten (2015, p. 188) Bayesian P values for mean and standard deviation test statistics The P values for the mean (P mean) give the probability that the mean of the data of new, out-of-sample observations simulated from the model exceeds the mean of the observed data. The P values for the standard deviation (P SD) give the probability that the standard deviation of new, out-of-sample observations simulated from the model exceeds the standard deviation of the observed data. Large (\\(\\gtrapprox 0.90\\)) or small (\\(\\lessapprox 0.10\\)) values indicate lack of fit. Hobbs and Hooten (2015);Hobbs et al. (2024, Appendix S2 p. 8) Check the Bayesian p-values between the models # bayesian p-value get_mod_p_val = function(my_mod, ndraws = 1000){ # get draws from the posterior predictive distribution brms::posterior_predict(my_mod, ndraws = ndraws) %&gt;% dplyr::as_tibble() %&gt;% dplyr::mutate(draw = dplyr::row_number()) %&gt;% tidyr::pivot_longer(cols = -draw, values_to = &quot;y_rep&quot;) %&gt;% dplyr::mutate(y_n = readr::parse_number(name)) %&gt;% dplyr::select(-c(y_n)) %&gt;% dplyr::group_by(draw) %&gt;% # make test statistic dplyr::summarise( # test statistics y_sim mean_y_rep = mean(y_rep) , sd_y_rep = sd(y_rep) ) %&gt;% # # observed data test statistics dplyr::mutate( # test statistics y mean_y = mean(my_mod$data[,1]) , sd_y = sd(my_mod$data[,1]) ) %&gt;% # p-values dplyr::ungroup() %&gt;% dplyr::mutate( p_val_mean = as.numeric(mean_y_rep &gt; mean_y) , p_val_sd = as.numeric(sd_y_rep &gt; sd_y) ) %&gt;% # summarize p-vals dplyr::summarise( P.mean = mean(p_val_mean) , P.sd = mean(p_val_sd) ) } # get the model p-values set.seed(16) # replicate results dplyr::bind_rows( get_mod_p_val(brms_f_mod5, ndraws = 5000) %&gt;% dplyr::mutate(model = &quot;brms_f_mod5&quot;) ) %&gt;% dplyr::relocate(model) %&gt;% kableExtra::kbl(digits = 3) %&gt;% kableExtra::kable_styling() model P.mean P.sd brms_f_mod5 0.228 0.878 "],["stats_detected.html", "Section 7 Statistical Analysis: Detected Tree Reliability 7.1 Model Definition 7.2 Setup 7.3 Tree Height 7.4 Tree DBH 7.5 Posterior Predictive Checks", " Section 7 Statistical Analysis: Detected Tree Reliability In this section, we’ll evaluate the influence of the processing parameters on UAS-detected tree height and DBH reliability. The UAS and Field validation data was built and described in this section. For this section we will only look at data from “matched” UAS-field tree pairs (i.e. true positive trees). For successfully matched trees, the UAS tree height and DBH values were compared to field survey tree values to determine the mean error and root mean square error (RMSE). The mean error quantifies the bias of the UAS data while the RMSE quantifies the precision of the UAS data. We will utilize our “full” model presented in the prior section in which we modeled the F-score which is a measure of how well the UAS detected trees represent the field survey trees. But here we will change the likelihood function and the prior distributions. For a more in-depth review of the traditional treatment of this sort of data structure called multifactor analysis of variance (ANOVA) compared to the Bayesian hierarchical generalization of the traditional ANOVA model used here see this previous section. 7.1 Model Definition We will used the same model structure for all dependent variables of interest in this section which include: Height Mean Error (m) Height RMSE (m) DBH Mean Error (cm) DBH RMSE (cm) Kruschke (2015) describes the Hierarchical Bayesian approach to describe groups of metric data with multiple nominal predictors when every subject (“study site” in our research) only contributes one observation per cell/condition: \\[\\begin{align*} y = &amp; \\; \\beta_0 \\\\ &amp; + \\overrightarrow \\beta_1 \\overrightarrow x_1 + \\overrightarrow \\beta_2 \\overrightarrow x_2 + \\overrightarrow \\beta_{1 \\times 2} \\overrightarrow x_{1 \\times 2} \\\\ &amp; + \\overrightarrow \\beta_S \\overrightarrow x_S \\end{align*}\\] In other words, we assume a main effect of subject, but no interaction of subject with other predictors. In this model, the subject effect (deflection) is constant across treatments, and the treatment effects (deflections) are constant across subjects. Notice that the model makes no requirement that every subject contributes a datum to every condition. Indeed, the model allows zero or multiple data per subject per condition. Bayesian estimation makes no assumptions or requirements that the design is balanced (i.e., has equal numbers of measurement in each cell). (p. 608) and see section 20 from Kurz’s ebook supplement The metric predicted variable with three nominal predictor variables and subject-level effects model has the form: \\[\\begin{align*} y_{i} \\sim &amp; \\operatorname{Normal}\\bigl(\\mu_{i}, \\sigma_{y} \\bigr) \\\\ \\mu_{i} = &amp; \\beta_0 \\\\ &amp; + \\sum_{j=1}^{J=5} \\beta_{1[j]} x_{1[j]} + \\sum_{k=1}^{K=4} \\beta_{2[k]} x_{2[k]} + \\sum_{f=1}^{F=3} \\beta_{3[f]} x_{3[f]} + \\sum_{s=1}^{S=5} \\beta_{4[s]} x_{4[s]} \\\\ &amp; + \\sum_{j,k} \\beta_{1\\times2[j,k]} x_{1\\times2[j,k]} + \\sum_{j,f} \\beta_{1\\times3[j,f]} x_{1\\times3[j,f]} + \\sum_{k,f} \\beta_{2\\times3[k,f]} x_{2\\times3[k,f]} \\\\ &amp; + \\sum_{j,k,f} \\beta_{1\\times2\\times3[j,k,f]} x_{1\\times2\\times3[j,k,f]} \\\\ \\beta_{0} \\sim &amp; \\operatorname{Normal}(\\bar{y},y_{SD} \\times 5) \\\\ \\beta_{1[j]} \\sim &amp; \\operatorname{Normal}(\\bar{y},\\sigma_{\\beta_{1}}) \\\\ \\beta_{2[k]} \\sim &amp; \\operatorname{Normal}(\\bar{y},\\sigma_{\\beta_{2}}) \\\\ \\beta_{3[f]} \\sim &amp; \\operatorname{Normal}(\\bar{y},\\sigma_{\\beta_{3}}) \\\\ \\beta_{4[s]} \\sim &amp; \\operatorname{Normal}(\\bar{y},\\sigma_{\\beta_{4}}) \\\\ \\beta_{1\\times2[j,k]} \\sim &amp; \\operatorname{Normal}(\\bar{y},\\sigma_{\\beta_{1\\times2}}) \\\\ \\beta_{1\\times3[j,f]} \\sim &amp; \\operatorname{Normal}(\\bar{y},\\sigma_{\\beta_{1\\times3}}) \\\\ \\beta_{2\\times3[k,f]} \\sim &amp; \\operatorname{Normal}(\\bar{y},\\sigma_{\\beta_{2\\times3}}) \\\\ \\sigma_{\\beta_{1}} \\sim &amp; \\operatorname{Gamma}(shape,rate) \\\\ \\sigma_{\\beta_{2}} \\sim &amp; \\operatorname{Gamma}(shape,rate) \\\\ \\sigma_{\\beta_{3}} \\sim &amp; \\operatorname{Gamma}(shape,rate) \\\\ \\sigma_{\\beta_{4}} \\sim &amp; \\operatorname{Gamma}(shape,rate) \\\\ \\sigma_{\\beta_{1\\times2}} \\sim &amp; \\operatorname{Gamma}(shape,rate) \\\\ \\sigma_{\\beta_{1\\times3}} \\sim &amp; \\operatorname{Gamma}(shape,rate) \\\\ \\sigma_{\\beta_{2\\times3}} \\sim &amp; \\operatorname{Gamma}(shape,rate) \\\\ \\sigma_{y} \\sim &amp; \\operatorname{Cauchy}(0,y_{SD}) \\\\ \\end{align*}\\] , where \\(j\\) is the depth map generation quality setting corresponding to observation \\(i\\), \\(k\\) is the depth map filtering mode setting corresponding to observation \\(i\\), \\(f\\) is the processing software corresponding to observation \\(i\\), and \\(s\\) is the study site corresponding to observation \\(i\\) for this model, we’ll define the priors following Kurz Kruschke (2015) explains this prior distribution methodology: we let the data serve as a proxy and we set the prior wide relative to the variance in the data, called ySD. Analogously, the normal prior for the baseline a0 is centered on the data mean and made very wide relative to the variance of the data. The goal is merely to achieve scale invariance, so that whatever is the measurement scale of the data, the prior will be broad and noncommittal on that scale…The prior on aSigma is a gamma distribution that is broad on the scale of the data, and that has a nonzero mode so that its probability density drops to zero as aSigma approaches zero. Specifically, the shape and rate parameters of the gamma distribution are set so its mode is sd(y)/2 and its standard deviation is 2*sd(y) (p.560-561) 7.2 Setup load the data if needed # load data if needed if(ls()[ls() %in% &quot;ptcld_validation_data&quot;] %&gt;% length()==0){ ptcld_validation_data = readr::read_csv(&quot;../data/ptcld_full_analysis_data.csv&quot;) %&gt;% dplyr::mutate( depth_maps_generation_quality = factor( depth_maps_generation_quality %&gt;% tolower() %&gt;% stringr::str_replace_all(&quot;ultrahigh&quot;, &quot;ultra high&quot;) , ordered = TRUE , levels = c( &quot;lowest&quot; , &quot;low&quot; , &quot;medium&quot; , &quot;high&quot; , &quot;ultra high&quot; ) ) %&gt;% forcats::fct_rev() , depth_maps_generation_filtering_mode = factor( depth_maps_generation_filtering_mode %&gt;% tolower() , ordered = TRUE , levels = c( &quot;disabled&quot; , &quot;mild&quot; , &quot;moderate&quot; , &quot;aggressive&quot; ) ) %&gt;% forcats::fct_rev() ) } What is this data? # what is this data? ptcld_validation_data %&gt;% dplyr::glimpse() ## Rows: 260 ## Columns: 114 ## $ tracking_file_full_path &lt;chr&gt; &quot;E:\\\\SfM_Software_Comparison\\\\Me… ## $ software &lt;chr&gt; &quot;METASHAPE&quot;, &quot;METASHAPE&quot;, &quot;METAS… ## $ study_site &lt;chr&gt; &quot;KAIBAB_HIGH&quot;, &quot;KAIBAB_HIGH&quot;, &quot;K… ## $ processing_attribute1 &lt;chr&gt; &quot;HIGH&quot;, &quot;HIGH&quot;, &quot;HIGH&quot;, &quot;HIGH&quot;, … ## $ processing_attribute2 &lt;chr&gt; &quot;AGGRESSIVE&quot;, &quot;DISABLED&quot;, &quot;MILD&quot;… ## $ processing_attribute3 &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, … ## $ file_name &lt;chr&gt; &quot;HIGH_AGGRESSIVE&quot;, &quot;HIGH_DISABLE… ## $ number_of_points &lt;int&gt; 52974294, 72549206, 69858217, 69… ## $ las_area_m2 &lt;dbl&gt; 86661.27, 87175.42, 86404.78, 86… ## $ timer_tile_time_mins &lt;dbl&gt; 0.63600698, 2.49318542, 0.841338… ## $ timer_class_dtm_norm_chm_time_mins &lt;dbl&gt; 3.6559556, 5.3289152, 5.1638296,… ## $ timer_treels_time_mins &lt;dbl&gt; 8.9065272, 19.2119663, 12.339179… ## $ timer_itd_time_mins &lt;dbl&gt; 0.02202115, 0.02449968, 0.037984… ## $ timer_competition_time_mins &lt;dbl&gt; 0.10590740, 0.17865245, 0.121248… ## $ timer_estdbh_time_mins &lt;dbl&gt; 0.02290262, 0.02382533, 0.021991… ## $ timer_silv_time_mins &lt;dbl&gt; 0.012565533, 0.015940932, 0.0150… ## $ timer_total_time_mins &lt;dbl&gt; 13.361886, 27.276985, 18.540606,… ## $ sttng_input_las_dir &lt;chr&gt; &quot;D:/Metashape_Testing_2024&quot;, &quot;D:… ## $ sttng_use_parallel_processing &lt;lgl&gt; FALSE, FALSE, FALSE, FALSE, FALS… ## $ sttng_desired_chm_res &lt;dbl&gt; 0.25, 0.25, 0.25, 0.25, 0.25, 0.… ## $ sttng_max_height_threshold_m &lt;int&gt; 60, 60, 60, 60, 60, 60, 60, 60, … ## $ sttng_minimum_tree_height_m &lt;int&gt; 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,… ## $ sttng_dbh_max_size_m &lt;int&gt; 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,… ## $ sttng_local_dbh_model &lt;chr&gt; &quot;rf&quot;, &quot;rf&quot;, &quot;rf&quot;, &quot;rf&quot;, &quot;rf&quot;, &quot;r… ## $ sttng_user_supplied_epsg &lt;lgl&gt; NA, NA, NA, NA, NA, NA, NA, NA, … ## $ sttng_accuracy_level &lt;int&gt; 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,… ## $ sttng_pts_m2_for_triangulation &lt;int&gt; 20, 20, 20, 20, 20, 20, 20, 20, … ## $ sttng_normalization_with &lt;chr&gt; &quot;triangulation&quot;, &quot;triangulation&quot;… ## $ sttng_competition_buffer_m &lt;int&gt; 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,… ## $ depth_maps_generation_quality &lt;ord&gt; high, high, high, high, low, low… ## $ depth_maps_generation_filtering_mode &lt;ord&gt; aggressive, disabled, mild, mode… ## $ total_sfm_time_min &lt;dbl&gt; 54.800000, 60.316667, 55.933333,… ## $ number_of_points_sfm &lt;dbl&gt; 52974294, 72549206, 69858217, 69… ## $ total_sfm_time_norm &lt;dbl&gt; 0.1117823680, 0.1237564664, 0.11… ## $ processed_data_dir &lt;chr&gt; &quot;E:/SfM_Software_Comparison/Meta… ## $ processing_id &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1… ## $ true_positive_n_trees &lt;dbl&gt; 229, 261, 260, 234, 220, 175, 23… ## $ commission_n_trees &lt;dbl&gt; 173, 222, 213, 193, 148, 223, 16… ## $ omission_n_trees &lt;dbl&gt; 772, 740, 741, 767, 781, 826, 77… ## $ f_score &lt;dbl&gt; 0.3264433, 0.3517520, 0.3527815,… ## $ tree_height_m_me &lt;dbl&gt; 0.270336679, 0.283568790, 0.3122… ## $ tree_height_m_mpe &lt;dbl&gt; 0.002357383, 0.013286785, 0.0142… ## $ tree_height_m_mae &lt;dbl&gt; 0.7873610, 0.6886235, 0.6914983,… ## $ tree_height_m_mape &lt;dbl&gt; 0.06624939, 0.06903969, 0.060550… ## $ tree_height_m_smape &lt;dbl&gt; 0.06776453, 0.06838733, 0.060410… ## $ tree_height_m_mse &lt;dbl&gt; 0.9842433, 0.8507862, 0.8259923,… ## $ tree_height_m_rmse &lt;dbl&gt; 0.9920904, 0.9223807, 0.9088412,… ## $ dbh_cm_me &lt;dbl&gt; 2.0551269, 1.2718827, 1.7505679,… ## $ dbh_cm_mpe &lt;dbl&gt; 0.077076168, 0.056392083, 0.0755… ## $ dbh_cm_mae &lt;dbl&gt; 5.091373, 4.375871, 4.674437, 4.… ## $ dbh_cm_mape &lt;dbl&gt; 0.2076874, 0.2185989, 0.2110014,… ## $ dbh_cm_smape &lt;dbl&gt; 0.1966263, 0.2081000, 0.1986588,… ## $ dbh_cm_mse &lt;dbl&gt; 44.38957, 35.29251, 38.33622, 38… ## $ dbh_cm_rmse &lt;dbl&gt; 6.662549, 5.940750, 6.191625, 6.… ## $ uas_basal_area_m2 &lt;dbl&gt; 55.75278, 60.26123, 58.67391, 57… ## $ field_basal_area_m2 &lt;dbl&gt; 69.04409, 69.04409, 69.04409, 69… ## $ uas_basal_area_m2_per_ha &lt;dbl&gt; 31.97437, 34.55997, 33.64964, 33… ## $ field_basal_area_m2_per_ha &lt;dbl&gt; 39.59697, 39.59697, 39.59697, 39… ## $ basal_area_m2_error &lt;dbl&gt; -13.291309, -8.782866, -10.37018… ## $ basal_area_m2_per_ha_error &lt;dbl&gt; -7.622601, -5.036997, -5.947326,… ## $ basal_area_pct_error &lt;dbl&gt; -0.19250466, -0.12720663, -0.150… ## $ basal_area_abs_pct_error &lt;dbl&gt; 0.19250466, 0.12720663, 0.150196… ## $ overstory_commission_n_trees &lt;dbl&gt; 141, 178, 178, 160, 95, 173, 120… ## $ understory_commission_n_trees &lt;dbl&gt; 32, 44, 35, 33, 53, 50, 43, 39, … ## $ overstory_omission_n_trees &lt;dbl&gt; 558, 560, 545, 556, 554, 598, 54… ## $ understory_omission_n_trees &lt;dbl&gt; 214, 180, 196, 211, 227, 228, 22… ## $ overstory_true_positive_n_trees &lt;dbl&gt; 185, 183, 198, 187, 189, 145, 19… ## $ understory_true_positive_n_trees &lt;dbl&gt; 44, 78, 62, 47, 31, 30, 33, 40, … ## $ overstory_f_score &lt;dbl&gt; 0.3461179, 0.3315217, 0.3538874,… ## $ understory_f_score &lt;dbl&gt; 0.2634731, 0.4105263, 0.3492958,… ## $ overstory_tree_height_m_me &lt;dbl&gt; 0.41693172, 0.44114110, 0.442167… ## $ understory_tree_height_m_me &lt;dbl&gt; -0.34602886, -0.08612009, -0.102… ## $ overstory_tree_height_m_mpe &lt;dbl&gt; 0.020790675, 0.024558478, 0.0241… ## $ understory_tree_height_m_mpe &lt;dbl&gt; -0.075146232, -0.013158341, -0.0… ## $ overstory_tree_height_m_mae &lt;dbl&gt; 0.8201433, 0.7820879, 0.7770369,… ## $ understory_tree_height_m_mae &lt;dbl&gt; 0.6495266, 0.4693415, 0.4183269,… ## $ overstory_tree_height_m_mape &lt;dbl&gt; 0.04662933, 0.04863237, 0.048708… ## $ understory_tree_height_m_mape &lt;dbl&gt; 0.14874284, 0.11691842, 0.098369… ## $ overstory_tree_height_m_smape &lt;dbl&gt; 0.04589942, 0.04776615, 0.047912… ## $ understory_tree_height_m_smape &lt;dbl&gt; 0.15969736, 0.11676780, 0.100322… ## $ overstory_tree_height_m_mse &lt;dbl&gt; 1.0623763, 1.0055835, 0.9739823,… ## $ understory_tree_height_m_mse &lt;dbl&gt; 0.6557300, 0.4876080, 0.3533791,… ## $ overstory_tree_height_m_rmse &lt;dbl&gt; 1.0307164, 1.0027878, 0.9869054,… ## $ understory_tree_height_m_rmse &lt;dbl&gt; 0.8097715, 0.6982893, 0.5944570,… ## $ overstory_dbh_cm_me &lt;dbl&gt; 2.88225065, 2.37098111, 2.694675… ## $ understory_dbh_cm_me &lt;dbl&gt; -1.4225525, -1.3067712, -1.26448… ## $ overstory_dbh_cm_mpe &lt;dbl&gt; 0.11199444, 0.09928650, 0.110477… ## $ understory_dbh_cm_mpe &lt;dbl&gt; -0.06973931, -0.04424482, -0.035… ## $ overstory_dbh_cm_mae &lt;dbl&gt; 5.753010, 5.298094, 5.472454, 5.… ## $ understory_dbh_cm_mae &lt;dbl&gt; 2.309487, 2.212192, 2.125931, 2.… ## $ overstory_dbh_cm_mape &lt;dbl&gt; 0.1862021, 0.1848729, 0.1898205,… ## $ understory_dbh_cm_mape &lt;dbl&gt; 0.2980235, 0.2977254, 0.2786439,… ## $ overstory_dbh_cm_smape &lt;dbl&gt; 0.1686851, 0.1699578, 0.1735200,… ## $ understory_dbh_cm_smape &lt;dbl&gt; 0.3141064, 0.2975874, 0.2789409,… ## $ overstory_dbh_cm_mse &lt;dbl&gt; 52.78250, 46.57941, 47.70797, 46… ## $ understory_dbh_cm_mse &lt;dbl&gt; 9.101103, 8.811704, 8.407077, 9.… ## $ overstory_dbh_cm_rmse &lt;dbl&gt; 7.265156, 6.824911, 6.907095, 6.… ## $ understory_dbh_cm_rmse &lt;dbl&gt; 3.016803, 2.968451, 2.899496, 3.… ## $ overstory_uas_basal_area_m2 &lt;dbl&gt; 55.49096, 59.79139, 58.30184, 57… ## $ understory_uas_basal_area_m2 &lt;dbl&gt; 0.2618258, 0.4698415, 0.3720740,… ## $ overstory_field_basal_area_m2 &lt;dbl&gt; 67.50326, 67.50326, 67.50326, 67… ## $ understory_field_basal_area_m2 &lt;dbl&gt; 1.540832, 1.540832, 1.540832, 1.… ## $ overstory_uas_basal_area_m2_per_ha &lt;dbl&gt; 31.82421, 34.29052, 33.43626, 32… ## $ understory_uas_basal_area_m2_per_ha &lt;dbl&gt; 0.15015781, 0.26945534, 0.213385… ## $ overstory_field_basal_area_m2_per_ha &lt;dbl&gt; 38.7133, 38.7133, 38.7133, 38.71… ## $ understory_field_basal_area_m2_per_ha &lt;dbl&gt; 0.883671, 0.883671, 0.883671, 0.… ## $ overstory_basal_area_m2_per_ha_error &lt;dbl&gt; -6.889088, -4.422782, -5.277041,… ## $ understory_basal_area_m2_per_ha_error &lt;dbl&gt; -0.7335132, -0.6142157, -0.67028… ## $ overstory_basal_area_pct_error &lt;dbl&gt; -0.17795146, -0.11424450, -0.136… ## $ understory_basal_area_pct_error &lt;dbl&gt; -0.8300750, -0.6950728, -0.75852… ## $ overstory_basal_area_abs_pct_error &lt;dbl&gt; 0.17795146, 0.11424450, 0.136310… ## $ understory_basal_area_abs_pct_error &lt;dbl&gt; 0.8300750, 0.6950728, 0.7585239,… ## $ validation_file_full_path &lt;chr&gt; &quot;E:/SfM_Software_Comparison/Meta… ## $ overstory_ht_m &lt;dbl&gt; 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,… # a row is unique by... identical( nrow(ptcld_validation_data) , ptcld_validation_data %&gt;% dplyr::distinct( study_site, software , depth_maps_generation_quality , depth_maps_generation_filtering_mode , processing_attribute3 # need to align all by software so this will go away or be filled ) %&gt;% nrow() ) ## [1] TRUE load our plotting functions if needed (not showing these functions here but see the prior section for function definitions) 7.3 Tree Height 7.3.1 Summary Statistics 7.3.1.1 Height Mean Error (bias) # summarize data dta_temp = ptcld_validation_data %&gt;% dplyr::group_by(software, depth_maps_generation_quality, depth_maps_generation_filtering_mode) %&gt;% # collapse across study site dplyr::summarise( tree_height_m_me = mean(tree_height_m_me, na.rm = T) , n = dplyr::n() ) # set limits for color scale lmt_tree_height_m_me = ceiling(10*max(abs(range(dta_temp$tree_height_m_me, na.rm = T))))/10 # scales::show_col(scales::pal_dichromat(&quot;BluetoOrange.10&quot;)(10)) # scales::show_col(scales::pal_div_gradient()(seq(0, 1, length.out = 7))) # plot it dta_temp %&gt;% ggplot(mapping = aes( y = depth_maps_generation_quality , x = depth_maps_generation_filtering_mode , fill = tree_height_m_me , label = paste0(scales::comma(tree_height_m_me,accuracy = 0.01), &quot;\\n(n=&quot;, n,&quot;)&quot;) )) + geom_tile(color = &quot;white&quot;) + geom_text(color = &quot;white&quot;, size = 3) + facet_grid(cols = vars(software)) + scale_x_discrete(expand = c(0, 0)) + scale_y_discrete(expand = c(0, 0)) + scale_fill_stepsn( n.breaks = 7 , colors = scales::pal_div_gradient()(seq(0, 1, length.out = 7)) , limits = c(-lmt_tree_height_m_me,lmt_tree_height_m_me) , labels = scales::comma_format(accuracy = 0.1) , show.limits = T ) + labs( x = &quot;filtering mode&quot; , y = &quot;quality&quot; , fill = &quot;Height Mean Error (m)&quot; , title = &quot;mean height mean error (m) and # of study sites&quot; , subtitle = paste( &quot;negative values = UAS tree height &lt; field tree height&quot; , &quot; || &quot; , &quot;positive values = UAS tree height &gt; field tree height&quot; ) ) + theme_light() + theme( legend.position = &quot;none&quot; , axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1) , panel.background = element_blank() , panel.grid = element_blank() # , plot.title = element_text(hjust = 0.5) # , plot.subtitle = element_text(hjust = 0.5) , strip.text = element_text(color = &quot;black&quot;, face = &quot;bold&quot;) ) let’s check the distribution (of our dependent or \\(y\\) variable) # distribution ptcld_validation_data %&gt;% ggplot(mapping = aes(x = tree_height_m_me)) + geom_hline(yintercept = 0, color = &quot;gray77&quot;) + geom_vline(xintercept = 0, color = &quot;gray77&quot;) + # geom_vline(xintercept = c(0,1)) + geom_density(fill = &quot;lightblue&quot;, alpha = 0.7, color = NA) + labs(y=&quot;&quot;,x=&quot;Height Mean Error (m)&quot;) + scale_y_continuous(breaks = c(0)) + scale_x_continuous(breaks = scales::extended_breaks(10)) + theme_light() + theme(panel.grid = element_blank()) + labs( caption = ) and the summary statistics ptcld_validation_data %&gt;% dplyr::ungroup() %&gt;% dplyr::select(tree_height_m_me) %&gt;% dplyr::summarise( dplyr::across( dplyr::everything() , .fns = list( mean = ~ mean(.x,na.rm=T), median = ~ median(.x,na.rm=T), sd = ~ sd(.x,na.rm=T) , min = ~ min(.x,na.rm=T), max = ~ max(.x,na.rm=T) , q25 = ~ quantile(.x, 0.25, na.rm = T) , q75 = ~ quantile(.x, 0.75, na.rm = T) ) , .names = &quot;{.fn}&quot; ) ) %&gt;% tidyr::pivot_longer(everything()) %&gt;% kableExtra::kbl(caption = &quot;summary: `tree_height_m_me`&quot;, digits = 3, col.names = NULL) %&gt;% kableExtra::kable_styling() Table 7.1: summary: tree_height_m_me mean 0.122 median 0.166 sd 0.355 min -1.860 max 0.763 q25 -0.088 q75 0.356 7.3.1.2 Height RMSE (precision) # summarize data dta_temp = ptcld_validation_data %&gt;% dplyr::group_by(software, depth_maps_generation_quality, depth_maps_generation_filtering_mode) %&gt;% # collapse across study site dplyr::summarise( tree_height_m_rmse = mean(tree_height_m_rmse, na.rm = T) , n = dplyr::n() ) # set limits for color scale lmt_tree_height_m_rmse = ceiling(1.02*10*max(abs(range(dta_temp$tree_height_m_rmse, na.rm = T))))/10 # scales::show_col(viridis::mako(n = 10, begin = 0.2, end = 0.9, direction = -1)) # scales::show_col(scales::pal_div_gradient()(seq(0, 1, length.out = 7))) # plot it dta_temp %&gt;% ggplot(mapping = aes( y = depth_maps_generation_quality , x = depth_maps_generation_filtering_mode , fill = tree_height_m_rmse , label = paste0(scales::comma(tree_height_m_rmse,accuracy = 0.01), &quot;\\n(n=&quot;, n,&quot;)&quot;) )) + geom_tile(color = &quot;white&quot;) + geom_text(color = &quot;white&quot;, size = 3) + facet_grid(cols = vars(software)) + scale_x_discrete(expand = c(0, 0)) + scale_y_discrete(expand = c(0, 0)) + scale_fill_stepsn( n.breaks = 5 , colors = viridis::mako(n = 5, begin = 0.2, end = 0.9, direction = -1) , limits = c(0,lmt_tree_height_m_rmse) , labels = scales::comma_format(accuracy = 0.01) , show.limits = T ) + labs( x = &quot;filtering mode&quot; , y = &quot;quality&quot; , fill = &quot;Height RMSE (m)&quot; , title = &quot;mean height RMSE (m) and # of study sites&quot; ) + theme_light() + theme( legend.position = &quot;none&quot; , axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1) , panel.background = element_blank() , panel.grid = element_blank() # , plot.title = element_text(hjust = 0.5) # , plot.subtitle = element_text(hjust = 0.5) , strip.text = element_text(color = &quot;black&quot;, face = &quot;bold&quot;) ) let’s check the distribution (of our dependent or \\(y\\) variable) # distribution ptcld_validation_data %&gt;% ggplot(mapping = aes(x = tree_height_m_rmse)) + geom_hline(yintercept = 0, color = &quot;gray77&quot;) + geom_vline(xintercept = 0, color = &quot;gray77&quot;) + # geom_vline(xintercept = c(0,1)) + geom_density(fill = &quot;lightblue&quot;, alpha = 0.7, color = NA) + labs(y=&quot;&quot;,x=&quot;Height RMSE (m)&quot;) + scale_y_continuous(breaks = c(0)) + scale_x_continuous(breaks = scales::extended_breaks(10)) + theme_light() + theme(panel.grid = element_blank()) and the summary statistics ptcld_validation_data %&gt;% dplyr::ungroup() %&gt;% dplyr::select(tree_height_m_rmse) %&gt;% dplyr::summarise( dplyr::across( dplyr::everything() , .fns = list( mean = ~ mean(.x,na.rm=T), median = ~ median(.x,na.rm=T), sd = ~ sd(.x,na.rm=T) , min = ~ min(.x,na.rm=T), max = ~ max(.x,na.rm=T) , q25 = ~ quantile(.x, 0.25, na.rm = T) , q75 = ~ quantile(.x, 0.75, na.rm = T) ) , .names = &quot;{.fn}&quot; ) ) %&gt;% tidyr::pivot_longer(everything()) %&gt;% kableExtra::kbl(caption = &quot;summary: `tree_height_m_rmse`&quot;, digits = 3, col.names = NULL) %&gt;% kableExtra::kable_styling() Table 7.2: summary: tree_height_m_rmse mean 0.827 median 0.819 sd 0.179 min 0.394 max 1.860 q25 0.678 q75 0.965 7.3.2 Model: Height Mean Error (bias) # from Kurz: gamma_a_b_from_omega_sigma = function(mode, sd) { if (mode &lt;= 0) stop(&quot;mode must be &gt; 0&quot;) if (sd &lt;= 0) stop(&quot;sd must be &gt; 0&quot;) rate = (mode + sqrt(mode^2 + 4 * sd^2)) / (2 * sd^2) shape = 1 + mode * rate return(list(shape = shape, rate = rate)) } mean_y_temp = mean(ptcld_validation_data$tree_height_m_me, na.rm = T) sd_y_temp = sd(ptcld_validation_data$tree_height_m_me, na.rm = T) omega_temp = sd_y_temp / 2 sigma_temp = 2 * sd_y_temp s_r_temp = gamma_a_b_from_omega_sigma(mode = omega_temp, sd = sigma_temp) stanvars_temp = brms::stanvar(mean_y_temp, name = &quot;mean_y&quot;) + brms::stanvar(sd_y_temp, name = &quot;sd_y&quot;) + brms::stanvar(s_r_temp$shape, name = &quot;alpha&quot;) + brms::stanvar(s_r_temp$rate, name = &quot;beta&quot;) 7.3.2.1 Prior distributions #### setting priors # required libraries: tidyverse, tidybayes, brms, palettetown, latex2exp priors_temp &lt;- c( brms::prior(normal(mean_y_temp, sd_y_temp * 5), class = &quot;Intercept&quot;) , brms::prior(gamma(s_r_temp$shape, s_r_temp$rate), class = &quot;sd&quot;) , brms::prior(cauchy(0, sd_y_temp), class = &quot;sigma&quot;) ) # plot plt_prior1 = priors_temp %&gt;% tidybayes::parse_dist() %&gt;% tidybayes::marginalize_lkjcorr(K = 2) %&gt;% tidyr::separate( .args , sep = &quot;,&quot; , into = c(&quot;a&quot;,&quot;b&quot;) , remove = F ) %&gt;% dplyr::mutate( distrib = paste0( class, &quot; ~ &quot; , .dist , &quot;(&quot; , a %&gt;% readr::parse_number() %&gt;% round(2) , &quot;,&quot; , b %&gt;% readr::parse_number() %&gt;% round(2) , &quot;)&quot; ) ) %&gt;% ggplot(., aes(dist = .dist, args = .args)) + facet_grid(cols=vars(distrib), scales = &quot;free&quot;) + ggdist::stat_halfeye( aes(fill = prior), n = 10e2, show.legend = F , fill = &quot;slategray&quot; ) + coord_flip() + theme_light() + theme( strip.text = element_text(face = &quot;bold&quot;, color = &quot;black&quot;), axis.text.y = element_blank(), axis.ticks = element_blank() , axis.text = element_text(size = 6) )+ labs( x = &quot;&quot; , title = &quot;Priors: Height Mean Error (bias)&quot; , y = &quot;&quot; ) plt_prior1 7.3.2.2 Fit the model Now fit the model. brms_ht_me_mod = brms::brm( formula = tree_height_m_me ~ # baseline 1 + # main effects (1 | depth_maps_generation_quality) + (1 | depth_maps_generation_filtering_mode) + (1 | software) + (1 | study_site) + # only fitting main effects of site and not interactions # two-way interactions (1 | depth_maps_generation_quality:depth_maps_generation_filtering_mode) + (1 | depth_maps_generation_quality:software) + (1 | depth_maps_generation_filtering_mode:software) + # three-way interactions (1 | depth_maps_generation_quality:depth_maps_generation_filtering_mode:software) , data = ptcld_validation_data , family = brms::brmsfamily(family = &quot;gaussian&quot;) , iter = 20000, warmup = 10000, chains = 4 , control = list(adapt_delta = 0.999, max_treedepth = 13) , cores = round(parallel::detectCores()/2) , prior = c( brms::prior(normal(mean_y, sd_y * 5), class = &quot;Intercept&quot;) , brms::prior(gamma(alpha, beta), class = &quot;sd&quot;) , brms::prior(cauchy(0, sd_y), class = &quot;sigma&quot;) ) , stanvars = stanvars_temp , file = paste0(rootdir, &quot;/fits/brms_ht_me_mod&quot;) ) 7.3.2.3 Quality:Filtering - interaction draws_temp = ptcld_validation_data %&gt;% dplyr::distinct(depth_maps_generation_quality, depth_maps_generation_filtering_mode) %&gt;% tidybayes::add_epred_draws( brms_ht_me_mod, allow_new_levels = T # this part is crucial , re_formula = ~ (1 | depth_maps_generation_quality) + (1 | depth_maps_generation_filtering_mode) + (1 | depth_maps_generation_quality:depth_maps_generation_filtering_mode) ) %&gt;% dplyr::rename(value = .epred) %&gt;% dplyr::mutate(med = tidybayes::median_hdci(value)$y) # plot draws_temp %&gt;% dplyr::mutate(depth_maps_generation_quality = depth_maps_generation_quality %&gt;% forcats::fct_rev()) %&gt;% # plot ggplot( mapping = aes( y = value, x = depth_maps_generation_filtering_mode , fill = med ) ) + geom_hline(yintercept = 0, color = &quot;gray33&quot;) + tidybayes::stat_eye( point_interval = median_hdi, .width = .95 , slab_alpha = 0.98 , interval_color = &quot;black&quot;, linewidth = 1 , point_color = &quot;black&quot;, point_fill = &quot;black&quot;, point_size = 1 ) + scale_fill_stepsn( n.breaks = 7 , colors = scales::pal_div_gradient()(seq(0, 1, length.out = 7)) , limits = c(-lmt_tree_height_m_me,lmt_tree_height_m_me) , labels = scales::comma_format(accuracy = 0.1) , show.limits = T ) + facet_grid(cols = vars(depth_maps_generation_quality)) + labs( x = &quot;filtering mode&quot;, y = &quot;Height Mean Error (m)&quot; , subtitle = &quot;posterior predictive distribution of height mean error (m) with 95% HDI\\nby dense cloud quality&quot; ) + theme_light() + theme( legend.position = &quot;none&quot; , legend.direction = &quot;horizontal&quot; , axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1) , strip.text = element_text(color = &quot;black&quot;, face = &quot;bold&quot;) ) and a table of these 95% HDI values table_temp = draws_temp %&gt;% tidybayes::median_hdi(value) %&gt;% dplyr::select(-c(.point,.interval, .width,.row)) %&gt;% dplyr::arrange(depth_maps_generation_quality,depth_maps_generation_filtering_mode) table_temp %&gt;% dplyr::select(-c(depth_maps_generation_quality)) %&gt;% kableExtra::kbl( digits = 2 , caption = &quot;Height Mean Error (m)&lt;br&gt;95% HDI of the posterior predictive distribution&quot; , col.names = c( &quot;filtering mode&quot; , &quot;Height Mean Error (m)&lt;br&gt;median&quot; , &quot;HDI low&quot;, &quot;HDI high&quot; ) , escape = F ) %&gt;% kableExtra::kable_styling() %&gt;% kableExtra::pack_rows(index = table(forcats::fct_inorder(table_temp$depth_maps_generation_quality))) %&gt;% kableExtra::scroll_box(height = &quot;8in&quot;) Table 7.3: Height Mean Error (m)95% HDI of the posterior predictive distribution filtering mode Height Mean Error (m)median HDI low HDI high ultra high aggressive 0.26 -0.29 0.80 moderate 0.30 -0.25 0.83 mild 0.34 -0.20 0.88 disabled 0.37 -0.18 0.90 high aggressive 0.18 -0.37 0.72 moderate 0.23 -0.31 0.77 mild 0.27 -0.27 0.81 disabled 0.29 -0.27 0.82 medium aggressive 0.06 -0.49 0.59 moderate 0.11 -0.43 0.64 mild 0.16 -0.40 0.67 disabled 0.19 -0.36 0.71 low aggressive -0.06 -0.61 0.47 moderate -0.01 -0.54 0.53 mild 0.04 -0.50 0.58 disabled 0.08 -0.46 0.61 lowest aggressive -0.22 -0.78 0.37 moderate -0.16 -0.72 0.43 mild -0.10 -0.66 0.48 disabled -0.09 -0.65 0.50 7.3.2.4 Software:Quality - interaction draws_temp = ptcld_validation_data %&gt;% dplyr::distinct(depth_maps_generation_quality, software) %&gt;% tidybayes::add_epred_draws( brms_ht_me_mod, allow_new_levels = T # this part is crucial , re_formula = ~ (1 | depth_maps_generation_quality) + (1 | software) + (1 | depth_maps_generation_quality:software) ) %&gt;% dplyr::rename(value = .epred) %&gt;% dplyr::mutate(med = tidybayes::median_hdci(value)$y) # plot draws_temp %&gt;% dplyr::mutate(depth_maps_generation_quality = depth_maps_generation_quality %&gt;% forcats::fct_rev()) %&gt;% # plot ggplot( mapping = aes( y = value, x = software , fill = med ) ) + geom_hline(yintercept = 0, color = &quot;gray33&quot;) + tidybayes::stat_eye( point_interval = median_hdi, .width = .95 , slab_alpha = 0.98 , interval_color = &quot;black&quot;, linewidth = 1 , point_color = &quot;black&quot;, point_fill = &quot;black&quot;, point_size = 1 ) + scale_fill_stepsn( n.breaks = 7 , colors = scales::pal_div_gradient()(seq(0, 1, length.out = 7)) , limits = c(-lmt_tree_height_m_me,lmt_tree_height_m_me) , labels = scales::comma_format(accuracy = 0.1) , show.limits = T ) + facet_grid(cols = vars(depth_maps_generation_quality)) + labs( x = &quot;software&quot;, y = &quot;Height Mean Error (m)&quot; , subtitle = &quot;posterior predictive distribution of height mean error (m) with 95% HDI\\nby dense cloud quality&quot; ) + theme_light() + theme( legend.position = &quot;none&quot; , legend.direction = &quot;horizontal&quot; , axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1) , strip.text = element_text(color = &quot;black&quot;, face = &quot;bold&quot;) ) and a table of these 95% HDI values table_temp = draws_temp %&gt;% tidybayes::median_hdi(value) %&gt;% # remove out-of-sample obs dplyr::inner_join( ptcld_validation_data %&gt;% dplyr::distinct(depth_maps_generation_quality, software) , by = dplyr::join_by(depth_maps_generation_quality, software) ) %&gt;% dplyr::select(-c(.point,.interval, .width,.row)) %&gt;% dplyr::arrange(software,depth_maps_generation_quality) table_temp %&gt;% dplyr::select(-c(software)) %&gt;% kableExtra::kbl( digits = 2 , caption = &quot;Height Mean Error (m)&lt;br&gt;95% HDI of the posterior predictive distribution&quot; , col.names = c( &quot;quality&quot; , &quot;Height Mean Error (m)&lt;br&gt;median&quot; , &quot;HDI low&quot;, &quot;HDI high&quot; ) , escape = F ) %&gt;% kableExtra::kable_styling() %&gt;% kableExtra::pack_rows(index = table(forcats::fct_inorder(table_temp$software))) %&gt;% kableExtra::scroll_box(height = &quot;8in&quot;) Table 7.4: Height Mean Error (m)95% HDI of the posterior predictive distribution quality Height Mean Error (m)median HDI low HDI high METASHAPE ultra high 0.33 0.00 0.65 high 0.24 -0.08 0.57 medium 0.06 -0.27 0.38 low -0.23 -0.55 0.10 lowest -0.54 -0.87 -0.21 OPENDRONEMAP ultra high 0.36 0.04 0.69 high 0.22 -0.10 0.54 medium 0.06 -0.26 0.39 low 0.07 -0.26 0.39 lowest 0.01 -0.31 0.34 PIX4D ultra high 0.41 0.08 0.74 high 0.37 0.04 0.70 medium 0.29 -0.04 0.61 low 0.12 -0.21 0.45 7.3.2.5 Software:Filtering - interaction draws_temp = ptcld_validation_data %&gt;% dplyr::distinct(depth_maps_generation_filtering_mode, software) %&gt;% tidybayes::add_epred_draws( brms_ht_me_mod, allow_new_levels = T # this part is crucial , re_formula = ~ (1 | depth_maps_generation_filtering_mode) + (1 | software) + (1 | depth_maps_generation_filtering_mode:software) ) %&gt;% dplyr::rename(value = .epred) %&gt;% dplyr::mutate(med = tidybayes::median_hdci(value)$y) # plot draws_temp %&gt;% # plot ggplot( mapping = aes( y = value, x = software , fill = med ) ) + geom_hline(yintercept = 0, color = &quot;gray33&quot;) + tidybayes::stat_eye( point_interval = median_hdi, .width = .95 , slab_alpha = 0.98 , interval_color = &quot;black&quot;, linewidth = 1 , point_color = &quot;black&quot;, point_fill = &quot;black&quot;, point_size = 1 ) + scale_fill_stepsn( n.breaks = 7 , colors = scales::pal_div_gradient()(seq(0, 1, length.out = 7)) , limits = c(-lmt_tree_height_m_me,lmt_tree_height_m_me) , labels = scales::comma_format(accuracy = 0.1) , show.limits = T ) + facet_grid(cols = vars(depth_maps_generation_filtering_mode)) + labs( x = &quot;software&quot;, y = &quot;Height Mean Error (m)&quot; , subtitle = &quot;posterior predictive distribution of height mean error (m) with 95% HDI\\nby filtering mode&quot; ) + theme_light() + theme( legend.position = &quot;none&quot; , legend.direction = &quot;horizontal&quot; , axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1) , strip.text = element_text(color = &quot;black&quot;, face = &quot;bold&quot;) ) and a table of these 95% HDI values table_temp = draws_temp %&gt;% tidybayes::median_hdi(value) %&gt;% dplyr::select(-c(.point,.interval, .width,.row)) %&gt;% dplyr::arrange(software,depth_maps_generation_filtering_mode) table_temp %&gt;% dplyr::select(-c(software)) %&gt;% kableExtra::kbl( digits = 2 , caption = &quot;Height Mean Error (m)&lt;br&gt;95% HDI of the posterior predictive distribution&quot; , col.names = c( &quot;filtering mode&quot; , &quot;Height Mean Error (m)&lt;br&gt;median&quot; , &quot;HDI low&quot;, &quot;HDI high&quot; ) , escape = F ) %&gt;% kableExtra::kable_styling() %&gt;% kableExtra::pack_rows(index = table(forcats::fct_inorder(table_temp$software))) %&gt;% kableExtra::scroll_box(height = &quot;8in&quot;) Table 7.5: Height Mean Error (m)95% HDI of the posterior predictive distribution filtering mode Height Mean Error (m)median HDI low HDI high METASHAPE aggressive -0.08 -0.51 0.36 moderate -0.01 -0.45 0.42 mild 0.04 -0.40 0.48 disabled 0.06 -0.38 0.50 OPENDRONEMAP aggressive 0.07 -0.37 0.49 moderate 0.13 -0.31 0.55 mild 0.16 -0.27 0.59 disabled 0.19 -0.25 0.61 PIX4D moderate 0.18 -0.25 0.64 mild 0.24 -0.20 0.69 disabled 0.27 -0.17 0.71 7.3.2.6 Software:Quality:Filtering - interaction # get draws fltr_sftwr_draws_temp = tidyr::crossing( depth_maps_generation_quality = unique(ptcld_validation_data$depth_maps_generation_quality) , depth_maps_generation_filtering_mode = unique(ptcld_validation_data$depth_maps_generation_filtering_mode) , software = unique(ptcld_validation_data$software) ) %&gt;% tidybayes::add_epred_draws( brms_ht_me_mod, allow_new_levels = T # this part is crucial , re_formula = ~ (1 | depth_maps_generation_quality) + # main effects (1 | depth_maps_generation_quality) + (1 | depth_maps_generation_filtering_mode) + (1 | software) + # two-way interactions (1 | depth_maps_generation_quality:depth_maps_generation_filtering_mode) + (1 | depth_maps_generation_quality:software) + (1 | depth_maps_generation_filtering_mode:software) + # three-way interactions (1 | depth_maps_generation_quality:depth_maps_generation_filtering_mode:software) ) %&gt;% dplyr::rename(value = .epred) %&gt;% dplyr::mutate(med = tidybayes::median_hdci(value)$y) # plot qlty_fltr_sftwr_ht_me = fltr_sftwr_draws_temp %&gt;% dplyr::inner_join( ptcld_validation_data %&gt;% dplyr::distinct(software, depth_maps_generation_quality, depth_maps_generation_filtering_mode) , by = dplyr::join_by(software, depth_maps_generation_quality, depth_maps_generation_filtering_mode) ) %&gt;% dplyr::mutate(depth_maps_generation_quality = depth_maps_generation_quality %&gt;% forcats::fct_rev()) %&gt;% ggplot( mapping = aes( y = value , x = depth_maps_generation_filtering_mode , fill = med ) ) + geom_hline(yintercept = 0, color = &quot;gray33&quot;) + tidybayes::stat_eye( point_interval = median_hdi, .width = .95 , slab_alpha = 0.98 , interval_color = &quot;black&quot;, linewidth = 1 , point_color = &quot;black&quot;, point_fill = &quot;black&quot;, point_size = 1 ) + scale_fill_stepsn( n.breaks = 7 , colors = scales::pal_div_gradient()(seq(0, 1, length.out = 7)) , limits = c(-lmt_tree_height_m_me,lmt_tree_height_m_me) , labels = scales::comma_format(accuracy = 0.1) , show.limits = T ) + facet_grid( rows = vars(software) , cols = vars(depth_maps_generation_quality) # , switch = &quot;y&quot; ) + labs( x = &quot;filtering mode&quot;, y = &quot;Height Mean Error (m)&quot; , subtitle = &quot;posterior predictive distribution of height mean error (m) with 95% HDI\\nby dense cloud quality and software&quot; # , caption = form_temp ) + theme_light() + theme( legend.position = &quot;none&quot; , legend.direction = &quot;horizontal&quot; , axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1) , strip.text = element_text(color = &quot;black&quot;, face = &quot;bold&quot;) , panel.grid = element_blank() # , strip.placement = &quot;outside&quot; ) + guides( fill = guide_legend(override.aes = list(shape = NA, size = 6, alpha = 0.9, lwd = NA)) ) # print it qlty_fltr_sftwr_ht_me ggplot2::ggsave(&quot;../data/qlty_fltr_sftwr_ht_me.png&quot;, height = 7, width = 10.5) and a table of these 95% HDI values table_temp = fltr_sftwr_draws_temp %&gt;% tidybayes::median_hdi(value) %&gt;% dplyr::inner_join( ptcld_validation_data %&gt;% dplyr::distinct(software, depth_maps_generation_quality, depth_maps_generation_filtering_mode) , by = dplyr::join_by(software, depth_maps_generation_quality, depth_maps_generation_filtering_mode) ) %&gt;% dplyr::mutate(depth_maps_generation_quality = depth_maps_generation_quality %&gt;% forcats::fct_rev()) %&gt;% dplyr::select(c( software, depth_maps_generation_quality, depth_maps_generation_filtering_mode , value, .lower, .upper )) %&gt;% dplyr::ungroup() %&gt;% dplyr::arrange(software, depth_maps_generation_quality, depth_maps_generation_filtering_mode) table_temp %&gt;% # dplyr::select(-c(software)) %&gt;% kableExtra::kbl( digits = 2 , caption = &quot;Height Mean Error (m)&lt;br&gt;95% HDI of the posterior predictive distribution&quot; , col.names = c( &quot;software&quot;, &quot;quality&quot;, &quot;filtering mode&quot; , &quot;Height Mean Error (m)&lt;br&gt;median&quot; , &quot;HDI low&quot;, &quot;HDI high&quot; ) , escape = F ) %&gt;% kableExtra::kable_styling() %&gt;% # kableExtra::pack_rows(index = table(forcats::fct_inorder(table_temp$software))) %&gt;% kableExtra::collapse_rows(columns = 1:2, valign = &quot;top&quot;) %&gt;% kableExtra::scroll_box(height = &quot;8in&quot;) Table 7.6: Height Mean Error (m)95% HDI of the posterior predictive distribution software quality filtering mode Height Mean Error (m)median HDI low HDI high METASHAPE lowest aggressive -0.64 -0.93 -0.34 moderate -0.55 -0.84 -0.25 mild -0.50 -0.79 -0.21 disabled -0.49 -0.78 -0.20 low aggressive -0.32 -0.61 -0.03 moderate -0.26 -0.55 0.04 mild -0.20 -0.50 0.09 disabled -0.16 -0.46 0.13 medium aggressive -0.16 -0.52 0.20 moderate -0.08 -0.45 0.28 mild -0.04 -0.41 0.32 disabled -0.02 -0.39 0.34 high aggressive 0.16 -0.13 0.44 moderate 0.23 -0.07 0.52 mild 0.26 -0.03 0.55 disabled 0.28 -0.01 0.57 ultra high aggressive 0.15 -0.21 0.51 moderate 0.22 -0.15 0.57 mild 0.25 -0.12 0.61 disabled 0.28 -0.09 0.64 OPENDRONEMAP lowest aggressive -0.08 -0.37 0.21 moderate -0.02 -0.31 0.28 mild 0.05 -0.25 0.34 disabled 0.06 -0.23 0.36 low aggressive 0.00 -0.30 0.28 moderate 0.02 -0.27 0.32 mild 0.10 -0.20 0.39 disabled 0.14 -0.16 0.43 medium aggressive 0.15 -0.21 0.51 moderate 0.19 -0.18 0.55 mild 0.25 -0.12 0.61 disabled 0.28 -0.07 0.65 high aggressive 0.16 -0.12 0.45 moderate 0.20 -0.09 0.49 mild 0.25 -0.05 0.54 disabled 0.28 -0.01 0.57 ultra high aggressive 0.29 -0.07 0.65 moderate 0.32 -0.05 0.68 mild 0.37 0.00 0.73 disabled 0.40 0.03 0.76 PIX4D low moderate 0.10 -0.21 0.39 mild 0.15 -0.16 0.44 disabled 0.19 -0.12 0.49 medium moderate 0.33 -0.15 0.81 mild 0.37 -0.10 0.86 disabled 0.41 -0.07 0.90 high moderate 0.36 0.06 0.66 mild 0.40 0.10 0.70 disabled 0.43 0.13 0.73 ultra high moderate 0.40 -0.11 0.88 mild 0.44 -0.08 0.91 disabled 0.47 -0.04 0.96 7.3.3 Model: Height RMSE (precision) Define priors # from Kurz: gamma_a_b_from_omega_sigma = function(mode, sd) { if (mode &lt;= 0) stop(&quot;mode must be &gt; 0&quot;) if (sd &lt;= 0) stop(&quot;sd must be &gt; 0&quot;) rate = (mode + sqrt(mode^2 + 4 * sd^2)) / (2 * sd^2) shape = 1 + mode * rate return(list(shape = shape, rate = rate)) } mean_y_temp = mean(ptcld_validation_data$tree_height_m_rmse, na.rm = T) sd_y_temp = sd(ptcld_validation_data$tree_height_m_rmse, na.rm = T) omega_temp = sd_y_temp / 2 sigma_temp = 2 * sd_y_temp s_r_temp = gamma_a_b_from_omega_sigma(mode = omega_temp, sd = sigma_temp) stanvars_temp = brms::stanvar(mean_y_temp, name = &quot;mean_y&quot;) + brms::stanvar(sd_y_temp, name = &quot;sd_y&quot;) + brms::stanvar(s_r_temp$shape, name = &quot;alpha&quot;) + brms::stanvar(s_r_temp$rate, name = &quot;beta&quot;) 7.3.3.1 Prior distributions #### setting priors # required libraries: tidyverse, tidybayes, brms, palettetown, latex2exp priors_temp &lt;- c( brms::prior(normal(mean_y_temp, sd_y_temp * 5), class = &quot;Intercept&quot;) , brms::prior(gamma(s_r_temp$shape, s_r_temp$rate), class = &quot;sd&quot;) , brms::prior(cauchy(0, sd_y_temp), class = &quot;sigma&quot;) ) # plot plt_prior2 = priors_temp %&gt;% tidybayes::parse_dist() %&gt;% tidybayes::marginalize_lkjcorr(K = 2) %&gt;% tidyr::separate( .args , sep = &quot;,&quot; , into = c(&quot;a&quot;,&quot;b&quot;) , remove = F ) %&gt;% dplyr::mutate( distrib = paste0( class, &quot; ~ &quot; , .dist , &quot;(&quot; , a %&gt;% readr::parse_number() %&gt;% round(2) , &quot;,&quot; , b %&gt;% readr::parse_number() %&gt;% round(2) , &quot;)&quot; ) ) %&gt;% ggplot(., aes(dist = .dist, args = .args)) + facet_grid(cols=vars(distrib), scales = &quot;free&quot;) + ggdist::stat_halfeye( aes(fill = prior), n = 10e2, show.legend = F , fill = &quot;slategray&quot; ) + coord_flip() + theme_light() + theme( strip.text = element_text(face = &quot;bold&quot;, color = &quot;black&quot;), axis.text.y = element_blank(), axis.ticks = element_blank() , axis.text = element_text(size = 6) )+ labs( x = &quot;&quot; , title = &quot;Priors: Height RMSE (precision)&quot; , y = &quot;&quot; ) plt_prior2 7.3.3.2 Fit the model Now fit the model. brms_ht_rmse_mod = brms::brm( formula = tree_height_m_rmse ~ # baseline 1 + # main effects (1 | depth_maps_generation_quality) + (1 | depth_maps_generation_filtering_mode) + (1 | software) + (1 | study_site) + # only fitting main effects of site and not interactions # two-way interactions (1 | depth_maps_generation_quality:depth_maps_generation_filtering_mode) + (1 | depth_maps_generation_quality:software) + (1 | depth_maps_generation_filtering_mode:software) + # three-way interactions (1 | depth_maps_generation_quality:depth_maps_generation_filtering_mode:software) , data = ptcld_validation_data , family = brms::brmsfamily(family = &quot;gaussian&quot;) , iter = 20000, warmup = 10000, chains = 4 , control = list(adapt_delta = 0.999, max_treedepth = 13) , cores = round(parallel::detectCores()/2) , prior = c( brms::prior(normal(mean_y, sd_y * 5), class = &quot;Intercept&quot;) , brms::prior(gamma(alpha, beta), class = &quot;sd&quot;) , brms::prior(cauchy(0, sd_y), class = &quot;sigma&quot;) ) , stanvars = stanvars_temp , file = paste0(rootdir, &quot;/fits/brms_ht_rmse_mod&quot;) ) 7.3.3.3 Quality:Filtering - interaction draws_temp = ptcld_validation_data %&gt;% dplyr::distinct(depth_maps_generation_quality, depth_maps_generation_filtering_mode) %&gt;% tidybayes::add_epred_draws( brms_ht_rmse_mod, allow_new_levels = T # this part is crucial , re_formula = ~ (1 | depth_maps_generation_quality) + (1 | depth_maps_generation_filtering_mode) + (1 | depth_maps_generation_quality:depth_maps_generation_filtering_mode) ) %&gt;% dplyr::rename(value = .epred) %&gt;% dplyr::mutate(med = tidybayes::median_hdci(value)$y) # plot draws_temp %&gt;% dplyr::mutate(depth_maps_generation_quality = depth_maps_generation_quality %&gt;% forcats::fct_rev()) %&gt;% # plot ggplot( mapping = aes( y = value, x = depth_maps_generation_filtering_mode , fill = med ) ) + geom_hline(yintercept = 0, color = &quot;gray33&quot;) + tidybayes::stat_eye( point_interval = median_hdi, .width = .95 , slab_alpha = 0.98 , interval_color = &quot;black&quot;, linewidth = 1 , point_color = &quot;black&quot;, point_fill = &quot;black&quot;, point_size = 1 ) + scale_fill_stepsn( n.breaks = 5 , colors = viridis::mako(n = 5, begin = 0.2, end = 0.9, direction = -1) , limits = c(0,lmt_tree_height_m_rmse) , labels = scales::comma_format(accuracy = 0.01) , show.limits = T ) + facet_grid(cols = vars(depth_maps_generation_quality)) + scale_y_continuous(limits = c(-0.02,NA)) + labs( x = &quot;filtering mode&quot;, y = &quot;Height RMSE (m)&quot; , subtitle = &quot;posterior predictive distribution of height RMSE (m) with 95% HDI\\nby dense cloud quality&quot; ) + theme_light() + theme( legend.position = &quot;none&quot; , legend.direction = &quot;horizontal&quot; , axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1) , strip.text = element_text(color = &quot;black&quot;, face = &quot;bold&quot;) ) and a table of these 95% HDI values table_temp = draws_temp %&gt;% tidybayes::median_hdi(value) %&gt;% dplyr::select(-c(.point,.interval, .width,.row)) %&gt;% dplyr::arrange(depth_maps_generation_quality,depth_maps_generation_filtering_mode) table_temp %&gt;% dplyr::select(-c(depth_maps_generation_quality)) %&gt;% kableExtra::kbl( digits = 2 , caption = &quot;Height RMSE (m)&lt;br&gt;95% HDI of the posterior predictive distribution&quot; , col.names = c( &quot;filtering mode&quot; , &quot;Height RMSE (m)&lt;br&gt;median&quot; , &quot;HDI low&quot;, &quot;HDI high&quot; ) , escape = F ) %&gt;% kableExtra::kable_styling() %&gt;% kableExtra::pack_rows(index = table(forcats::fct_inorder(table_temp$depth_maps_generation_quality))) %&gt;% kableExtra::scroll_box(height = &quot;8in&quot;) Table 7.7: Height RMSE (m)95% HDI of the posterior predictive distribution filtering mode Height RMSE (m)median HDI low HDI high ultra high aggressive 0.81 0.58 1.04 moderate 0.81 0.58 1.04 mild 0.79 0.57 1.03 disabled 0.81 0.59 1.04 high aggressive 0.81 0.57 1.04 moderate 0.80 0.57 1.04 mild 0.79 0.56 1.03 disabled 0.81 0.58 1.04 medium aggressive 0.82 0.58 1.05 moderate 0.81 0.58 1.05 mild 0.80 0.57 1.03 disabled 0.81 0.58 1.05 low aggressive 0.85 0.61 1.08 moderate 0.84 0.61 1.08 mild 0.82 0.59 1.06 disabled 0.83 0.61 1.07 lowest aggressive 0.91 0.68 1.18 moderate 0.90 0.66 1.15 mild 0.88 0.64 1.14 disabled 0.90 0.66 1.15 we can also make pairwise comparisons # first we need to define the contrasts to make contrast_list = tidyr::crossing( x1 = unique(ptcld_validation_data$depth_maps_generation_quality) , x2 = unique(ptcld_validation_data$depth_maps_generation_quality) ) %&gt;% dplyr::mutate( dplyr::across( dplyr::everything() , .fns = function(x){factor( x, ordered = T , levels = levels(ptcld_validation_data$depth_maps_generation_quality) )} ) ) %&gt;% dplyr::filter(x1&lt;x2) %&gt;% dplyr::arrange(x1,x2) %&gt;% dplyr::mutate(dplyr::across(dplyr::everything(), as.character)) %&gt;% purrr::transpose() # make the contrasts using compare_levels brms_contrast_temp = draws_temp %&gt;% tidybayes::compare_levels( value , by = depth_maps_generation_quality , comparison = contrast_list # tidybayes::emmeans_comparison(&quot;revpairwise&quot;) #&quot;pairwise&quot; ) %&gt;% dplyr::rename(contrast = depth_maps_generation_quality) # separate contrast brms_contrast_temp = brms_contrast_temp %&gt;% dplyr::ungroup() %&gt;% tidyr::separate_wider_delim( cols = contrast , delim = &quot; - &quot; , names = paste0( &quot;sorter&quot; , 1:(max(stringr::str_count(brms_contrast_temp$contrast, &quot;-&quot;))+1) ) , too_few = &quot;align_start&quot; , cols_remove = F ) %&gt;% dplyr::filter(sorter1!=sorter2) %&gt;% dplyr::mutate( dplyr::across( tidyselect::starts_with(&quot;sorter&quot;) , .fns = function(x){factor( x, ordered = T , levels = levels(ptcld_validation_data$depth_maps_generation_quality) )} ) , contrast = contrast %&gt;% forcats::fct_reorder( paste0(as.numeric(sorter1), as.numeric(sorter2)) %&gt;% as.numeric() ) , depth_maps_generation_filtering_mode = depth_maps_generation_filtering_mode %&gt;% factor( levels = levels(ptcld_validation_data$depth_maps_generation_filtering_mode) , ordered = T ) ) %&gt;% # median_hdi summary for coloring dplyr::group_by(contrast,depth_maps_generation_filtering_mode) %&gt;% make_contrast_vars() what is this contrast data? # what? brms_contrast_temp %&gt;% dplyr::glimpse() ## Rows: 1,600,000 ## Columns: 19 ## Groups: contrast, depth_maps_generation_filtering_mode [40] ## $ depth_maps_generation_filtering_mode &lt;ord&gt; aggressive, aggressive, aggressiv… ## $ .chain &lt;int&gt; NA, NA, NA, NA, NA, NA, NA, NA, N… ## $ .iteration &lt;int&gt; NA, NA, NA, NA, NA, NA, NA, NA, N… ## $ .draw &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11… ## $ sorter1 &lt;ord&gt; ultra high, ultra high, ultra hig… ## $ sorter2 &lt;ord&gt; high, high, high, high, high, hig… ## $ contrast &lt;fct&gt; ultra high - high, ultra high - h… ## $ value &lt;dbl&gt; 0.0481948853, -0.0268264129, -0.0… ## $ median_hdi_est &lt;dbl&gt; 0.001506739, 0.001506739, 0.00150… ## $ median_hdi_lower &lt;dbl&gt; -0.1064891, -0.1064891, -0.106489… ## $ median_hdi_upper &lt;dbl&gt; 0.1190195, 0.1190195, 0.1190195, … ## $ pr_gt_zero &lt;chr&gt; &quot;51%&quot;, &quot;51%&quot;, &quot;51%&quot;, &quot;51%&quot;, &quot;51%&quot;… ## $ pr_lt_zero &lt;chr&gt; &quot;49%&quot;, &quot;49%&quot;, &quot;49%&quot;, &quot;49%&quot;, &quot;49%&quot;… ## $ is_diff_dir &lt;lgl&gt; TRUE, FALSE, FALSE, TRUE, TRUE, T… ## $ pr_diff &lt;dbl&gt; 0.512925, 0.512925, 0.512925, 0.5… ## $ pr_diff_lab &lt;chr&gt; &quot;Pr(ultra high&gt;high)=51%&quot;, &quot;Pr(ul… ## $ pr_diff_lab_sm &lt;chr&gt; &quot;Pr(&gt;0)=51%&quot;, &quot;Pr(&gt;0)=51%&quot;, &quot;Pr(&gt;… ## $ pr_diff_lab_pos &lt;dbl&gt; 0.127946, 0.127946, 0.127946, 0.1… ## $ sig_level &lt;ord&gt; &lt;80%, &lt;80%, &lt;80%, &lt;80%, &lt;80%, &lt;80… plot it plt_contrast( brms_contrast_temp # , caption_text = form_temp , y_axis_title = &quot;quality&quot; , facet = &quot;depth_maps_generation_filtering_mode&quot; , label_size = 1.9 , x_expand = c(1,0.95) ) + labs( subtitle = &quot;posterior predictive distribution of group constrasts with 95% &amp; 50% HDI\\nby filtering mode&quot; , x = &quot;constrast Height RMSE (m)&quot; ) + theme( axis.text.x = element_text(size = 7) ) ggplot2::ggsave( &quot;../data/qlty_fltr_comp_ht_rmse.png&quot; , plot = ggplot2::last_plot() + labs(subtitle = &quot;&quot;) , height = 7, width = 10.5 ) and summarize these contrasts brms_contrast_temp %&gt;% dplyr::group_by(contrast, depth_maps_generation_filtering_mode, pr_lt_zero) %&gt;% tidybayes::median_hdi(value) %&gt;% dplyr::arrange(contrast, depth_maps_generation_filtering_mode) %&gt;% dplyr::select(contrast, depth_maps_generation_filtering_mode, value, .lower, .upper, pr_lt_zero) %&gt;% kableExtra::kbl( digits = 2 , caption = &quot;Height RMSE (m)&lt;br&gt;95% HDI of the posterior predictive distribution of group contrasts&quot; , col.names = c( &quot;quality contrast&quot; , &quot;filtering mode&quot; , &quot;median difference&lt;br&gt;Height RMSE (m)&quot; , &quot;HDI low&quot;, &quot;HDI high&quot; , &quot;Pr(diff&lt;0)&quot; ) , escape = F ) %&gt;% kableExtra::kable_styling() %&gt;% kableExtra::scroll_box(height = &quot;8in&quot;) Table 7.8: Height RMSE (m)95% HDI of the posterior predictive distribution of group contrasts quality contrast filtering mode median differenceHeight RMSE (m) HDI low HDI high Pr(diff&lt;0) ultra high - high aggressive 0.00 -0.11 0.12 49% ultra high - high moderate 0.00 -0.11 0.12 47% ultra high - high mild 0.00 -0.11 0.11 50% ultra high - high disabled 0.00 -0.11 0.12 48% ultra high - medium aggressive 0.00 -0.11 0.11 54% ultra high - medium moderate 0.00 -0.11 0.11 52% ultra high - medium mild 0.00 -0.11 0.11 51% ultra high - medium disabled 0.00 -0.11 0.11 51% ultra high - low aggressive -0.03 -0.16 0.07 74% ultra high - low moderate -0.04 -0.16 0.07 76% ultra high - low mild -0.03 -0.15 0.08 69% ultra high - low disabled -0.02 -0.14 0.09 65% ultra high - lowest aggressive -0.10 -0.25 0.04 91% ultra high - lowest moderate -0.09 -0.25 0.04 90% ultra high - lowest mild -0.08 -0.24 0.05 86% ultra high - lowest disabled -0.09 -0.24 0.04 89% high - medium aggressive -0.01 -0.12 0.11 55% high - medium moderate -0.01 -0.12 0.10 56% high - medium mild 0.00 -0.12 0.11 51% high - medium disabled 0.00 -0.12 0.11 53% high - low aggressive -0.03 -0.16 0.07 75% high - low moderate -0.04 -0.16 0.06 78% high - low mild -0.03 -0.14 0.08 70% high - low disabled -0.02 -0.14 0.08 68% high - lowest aggressive -0.10 -0.26 0.03 92% high - lowest moderate -0.10 -0.25 0.04 91% high - lowest mild -0.08 -0.24 0.06 85% high - lowest disabled -0.09 -0.25 0.04 89% medium - low aggressive -0.03 -0.15 0.08 70% medium - low moderate -0.03 -0.15 0.07 74% medium - low mild -0.02 -0.15 0.08 69% medium - low disabled -0.02 -0.14 0.09 65% medium - lowest aggressive -0.09 -0.24 0.04 90% medium - lowest moderate -0.09 -0.24 0.04 89% medium - lowest mild -0.08 -0.24 0.05 86% medium - lowest disabled -0.09 -0.24 0.05 89% low - lowest aggressive -0.06 -0.21 0.06 84% low - lowest moderate -0.05 -0.20 0.07 80% low - lowest mild -0.05 -0.20 0.07 79% low - lowest disabled -0.06 -0.21 0.05 85% 7.3.3.4 Software:Quality - interaction draws_temp = tidyr::crossing( depth_maps_generation_quality = unique(ptcld_validation_data$depth_maps_generation_quality) , software = unique(ptcld_validation_data$software) ) %&gt;% tidybayes::add_epred_draws( brms_ht_rmse_mod, allow_new_levels = T # this part is crucial , re_formula = ~ (1 | depth_maps_generation_quality) + (1 | software) + (1 | depth_maps_generation_quality:software) ) %&gt;% dplyr::rename(value = .epred) %&gt;% dplyr::mutate(med = tidybayes::median_hdci(value)$y) # plot draws_temp %&gt;% # remove out-of-sample obs dplyr::inner_join( ptcld_validation_data %&gt;% dplyr::distinct(depth_maps_generation_quality, software) , by = dplyr::join_by(depth_maps_generation_quality, software) ) %&gt;% dplyr::mutate(depth_maps_generation_quality = depth_maps_generation_quality %&gt;% forcats::fct_rev()) %&gt;% # plot ggplot( mapping = aes( y = value, x = software , fill = med ) ) + geom_hline(yintercept = 0, color = &quot;gray33&quot;) + tidybayes::stat_eye( point_interval = median_hdi, .width = .95 , slab_alpha = 0.98 , interval_color = &quot;black&quot;, linewidth = 1 , point_color = &quot;black&quot;, point_fill = &quot;black&quot;, point_size = 1 ) + scale_fill_stepsn( n.breaks = 5 , colors = viridis::mako(n = 5, begin = 0.2, end = 0.9, direction = -1) , limits = c(0,lmt_tree_height_m_rmse) , labels = scales::comma_format(accuracy = 0.01) , show.limits = T ) + facet_grid(cols = vars(depth_maps_generation_quality)) + scale_y_continuous(limits = c(-0.02,NA)) + labs( x = &quot;software&quot;, y = &quot;Height RMSE (m)&quot; , subtitle = &quot;posterior predictive distribution of height RMSE (m) with 95% HDI\\nby dense cloud quality&quot; ) + theme_light() + theme( legend.position = &quot;none&quot; , legend.direction = &quot;horizontal&quot; , axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1) , strip.text = element_text(color = &quot;black&quot;, face = &quot;bold&quot;) ) and a table of these 95% HDI values table_temp = draws_temp %&gt;% tidybayes::median_hdi(value) %&gt;% # remove out-of-sample obs dplyr::inner_join( ptcld_validation_data %&gt;% dplyr::distinct(depth_maps_generation_quality, software) , by = dplyr::join_by(depth_maps_generation_quality, software) ) %&gt;% dplyr::select(-c(.point,.interval, .width,.row)) %&gt;% dplyr::arrange(software,depth_maps_generation_quality) table_temp %&gt;% dplyr::select(-c(software)) %&gt;% kableExtra::kbl( digits = 2 , caption = &quot;Height RMSE (m)&lt;br&gt;95% HDI of the posterior predictive distribution&quot; , col.names = c( &quot;quality&quot; , &quot;Height RMSE (m)&lt;br&gt;median&quot; , &quot;HDI low&quot;, &quot;HDI high&quot; ) , escape = F ) %&gt;% kableExtra::kable_styling() %&gt;% kableExtra::pack_rows(index = table(forcats::fct_inorder(table_temp$software))) %&gt;% kableExtra::scroll_box(height = &quot;8in&quot;) Table 7.9: Height RMSE (m)95% HDI of the posterior predictive distribution quality Height RMSE (m)median HDI low HDI high METASHAPE ultra high 0.79 0.61 0.96 high 0.77 0.59 0.95 medium 0.78 0.60 0.95 low 0.90 0.73 1.08 lowest 1.06 0.88 1.24 OPENDRONEMAP ultra high 0.78 0.60 0.96 high 0.80 0.62 0.98 medium 0.83 0.65 1.01 low 0.81 0.63 0.99 lowest 0.84 0.66 1.02 PIX4D ultra high 0.81 0.64 1.00 high 0.80 0.62 0.98 medium 0.78 0.61 0.97 low 0.81 0.64 0.99 we can also make pairwise comparisons # calculate contrast brms_contrast_temp = draws_temp %&gt;% tidybayes::compare_levels( value , by = depth_maps_generation_quality , comparison = contrast_list ) %&gt;% dplyr::rename(contrast = depth_maps_generation_quality) # separate contrast brms_contrast_temp = brms_contrast_temp %&gt;% dplyr::ungroup() %&gt;% tidyr::separate_wider_delim( cols = contrast , delim = &quot; - &quot; , names = paste0( &quot;sorter&quot; , 1:(max(stringr::str_count(brms_contrast_temp$contrast, &quot;-&quot;))+1) ) , too_few = &quot;align_start&quot; , cols_remove = F ) %&gt;% dplyr::filter(sorter1!=sorter2) %&gt;% dplyr::mutate( dplyr::across( tidyselect::starts_with(&quot;sorter&quot;) , .fns = function(x){factor( x, ordered = T , levels = levels(ptcld_validation_data$depth_maps_generation_quality) )} ) , contrast = contrast %&gt;% forcats::fct_reorder( paste0(as.numeric(sorter1), as.numeric(sorter2)) %&gt;% as.numeric() ) ) %&gt;% # median_hdi summary for coloring dplyr::group_by(contrast, software) %&gt;% make_contrast_vars() # remove out-of-sample obs brms_contrast_temp = brms_contrast_temp %&gt;% dplyr::inner_join( ptcld_validation_data %&gt;% dplyr::distinct(software, depth_maps_generation_quality) , by = dplyr::join_by(software, sorter1 == depth_maps_generation_quality) ) %&gt;% dplyr::inner_join( ptcld_validation_data %&gt;% dplyr::distinct(software, depth_maps_generation_quality) , by = dplyr::join_by(software, sorter2 == depth_maps_generation_quality) ) plot it plt_contrast( brms_contrast_temp # , caption_text = form_temp , y_axis_title = &quot;quality&quot; , facet = &quot;software&quot; , label_size = 1.9 , x_expand = c(0.83,0.82) ) + labs( subtitle = &quot;posterior predictive distribution of group constrasts with 95% &amp; 50% HDI\\nby software&quot; , x = &quot;constrast Height RMSE (m)&quot; ) ggplot2::ggsave( &quot;../data/qlty_sftwr_comp_ht_rmse.png&quot; , plot = ggplot2::last_plot() + labs(subtitle = &quot;&quot;) , height = 7, width = 10.5 ) create plot for combining with other RMSE contrasts for publication ptchwrk_qlty_sftwr_comp_ht_rmse = plt_contrast( brms_contrast_temp , y_axis_title = &quot;quality contrast&quot; , facet = &quot;software&quot; , label_size = 1.5 , label = &quot;pr_diff_lab_sm&quot; , annotate_size = 1.6 ) + labs( subtitle = &quot;&quot; # &quot;constrast Height RMSE (m)&quot; , x = &quot;Height RMSE (m) constrast&quot; ) + theme( legend.position=&quot;none&quot; , axis.title.y = element_text(size = 10, face = &quot;bold&quot;) , axis.title.x = element_text(size = 8) ) # ptchwrk_qlty_sftwr_comp_ht_rmse and summarize these contrasts table_temp = brms_contrast_temp %&gt;% dplyr::group_by(contrast, software, pr_lt_zero) %&gt;% tidybayes::median_hdi(value) %&gt;% dplyr::arrange(contrast, software) %&gt;% dplyr::select(contrast, software, value, .lower, .upper, pr_lt_zero) %&gt;% dplyr::arrange(software, contrast) table_temp %&gt;% dplyr::select(-c(software)) %&gt;% kableExtra::kbl( digits = 2 , caption = &quot;Height RMSE (m)&lt;br&gt;95% HDI of the posterior predictive distribution of group contrasts&quot; , col.names = c( &quot;quality contrast&quot; , &quot;median difference&lt;br&gt;Height RMSE (m)&quot; , &quot;HDI low&quot;, &quot;HDI high&quot; , &quot;Pr(diff&lt;0)&quot; ) , escape = F ) %&gt;% kableExtra::kable_styling() %&gt;% kableExtra::pack_rows(index = table(forcats::fct_inorder(table_temp$software))) %&gt;% kableExtra::scroll_box(height = &quot;8in&quot;) Table 7.10: Height RMSE (m)95% HDI of the posterior predictive distribution of group contrasts quality contrast median differenceHeight RMSE (m) HDI low HDI high Pr(diff&lt;0) METASHAPE ultra high - high 0.02 -0.06 0.09 33% ultra high - medium 0.01 -0.07 0.09 40% ultra high - low -0.12 -0.20 -0.04 100% ultra high - lowest -0.28 -0.36 -0.19 100% high - medium -0.01 -0.09 0.07 57% high - low -0.13 -0.21 -0.05 100% high - lowest -0.29 -0.38 -0.21 100% medium - low -0.13 -0.21 -0.05 100% medium - lowest -0.29 -0.37 -0.20 100% low - lowest -0.16 -0.24 -0.08 100% OPENDRONEMAP ultra high - high -0.02 -0.10 0.06 67% ultra high - medium -0.05 -0.13 0.03 91% ultra high - low -0.03 -0.11 0.05 76% ultra high - lowest -0.06 -0.15 0.02 94% high - medium -0.04 -0.11 0.04 81% high - low -0.01 -0.09 0.07 61% high - lowest -0.05 -0.13 0.04 86% medium - low 0.02 -0.06 0.10 27% medium - lowest -0.01 -0.09 0.07 60% low - lowest -0.04 -0.12 0.04 81% PIX4D ultra high - high 0.01 -0.07 0.10 38% ultra high - medium 0.03 -0.06 0.12 24% ultra high - low 0.00 -0.09 0.09 50% high - medium 0.02 -0.07 0.11 34% high - low -0.01 -0.10 0.08 62% medium - low -0.03 -0.12 0.06 76% The contrasts above address the question “are there differences in RMSE based on dense point cloud generation quality within each software?”. To address the different question of “are there differences in RMSE based on the processing software used at a given dense point cloud generation quality?” we need to utilize a different formulation of the comparison parameter within our call to the tidybayes::compare_levels function and calculate the contrast by software instead # calculate contrast brms_contrast_temp = draws_temp %&gt;% tidybayes::compare_levels( value , by = software , comparison = &quot;pairwise&quot; ) %&gt;% dplyr::rename(contrast = software) %&gt;% # median_hdi summary for coloring dplyr::group_by(contrast, depth_maps_generation_quality) %&gt;% make_contrast_vars() # remove out-of-sample obs brms_contrast_temp = brms_contrast_temp %&gt;% tidyr::separate_wider_delim( cols = contrast , delim = &quot; - &quot; , names = paste0( &quot;sorter&quot; , 1:(max(stringr::str_count(brms_contrast_temp$contrast, &quot;-&quot;))+1) ) , too_few = &quot;align_start&quot; , cols_remove = F ) %&gt;% dplyr::filter(sorter1!=sorter2) %&gt;% dplyr::inner_join( ptcld_validation_data %&gt;% dplyr::distinct(software, depth_maps_generation_quality) , by = dplyr::join_by(sorter1 == software, depth_maps_generation_quality) ) %&gt;% dplyr::inner_join( ptcld_validation_data %&gt;% dplyr::distinct(software, depth_maps_generation_quality) , by = dplyr::join_by(sorter2 == software, depth_maps_generation_quality) ) plot it plt_contrast( brms_contrast_temp # , caption_text = form_temp , y_axis_title = &quot;software&quot; , facet = &quot;depth_maps_generation_quality&quot; , label_size = 1.9 , x_expand = c(0.25,0.1) ) + facet_wrap(facets = vars(depth_maps_generation_quality), ncol = 2) + labs( subtitle = &quot;posterior predictive distribution of group constrasts with 95% &amp; 50% HDI\\nby dense cloud quality&quot; , x = &quot;constrast Height RMSE (m)&quot; ) + theme( legend.position = c(.75, .13) ) + guides(fill = guide_colorbar(theme = theme( legend.key.width = unit(1, &quot;lines&quot;), legend.key.height = unit(7, &quot;lines&quot;) ))) ggplot2::ggsave( &quot;../data/sftwr_qlty_comp_ht_rmse.png&quot; , plot = ggplot2::last_plot() + labs(subtitle = &quot;&quot;) , height = 7, width = 10.5 ) create plot for combining with other RMSE contrasts for publication ptchwrk_sftwr_qlty_comp_ht_rmse = plt_contrast( brms_contrast_temp , y_axis_title = &quot;software contrast&quot; , facet = &quot;depth_maps_generation_quality&quot; , label_size = 1.7 , label = &quot;pr_diff_lab_sm&quot; , annotate_size = 1.8 ) + facet_wrap(facets = vars(depth_maps_generation_quality), ncol = 3) + labs( subtitle = &quot;&quot; , x = &quot;Height RMSE (m) constrast&quot; ) + theme( legend.position = &quot;inside&quot; , legend.position.inside = c(.8, .10) , axis.title.y = element_text(size = 10, face = &quot;bold&quot;) , axis.title.x = element_text(size = 8) ) + guides(fill = guide_colorbar(theme = theme( legend.key.width = unit(1, &quot;lines&quot;), legend.key.height = unit(6.5, &quot;lines&quot;) ))) # ptchwrk_sftwr_qlty_comp_ht_rmse and summarize these contrasts table_temp = brms_contrast_temp %&gt;% dplyr::group_by(contrast, depth_maps_generation_quality, pr_lt_zero) %&gt;% tidybayes::median_hdi(value) %&gt;% dplyr::arrange(contrast, depth_maps_generation_quality) %&gt;% dplyr::select(contrast, depth_maps_generation_quality, value, .lower, .upper, pr_lt_zero) table_temp %&gt;% dplyr::select(-c(contrast)) %&gt;% kableExtra::kbl( digits = 2 , caption = &quot;Height RMSE (m)&lt;br&gt;95% HDI of the posterior predictive distribution of group contrasts&quot; , col.names = c( &quot;quality&quot; , &quot;median difference&lt;br&gt;Height RMSE (m)&quot; , &quot;HDI low&quot;, &quot;HDI high&quot; , &quot;Pr(diff&lt;0)&quot; ) , escape = F ) %&gt;% kableExtra::kable_styling() %&gt;% kableExtra::pack_rows(index = table(forcats::fct_inorder(table_temp$contrast))) %&gt;% kableExtra::scroll_box(height = &quot;8in&quot;) Table 7.11: Height RMSE (m)95% HDI of the posterior predictive distribution of group contrasts quality median differenceHeight RMSE (m) HDI low HDI high Pr(diff&lt;0) OPENDRONEMAP - METASHAPE ultra high -0.01 -0.09 0.08 57% high 0.03 -0.05 0.11 25% medium 0.06 -0.03 0.14 9% low -0.09 -0.18 -0.01 99% lowest -0.22 -0.31 -0.13 100% PIX4D - METASHAPE ultra high 0.03 -0.06 0.12 26% high 0.03 -0.05 0.12 23% medium 0.01 -0.08 0.10 44% low -0.09 -0.18 0.01 97% PIX4D - OPENDRONEMAP ultra high 0.04 -0.05 0.13 21% high 0.00 -0.08 0.09 46% medium -0.05 -0.14 0.04 87% low 0.01 -0.08 0.10 44% 7.3.3.5 Software:Filtering - interaction draws_temp = tidyr::crossing( depth_maps_generation_filtering_mode = unique(ptcld_validation_data$depth_maps_generation_filtering_mode) , software = unique(ptcld_validation_data$software) ) %&gt;% tidybayes::add_epred_draws( brms_ht_rmse_mod, allow_new_levels = T # this part is crucial , re_formula = ~ (1 | depth_maps_generation_filtering_mode) + (1 | software) + (1 | depth_maps_generation_filtering_mode:software) ) %&gt;% dplyr::rename(value = .epred) %&gt;% dplyr::mutate(med = tidybayes::median_hdci(value)$y) # plot draws_temp %&gt;% # remove out-of-sample obs dplyr::inner_join( ptcld_validation_data %&gt;% dplyr::distinct(depth_maps_generation_filtering_mode, software) , by = dplyr::join_by(depth_maps_generation_filtering_mode, software) ) %&gt;% # plot ggplot( mapping = aes( y = value, x = software , fill = med ) ) + geom_hline(yintercept = 0, color = &quot;gray33&quot;) + tidybayes::stat_eye( point_interval = median_hdi, .width = .95 , slab_alpha = 0.98 , interval_color = &quot;black&quot;, linewidth = 1 , point_color = &quot;black&quot;, point_fill = &quot;black&quot;, point_size = 1 ) + scale_fill_stepsn( n.breaks = 5 , colors = viridis::mako(n = 5, begin = 0.2, end = 0.9, direction = -1) , limits = c(0,lmt_tree_height_m_rmse) , labels = scales::comma_format(accuracy = 0.01) , show.limits = T ) + facet_grid(cols = vars(depth_maps_generation_filtering_mode)) + scale_y_continuous(limits = c(-0.02,NA)) + labs( x = &quot;software&quot;, y = &quot;Height RMSE (m)&quot; , subtitle = &quot;posterior predictive distribution of height RMSE (m) with 95% HDI\\nby filtering mode&quot; ) + theme_light() + theme( legend.position = &quot;none&quot; , legend.direction = &quot;horizontal&quot; , axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1) , strip.text = element_text(color = &quot;black&quot;, face = &quot;bold&quot;) ) and a table of these 95% HDI values table_temp = draws_temp %&gt;% tidybayes::median_hdi(value) %&gt;% dplyr::select(-c(.point,.interval, .width,.row)) %&gt;% dplyr::arrange(software,depth_maps_generation_filtering_mode) table_temp %&gt;% dplyr::select(-c(software)) %&gt;% kableExtra::kbl( digits = 2 , caption = &quot;Height RMSE (m)&lt;br&gt;95% HDI of the posterior predictive distribution&quot; , col.names = c( &quot;filtering mode&quot; , &quot;Height RMSE (m)&lt;br&gt;median&quot; , &quot;HDI low&quot;, &quot;HDI high&quot; ) , escape = F ) %&gt;% kableExtra::kable_styling() %&gt;% kableExtra::pack_rows(index = table(forcats::fct_inorder(table_temp$software))) %&gt;% kableExtra::scroll_box(height = &quot;8in&quot;) Table 7.12: Height RMSE (m)95% HDI of the posterior predictive distribution filtering mode Height RMSE (m)median HDI low HDI high METASHAPE aggressive 0.88 0.68 1.07 moderate 0.85 0.66 1.05 mild 0.83 0.64 1.03 disabled 0.84 0.65 1.05 OPENDRONEMAP aggressive 0.82 0.62 1.01 moderate 0.82 0.62 1.02 mild 0.80 0.61 1.00 disabled 0.83 0.63 1.03 PIX4D aggressive 0.83 0.63 1.04 moderate 0.83 0.63 1.02 mild 0.81 0.61 1.01 disabled 0.83 0.63 1.03 we can also make pairwise comparisons # calculate contrast brms_contrast_temp = draws_temp %&gt;% tidybayes::compare_levels( value , by = depth_maps_generation_filtering_mode , comparison = &quot;pairwise&quot; ) %&gt;% dplyr::rename(contrast = depth_maps_generation_filtering_mode) # separate contrast brms_contrast_temp = brms_contrast_temp %&gt;% dplyr::ungroup() %&gt;% tidyr::separate_wider_delim( cols = contrast , delim = &quot; - &quot; , names = paste0( &quot;sorter&quot; , 1:(max(stringr::str_count(brms_contrast_temp$contrast, &quot;-&quot;))+1) ) , too_few = &quot;align_start&quot; , cols_remove = F ) %&gt;% dplyr::filter(sorter1!=sorter2) %&gt;% dplyr::mutate( dplyr::across( tidyselect::starts_with(&quot;sorter&quot;) , .fns = function(x){factor( x, ordered = T , levels = levels(ptcld_validation_data$depth_maps_generation_filtering_mode) )} ) , contrast = contrast %&gt;% forcats::fct_reorder( paste0(as.numeric(sorter1), as.numeric(sorter2)) %&gt;% as.numeric() ) %&gt;% # re order for filtering mode forcats::fct_rev() ) %&gt;% # median_hdi summary for coloring dplyr::group_by(contrast, software) %&gt;% make_contrast_vars() # remove out-of-sample obs brms_contrast_temp = brms_contrast_temp %&gt;% dplyr::inner_join( ptcld_validation_data %&gt;% dplyr::distinct(software, depth_maps_generation_filtering_mode) , by = dplyr::join_by(software, sorter1 == depth_maps_generation_filtering_mode) ) %&gt;% dplyr::inner_join( ptcld_validation_data %&gt;% dplyr::distinct(software, depth_maps_generation_filtering_mode) , by = dplyr::join_by(software, sorter2 == depth_maps_generation_filtering_mode) ) plot it plt_contrast( brms_contrast_temp # , caption_text = form_temp , y_axis_title = &quot;filtering mode&quot; , facet = &quot;software&quot; , label_size = 1.9 , x_expand = c(0.6,0.45) ) + labs( subtitle = &quot;posterior predictive distribution of group constrasts with 95% &amp; 50% HDI\\nby software&quot; , x = &quot;constrast Height RMSE (m)&quot; ) ggplot2::ggsave( &quot;../data/fltr_sftwr_comp_ht_rmse.png&quot; , plot = ggplot2::last_plot() + labs(subtitle = &quot;&quot;) , height = 7, width = 10.5 ) create plot for combining with other RMSE contrasts for publication ptchwrk_fltr_sftwr_comp_ht_rmse = plt_contrast( brms_contrast_temp , y_axis_title = &quot;filtering mode contrast&quot; , facet = &quot;software&quot; , label_size = 1.7 , label = &quot;pr_diff_lab_sm&quot; , annotate_size = 1.6 ) + labs( subtitle = &quot;&quot; # &quot;constrast Height RMSE (m)&quot; , x = &quot;Height RMSE (m) constrast&quot; ) + theme( legend.position=&quot;none&quot; , axis.title.y = element_text(size = 10, face = &quot;bold&quot;) , axis.title.x = element_text(size = 8) ) # ptchwrk_fltr_sftwr_comp_ht_rmse and summarize these contrasts table_temp = brms_contrast_temp %&gt;% dplyr::group_by(contrast, software, pr_lt_zero) %&gt;% tidybayes::median_hdi(value) %&gt;% dplyr::arrange(contrast, software) %&gt;% dplyr::select(contrast, software, value, .lower, .upper, pr_lt_zero) %&gt;% dplyr::arrange(software, contrast) table_temp %&gt;% dplyr::select(-c(software)) %&gt;% kableExtra::kbl( digits = 2 , caption = &quot;Height RMSE (m)&lt;br&gt;95% HDI of the posterior predictive distribution of group contrasts&quot; , col.names = c( &quot;filtering contrast&quot; , &quot;median difference&lt;br&gt;Height RMSE (m)&quot; , &quot;HDI low&quot;, &quot;HDI high&quot; , &quot;Pr(diff&lt;0)&quot; ) , escape = F ) %&gt;% kableExtra::kable_styling() %&gt;% kableExtra::pack_rows(index = table(forcats::fct_inorder(table_temp$software))) %&gt;% kableExtra::scroll_box(height = &quot;8in&quot;) Table 7.13: Height RMSE (m)95% HDI of the posterior predictive distribution of group contrasts filtering contrast median differenceHeight RMSE (m) HDI low HDI high Pr(diff&lt;0) METASHAPE disabled - mild 0.01 -0.04 0.07 30% disabled - moderate -0.01 -0.06 0.05 60% disabled - aggressive -0.03 -0.10 0.03 84% mild - moderate -0.02 -0.08 0.03 78% mild - aggressive -0.04 -0.11 0.01 93% moderate - aggressive -0.02 -0.09 0.03 79% OPENDRONEMAP disabled - mild 0.03 -0.03 0.09 15% disabled - moderate 0.01 -0.04 0.07 34% disabled - aggressive 0.01 -0.04 0.08 32% mild - moderate -0.02 -0.07 0.04 73% mild - aggressive -0.01 -0.07 0.05 68% moderate - aggressive 0.00 -0.05 0.06 46% PIX4D disabled - mild 0.02 -0.04 0.08 24% disabled - moderate 0.00 -0.06 0.06 47% mild - moderate -0.02 -0.08 0.04 74% 7.3.3.6 Software:Quality:Filtering - interaction # get draws fltr_sftwr_draws_temp = tidyr::crossing( depth_maps_generation_quality = unique(ptcld_validation_data$depth_maps_generation_quality) , depth_maps_generation_filtering_mode = unique(ptcld_validation_data$depth_maps_generation_filtering_mode) , software = unique(ptcld_validation_data$software) ) %&gt;% tidybayes::add_epred_draws( brms_ht_rmse_mod, allow_new_levels = T # this part is crucial , re_formula = ~ (1 | depth_maps_generation_quality) + # main effects (1 | depth_maps_generation_quality) + (1 | depth_maps_generation_filtering_mode) + (1 | software) + # two-way interactions (1 | depth_maps_generation_quality:depth_maps_generation_filtering_mode) + (1 | depth_maps_generation_quality:software) + (1 | depth_maps_generation_filtering_mode:software) + # three-way interactions (1 | depth_maps_generation_quality:depth_maps_generation_filtering_mode:software) ) %&gt;% dplyr::rename(value = .epred) %&gt;% dplyr::mutate(med = tidybayes::median_hdci(value)$y) # plot qlty_fltr_sftwr_ht_rmse = fltr_sftwr_draws_temp %&gt;% dplyr::inner_join( ptcld_validation_data %&gt;% dplyr::distinct(software, depth_maps_generation_quality, depth_maps_generation_filtering_mode) , by = dplyr::join_by(software, depth_maps_generation_quality, depth_maps_generation_filtering_mode) ) %&gt;% dplyr::mutate(depth_maps_generation_quality = depth_maps_generation_quality %&gt;% forcats::fct_rev()) %&gt;% ggplot( mapping = aes( y = value , x = depth_maps_generation_filtering_mode , fill = med ) ) + geom_hline(yintercept = 0, color = &quot;gray33&quot;) + tidybayes::stat_eye( point_interval = median_hdi, .width = .95 , slab_alpha = 0.98 , interval_color = &quot;black&quot;, linewidth = 1 , point_color = &quot;black&quot;, point_fill = &quot;black&quot;, point_size = 1 ) + scale_fill_stepsn( n.breaks = 5 , colors = viridis::mako(n = 5, begin = 0.2, end = 0.9, direction = -1) , limits = c(0,lmt_tree_height_m_rmse) , labels = scales::comma_format(accuracy = 0.01) , show.limits = T ) + facet_grid( rows = vars(software) , cols = vars(depth_maps_generation_quality) # , switch = &quot;y&quot; ) + scale_y_continuous(limits = c(-0.02,NA)) + labs( x = &quot;filtering mode&quot;, y = &quot;Height RMSE (m)&quot; , subtitle = &quot;posterior predictive distribution of height RMSE (m) with 95% HDI\\nby dense cloud quality and software&quot; # , caption = form_temp ) + theme_light() + theme( legend.position = &quot;none&quot; , legend.direction = &quot;horizontal&quot; , axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1) , strip.text = element_text(color = &quot;black&quot;, face = &quot;bold&quot;) , panel.grid = element_blank() # , strip.placement = &quot;outside&quot; ) + guides( fill = guide_legend(override.aes = list(shape = NA, size = 6, alpha = 0.9, lwd = NA)) ) # print it qlty_fltr_sftwr_ht_rmse ggplot2::ggsave(&quot;../data/qlty_fltr_sftwr_ht_rmse.png&quot;, height = 7, width = 10.5) and a table of these 95% HDI values table_temp = fltr_sftwr_draws_temp %&gt;% tidybayes::median_hdi(value) %&gt;% dplyr::inner_join( ptcld_validation_data %&gt;% dplyr::distinct(software, depth_maps_generation_quality, depth_maps_generation_filtering_mode) , by = dplyr::join_by(software, depth_maps_generation_quality, depth_maps_generation_filtering_mode) ) %&gt;% dplyr::mutate(depth_maps_generation_quality = depth_maps_generation_quality %&gt;% forcats::fct_rev()) %&gt;% dplyr::select(c( software, depth_maps_generation_quality, depth_maps_generation_filtering_mode , value, .lower, .upper )) %&gt;% dplyr::ungroup() %&gt;% dplyr::arrange(software, depth_maps_generation_quality, depth_maps_generation_filtering_mode) table_temp %&gt;% # dplyr::select(-c(software)) %&gt;% kableExtra::kbl( digits = 2 , caption = &quot;Height RMSE (m)&lt;br&gt;95% HDI of the posterior predictive distribution&quot; , col.names = c( &quot;software&quot;, &quot;quality&quot;, &quot;filtering mode&quot; , &quot;Height RMSE (m)&lt;br&gt;median&quot; , &quot;HDI low&quot;, &quot;HDI high&quot; ) , escape = F ) %&gt;% kableExtra::kable_styling() %&gt;% # kableExtra::pack_rows(index = table(forcats::fct_inorder(table_temp$software))) %&gt;% kableExtra::collapse_rows(columns = 1:2, valign = &quot;top&quot;) %&gt;% kableExtra::scroll_box(height = &quot;8in&quot;) Table 7.14: Height RMSE (m)95% HDI of the posterior predictive distribution software quality filtering mode Height RMSE (m)median HDI low HDI high METASHAPE lowest aggressive 1.10 0.93 1.28 moderate 1.07 0.90 1.24 mild 1.04 0.86 1.21 disabled 1.06 0.89 1.23 low aggressive 0.93 0.76 1.11 moderate 0.91 0.75 1.09 mild 0.88 0.71 1.05 disabled 0.89 0.72 1.06 medium aggressive 0.80 0.63 0.98 moderate 0.78 0.61 0.95 mild 0.76 0.58 0.92 disabled 0.77 0.60 0.94 high aggressive 0.79 0.62 0.96 moderate 0.77 0.60 0.94 mild 0.75 0.58 0.92 disabled 0.77 0.60 0.94 ultra high aggressive 0.81 0.64 0.98 moderate 0.79 0.62 0.96 mild 0.77 0.60 0.94 disabled 0.78 0.62 0.96 OPENDRONEMAP lowest aggressive 0.85 0.68 1.02 moderate 0.85 0.68 1.03 mild 0.82 0.64 0.99 disabled 0.86 0.69 1.03 low aggressive 0.81 0.64 0.98 moderate 0.82 0.65 0.99 mild 0.79 0.62 0.97 disabled 0.82 0.65 0.99 medium aggressive 0.83 0.66 1.00 moderate 0.83 0.65 0.99 mild 0.82 0.65 0.99 disabled 0.85 0.68 1.02 high aggressive 0.79 0.62 0.96 moderate 0.79 0.63 0.97 mild 0.79 0.62 0.96 disabled 0.81 0.64 0.98 ultra high aggressive 0.77 0.61 0.95 moderate 0.78 0.61 0.95 mild 0.77 0.60 0.94 disabled 0.80 0.62 0.96 PIX4D low moderate 0.83 0.66 1.00 mild 0.79 0.63 0.97 disabled 0.81 0.64 0.98 medium moderate 0.78 0.61 0.96 mild 0.77 0.60 0.94 disabled 0.79 0.62 0.96 high moderate 0.80 0.62 0.97 mild 0.79 0.62 0.96 disabled 0.81 0.64 0.99 ultra high moderate 0.81 0.65 0.99 mild 0.80 0.63 0.97 disabled 0.82 0.65 0.99 we can also make pairwise comparisons # calculate contrast brms_contrast_temp = fltr_sftwr_draws_temp %&gt;% tidybayes::compare_levels( value , by = depth_maps_generation_filtering_mode , comparison = &quot;pairwise&quot; ) %&gt;% dplyr::rename(contrast = depth_maps_generation_filtering_mode) # separate contrast brms_contrast_temp = brms_contrast_temp %&gt;% dplyr::ungroup() %&gt;% tidyr::separate_wider_delim( cols = contrast , delim = &quot; - &quot; , names = paste0( &quot;sorter&quot; , 1:(max(stringr::str_count(brms_contrast_temp$contrast, &quot;-&quot;))+1) ) , too_few = &quot;align_start&quot; , cols_remove = F ) %&gt;% dplyr::filter(sorter1!=sorter2) %&gt;% dplyr::mutate( dplyr::across( tidyselect::starts_with(&quot;sorter&quot;) , .fns = function(x){factor( x, ordered = T , levels = levels(ptcld_validation_data$depth_maps_generation_filtering_mode) )} ) , contrast = contrast %&gt;% forcats::fct_reorder( paste0(as.numeric(sorter1), as.numeric(sorter2)) %&gt;% as.numeric() ) %&gt;% # re order for filtering mode forcats::fct_rev() ) %&gt;% # median_hdi summary for coloring dplyr::group_by(contrast, software, depth_maps_generation_quality) %&gt;% make_contrast_vars() # remove out-of-sample obs brms_contrast_temp = brms_contrast_temp %&gt;% dplyr::inner_join( ptcld_validation_data %&gt;% dplyr::distinct(software, depth_maps_generation_quality, depth_maps_generation_filtering_mode) , by = dplyr::join_by(software, depth_maps_generation_quality, sorter1==depth_maps_generation_filtering_mode) ) %&gt;% dplyr::inner_join( ptcld_validation_data %&gt;% dplyr::distinct(software, depth_maps_generation_quality, depth_maps_generation_filtering_mode) , by = dplyr::join_by(software, depth_maps_generation_quality, sorter2==depth_maps_generation_filtering_mode) ) %&gt;% dplyr::mutate(depth_maps_generation_quality = depth_maps_generation_quality %&gt;% forcats::fct_rev()) plot it brms_contrast_temp %&gt;% plt_contrast( facet = c(&quot;depth_maps_generation_quality&quot;, &quot;software&quot;) , y_axis_title = &quot;filtering mode&quot; , label_size = 0 , x_expand = c(-0.1,-0.1) ) + facet_grid( rows = vars(software) , cols = vars(depth_maps_generation_quality) ) + labs( subtitle = &quot;posterior predictive distribution of group constrasts with 95% &amp; 50% HDI\\nby dense cloud quality and software&quot; , x = &quot;constrast Height RMSE (m)&quot; ) ggplot2::ggsave( &quot;../data/qlty_fltr_sftwr_comp_ht_rmse.png&quot; , plot = ggplot2::last_plot() + labs(subtitle = &quot;&quot;) , height = 7, width = 10.5 ) Export some final images for publication p1_temp = qlty_fltr_sftwr_ht_me + labs(subtitle = &quot;A: Height Mean Error (m)&quot;) + theme(plot.subtitle = element_text(face=&quot;bold&quot;)) p2_temp = qlty_fltr_sftwr_ht_rmse + labs(subtitle = &quot;B: Height RMSE (m)&quot;) + theme(plot.subtitle = element_text(face=&quot;bold&quot;)) # export p1_temp / p2_temp ggplot2::ggsave( filename = paste0(&quot;../data/qlty_fltr_sftwr_ht_comb.jpeg&quot;) , plot = ggplot2::last_plot() , width = 8.5 , height = 11 , units = &quot;in&quot; , dpi = &quot;print&quot; ) 7.4 Tree DBH 7.4.1 Summary Statistics 7.4.1.1 DBH Mean Error (bias) # summarize data dta_temp = ptcld_validation_data %&gt;% dplyr::group_by(software, depth_maps_generation_quality, depth_maps_generation_filtering_mode) %&gt;% # collapse across study site dplyr::summarise( dbh_cm_me = mean(dbh_cm_me, na.rm = T) , n = dplyr::n() ) # set limits for color scale lmt_dbh_cm_me = ceiling(10*max(abs(range(dta_temp$dbh_cm_me, na.rm = T))))/10 # scales::show_col(scales::pal_dichromat(&quot;BluetoOrange.10&quot;)(10)) # scales::show_col(scales::pal_div_gradient()(seq(0, 1, length.out = 7))) # plot it dta_temp %&gt;% ggplot(mapping = aes( y = depth_maps_generation_quality , x = depth_maps_generation_filtering_mode , fill = dbh_cm_me , label = paste0(scales::comma(dbh_cm_me,accuracy = 0.01), &quot;\\n(n=&quot;, n,&quot;)&quot;) )) + geom_tile(color = &quot;white&quot;) + geom_text(color = &quot;white&quot;, size = 3) + facet_grid(cols = vars(software)) + scale_x_discrete(expand = c(0, 0)) + scale_y_discrete(expand = c(0, 0)) + scale_fill_stepsn( n.breaks = 7 , colors = scales::pal_div_gradient()(seq(0, 1, length.out = 7)) , limits = c(-lmt_dbh_cm_me,lmt_dbh_cm_me) , labels = scales::comma_format(accuracy = 0.1) , show.limits = T ) + labs( x = &quot;filtering mode&quot; , y = &quot;quality&quot; , fill = &quot;DBH Mean Error (cm)&quot; , title = &quot;mean DBH mean error (cm) and # of study sites&quot; , subtitle = paste( &quot;negative values = UAS tree DBH &lt; field tree DBH&quot; , &quot; || &quot; , &quot;positive values = UAS tree DBH &gt; field tree DBH&quot; ) ) + theme_light() + theme( legend.position = &quot;none&quot; , axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1) , panel.background = element_blank() , panel.grid = element_blank() # , plot.title = element_text(hjust = 0.5) # , plot.subtitle = element_text(hjust = 0.5) , strip.text = element_text(color = &quot;black&quot;, face = &quot;bold&quot;) ) let’s check the distribution (of our dependent or \\(y\\) variable) # distribution ptcld_validation_data %&gt;% ggplot(mapping = aes(x = dbh_cm_me)) + geom_hline(yintercept = 0, color = &quot;gray77&quot;) + geom_vline(xintercept = 0, color = &quot;gray77&quot;) + # geom_vline(xintercept = c(0,1)) + geom_density(fill = &quot;lightblue&quot;, alpha = 0.7, color = NA) + labs(y=&quot;&quot;,x=&quot;DBH Mean Error (cm)&quot;) + scale_y_continuous(breaks = c(0)) + scale_x_continuous(breaks = scales::extended_breaks(10)) + theme_light() + theme(panel.grid = element_blank()) and the summary statistics ptcld_validation_data %&gt;% dplyr::ungroup() %&gt;% dplyr::select(dbh_cm_me) %&gt;% dplyr::summarise( dplyr::across( dplyr::everything() , .fns = list( mean = ~ mean(.x,na.rm=T), median = ~ median(.x,na.rm=T), sd = ~ sd(.x,na.rm=T) , min = ~ min(.x,na.rm=T), max = ~ max(.x,na.rm=T) , q25 = ~ quantile(.x, 0.25, na.rm = T) , q75 = ~ quantile(.x, 0.75, na.rm = T) ) , .names = &quot;{.fn}&quot; ) ) %&gt;% tidyr::pivot_longer(everything()) %&gt;% kableExtra::kbl(caption = &quot;summary: `dbh_cm_me`&quot;, digits = 3, col.names = NULL) %&gt;% kableExtra::kable_styling() Table 7.15: summary: dbh_cm_me mean 0.655 median 0.149 sd 3.506 min -9.733 max 8.480 q25 -1.964 q75 2.003 7.4.1.2 DBH RMSE (precision) # summarize data dta_temp = ptcld_validation_data %&gt;% dplyr::group_by(software, depth_maps_generation_quality, depth_maps_generation_filtering_mode) %&gt;% # collapse across study site dplyr::summarise( dbh_cm_rmse = mean(dbh_cm_rmse, na.rm = T) , n = dplyr::n() ) # set limits for color scale lmt_dbh_cm_rmse = ceiling(1.02*10*max(abs(range(dta_temp$dbh_cm_rmse, na.rm = T))))/10 # scales::show_col(viridis::mako(n = 10, begin = 0.2, end = 0.9, direction = -1)) # scales::show_col(scales::pal_div_gradient()(seq(0, 1, length.out = 7))) # plot it dta_temp %&gt;% ggplot(mapping = aes( y = depth_maps_generation_quality , x = depth_maps_generation_filtering_mode , fill = dbh_cm_rmse , label = paste0(scales::comma(dbh_cm_rmse,accuracy = 0.1), &quot;\\n(n=&quot;, n,&quot;)&quot;) )) + geom_tile(color = &quot;white&quot;) + geom_text(color = &quot;white&quot;, size = 3) + facet_grid(cols = vars(software)) + scale_x_discrete(expand = c(0, 0)) + scale_y_discrete(expand = c(0, 0)) + scale_fill_stepsn( n.breaks = 5 , colors = viridis::mako(n = 5, begin = 0.2, end = 0.9, direction = -1) , limits = c(0,lmt_dbh_cm_rmse) , labels = scales::comma_format(accuracy = 0.1) , show.limits = T ) + labs( x = &quot;filtering mode&quot; , y = &quot;quality&quot; , fill = &quot;DBH RMSE (cm)&quot; , title = &quot;mean DBH RMSE (cm) and # of study sites&quot; ) + theme_light() + theme( legend.position = &quot;none&quot; , axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1) , panel.background = element_blank() , panel.grid = element_blank() # , plot.title = element_text(hjust = 0.5) # , plot.subtitle = element_text(hjust = 0.5) , strip.text = element_text(color = &quot;black&quot;, face = &quot;bold&quot;) ) let’s check the distribution (of our dependent or \\(y\\) variable) # distribution ptcld_validation_data %&gt;% ggplot(mapping = aes(x = dbh_cm_rmse)) + geom_hline(yintercept = 0, color = &quot;gray77&quot;) + geom_vline(xintercept = 0, color = &quot;gray77&quot;) + # geom_vline(xintercept = c(0,1)) + geom_density(fill = &quot;lightblue&quot;, alpha = 0.7, color = NA) + labs(y=&quot;&quot;,x=&quot;DBH RMSE (cm)&quot;) + scale_y_continuous(breaks = c(0)) + scale_x_continuous(breaks = scales::extended_breaks(10)) + theme_light() + theme(panel.grid = element_blank()) and the summary statistics ptcld_validation_data %&gt;% dplyr::ungroup() %&gt;% dplyr::select(dbh_cm_rmse) %&gt;% dplyr::summarise( dplyr::across( dplyr::everything() , .fns = list( mean = ~ mean(.x,na.rm=T), median = ~ median(.x,na.rm=T), sd = ~ sd(.x,na.rm=T) , min = ~ min(.x,na.rm=T), max = ~ max(.x,na.rm=T) , q25 = ~ quantile(.x, 0.25, na.rm = T) , q75 = ~ quantile(.x, 0.75, na.rm = T) ) , .names = &quot;{.fn}&quot; ) ) %&gt;% tidyr::pivot_longer(everything()) %&gt;% kableExtra::kbl(caption = &quot;summary: `dbh_cm_rmse`&quot;, digits = 3, col.names = NULL) %&gt;% kableExtra::kable_styling() Table 7.16: summary: dbh_cm_rmse mean 6.337 median 5.869 sd 2.566 min 3.272 max 12.430 q25 4.080 q75 7.414 7.4.2 Model: DBH Mean Error (bias) Define priors # from Kurz: gamma_a_b_from_omega_sigma = function(mode, sd) { if (mode &lt;= 0) stop(&quot;mode must be &gt; 0&quot;) if (sd &lt;= 0) stop(&quot;sd must be &gt; 0&quot;) rate = (mode + sqrt(mode^2 + 4 * sd^2)) / (2 * sd^2) shape = 1 + mode * rate return(list(shape = shape, rate = rate)) } mean_y_temp = mean(ptcld_validation_data$dbh_cm_me, na.rm = T) sd_y_temp = sd(ptcld_validation_data$dbh_cm_me, na.rm = T) omega_temp = sd_y_temp / 2 sigma_temp = 2 * sd_y_temp s_r_temp = gamma_a_b_from_omega_sigma(mode = omega_temp, sd = sigma_temp) stanvars_temp = brms::stanvar(mean_y_temp, name = &quot;mean_y&quot;) + brms::stanvar(sd_y_temp, name = &quot;sd_y&quot;) + brms::stanvar(s_r_temp$shape, name = &quot;alpha&quot;) + brms::stanvar(s_r_temp$rate, name = &quot;beta&quot;) 7.4.2.1 Prior distributions #### setting priors # required libraries: tidyverse, tidybayes, brms, palettetown, latex2exp priors_temp &lt;- c( brms::prior(normal(mean_y_temp, sd_y_temp * 5), class = &quot;Intercept&quot;) , brms::prior(gamma(s_r_temp$shape, s_r_temp$rate), class = &quot;sd&quot;) , brms::prior(cauchy(0, sd_y_temp), class = &quot;sigma&quot;) ) # plot plt_prior3 = priors_temp %&gt;% tidybayes::parse_dist() %&gt;% tidybayes::marginalize_lkjcorr(K = 2) %&gt;% tidyr::separate( .args , sep = &quot;,&quot; , into = c(&quot;a&quot;,&quot;b&quot;) , remove = F ) %&gt;% dplyr::mutate( distrib = paste0( class, &quot; ~ &quot; , .dist , &quot;(&quot; , a %&gt;% readr::parse_number() %&gt;% round(2) , &quot;,&quot; , b %&gt;% readr::parse_number() %&gt;% round(2) , &quot;)&quot; ) ) %&gt;% ggplot(., aes(dist = .dist, args = .args)) + facet_grid(cols=vars(distrib), scales = &quot;free&quot;) + ggdist::stat_halfeye( aes(fill = prior), n = 10e2, show.legend = F , fill = &quot;slategray&quot; ) + coord_flip() + theme_light() + theme( strip.text = element_text(face = &quot;bold&quot;, color = &quot;black&quot;), axis.text.y = element_blank(), axis.ticks = element_blank() , axis.text = element_text(size = 6) )+ labs( x = &quot;&quot; , title = &quot;Priors: DBH Mean Error (bias)&quot; , y = &quot;&quot; ) plt_prior3 7.4.2.2 Fit the model Now fit the model. brms_dbh_me_mod = brms::brm( formula = dbh_cm_me ~ # baseline 1 + # main effects (1 | depth_maps_generation_quality) + (1 | depth_maps_generation_filtering_mode) + (1 | software) + (1 | study_site) + # only fitting main effects of site and not interactions # two-way interactions (1 | depth_maps_generation_quality:depth_maps_generation_filtering_mode) + (1 | depth_maps_generation_quality:software) + (1 | depth_maps_generation_filtering_mode:software) + # three-way interactions (1 | depth_maps_generation_quality:depth_maps_generation_filtering_mode:software) , data = ptcld_validation_data , family = brms::brmsfamily(family = &quot;gaussian&quot;) , iter = 20000, warmup = 10000, chains = 4 , control = list(adapt_delta = 0.999, max_treedepth = 13) , cores = round(parallel::detectCores()/2) , prior = c( brms::prior(normal(mean_y, sd_y * 5), class = &quot;Intercept&quot;) , brms::prior(gamma(alpha, beta), class = &quot;sd&quot;) , brms::prior(cauchy(0, sd_y), class = &quot;sigma&quot;) ) , stanvars = stanvars_temp , file = paste0(rootdir, &quot;/fits/brms_dbh_me_mod&quot;) ) 7.4.2.3 Quality:Filtering - interaction draws_temp = ptcld_validation_data %&gt;% dplyr::distinct(depth_maps_generation_quality, depth_maps_generation_filtering_mode) %&gt;% tidybayes::add_epred_draws( brms_dbh_me_mod, allow_new_levels = T # this part is crucial , re_formula = ~ (1 | depth_maps_generation_quality) + (1 | depth_maps_generation_filtering_mode) + (1 | depth_maps_generation_quality:depth_maps_generation_filtering_mode) ) %&gt;% dplyr::rename(value = .epred) %&gt;% dplyr::mutate(med = tidybayes::median_hdci(value)$y) # plot draws_temp %&gt;% dplyr::mutate(depth_maps_generation_quality = depth_maps_generation_quality %&gt;% forcats::fct_rev()) %&gt;% # plot ggplot( mapping = aes( y = value, x = depth_maps_generation_filtering_mode , fill = med ) ) + geom_hline(yintercept = 0, color = &quot;gray33&quot;) + # tidybayes::stat_dotsinterval( # point_interval = median_hdi, .width = .95 # , justification = -0.04 # , slab_alpha = 0.98 # , shape = 21, point_size = 3 # , quantiles = 100 # ) + tidybayes::stat_eye( point_interval = median_hdi, .width = .95 , slab_alpha = 0.98 , interval_color = &quot;black&quot;, linewidth = 1 , point_color = &quot;black&quot;, point_fill = &quot;black&quot;, point_size = 1 ) + scale_fill_stepsn( n.breaks = 7 , colors = scales::pal_div_gradient()(seq(0, 1, length.out = 7)) , limits = c(-lmt_dbh_cm_me*0.7,lmt_dbh_cm_me*0.7) , labels = scales::comma_format(accuracy = 0.1) , show.limits = T ) + scale_y_continuous(breaks = scales::extended_breaks(n=8)) + facet_grid(cols = vars(depth_maps_generation_quality)) + labs( x = &quot;filtering mode&quot;, y = &quot;DBH Mean Error (cm)&quot; , subtitle = &quot;posterior predictive distribution of DBH mean error (cm) with 95% HDI\\nby dense cloud quality&quot; ) + theme_light() + theme( legend.position = &quot;none&quot; , legend.direction = &quot;horizontal&quot; , axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1) , strip.text = element_text(color = &quot;black&quot;, face = &quot;bold&quot;) ) and a table of these 95% HDI values table_temp = draws_temp %&gt;% tidybayes::median_hdi(value) %&gt;% dplyr::select(-c(.point,.interval, .width,.row)) %&gt;% dplyr::arrange(depth_maps_generation_quality,depth_maps_generation_filtering_mode) table_temp %&gt;% dplyr::select(-c(depth_maps_generation_quality)) %&gt;% kableExtra::kbl( digits = 2 , caption = &quot;DBH Mean Error (cm)&lt;br&gt;95% HDI of the posterior predictive distribution&quot; , col.names = c( &quot;filtering mode&quot; , &quot;DBH Mean Error (cm)&lt;br&gt;median&quot; , &quot;HDI low&quot;, &quot;HDI high&quot; ) , escape = F ) %&gt;% kableExtra::kable_styling() %&gt;% kableExtra::pack_rows(index = table(forcats::fct_inorder(table_temp$depth_maps_generation_quality))) %&gt;% kableExtra::scroll_box(height = &quot;8in&quot;) Table 7.17: DBH Mean Error (cm)95% HDI of the posterior predictive distribution filtering mode DBH Mean Error (cm)median HDI low HDI high ultra high aggressive 0.82 -4.39 5.91 moderate 0.91 -4.03 6.25 mild 0.96 -4.20 6.07 disabled 0.94 -4.19 6.11 high aggressive 0.75 -4.28 6.02 moderate 0.85 -4.29 5.98 mild 0.90 -4.23 6.02 disabled 0.89 -4.17 6.12 medium aggressive 0.54 -4.51 5.76 moderate 0.69 -4.43 5.85 mild 0.76 -4.48 5.77 disabled 0.73 -4.60 5.67 low aggressive 0.38 -4.80 5.54 moderate 0.52 -4.45 5.83 mild 0.62 -4.56 5.73 disabled 0.61 -4.53 5.76 lowest aggressive -0.11 -5.34 5.10 moderate 0.07 -5.14 5.24 mild 0.19 -4.85 5.53 disabled 0.17 -5.03 5.35 7.4.2.4 Software:Quality - interaction draws_temp = ptcld_validation_data %&gt;% dplyr::distinct(depth_maps_generation_quality, software) %&gt;% tidybayes::add_epred_draws( brms_dbh_me_mod, allow_new_levels = T # this part is crucial , re_formula = ~ (1 | depth_maps_generation_quality) + (1 | software) + (1 | depth_maps_generation_quality:software) ) %&gt;% dplyr::rename(value = .epred) %&gt;% dplyr::mutate(med = tidybayes::median_hdci(value)$y) # plot draws_temp %&gt;% dplyr::mutate(depth_maps_generation_quality = depth_maps_generation_quality %&gt;% forcats::fct_rev()) %&gt;% # plot ggplot( mapping = aes( y = value, x = software , fill = med ) ) + geom_hline(yintercept = 0, color = &quot;gray33&quot;) + tidybayes::stat_eye( point_interval = median_hdi, .width = .95 , slab_alpha = 0.98 , interval_color = &quot;black&quot;, linewidth = 1 , point_color = &quot;black&quot;, point_fill = &quot;black&quot;, point_size = 1 ) + scale_fill_stepsn( n.breaks = 7 , colors = scales::pal_div_gradient()(seq(0, 1, length.out = 7)) , limits = c(-lmt_dbh_cm_me*0.7,lmt_dbh_cm_me*0.7) , labels = scales::comma_format(accuracy = 0.1) , show.limits = T ) + scale_y_continuous(breaks = scales::extended_breaks(n=8)) + facet_grid(cols = vars(depth_maps_generation_quality)) + labs( x = &quot;software&quot;, y = &quot;DBH Mean Error (cm)&quot; , subtitle = &quot;posterior predictive distribution of DBH mean error (cm) with 95% HDI\\nby dense cloud quality&quot; ) + theme_light() + theme( legend.position = &quot;none&quot; , legend.direction = &quot;horizontal&quot; , axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1) , strip.text = element_text(color = &quot;black&quot;, face = &quot;bold&quot;) ) and a table of these 95% HDI values table_temp = draws_temp %&gt;% tidybayes::median_hdi(value) %&gt;% # remove out-of-sample obs dplyr::inner_join( ptcld_validation_data %&gt;% dplyr::distinct(depth_maps_generation_quality, software) , by = dplyr::join_by(depth_maps_generation_quality, software) ) %&gt;% dplyr::select(-c(.point,.interval, .width,.row)) %&gt;% dplyr::arrange(software,depth_maps_generation_quality) table_temp %&gt;% dplyr::select(-c(software)) %&gt;% kableExtra::kbl( digits = 2 , caption = &quot;DBH Mean Error (cm)&lt;br&gt;95% HDI of the posterior predictive distribution&quot; , col.names = c( &quot;quality&quot; , &quot;DBH Mean Error (cm)&lt;br&gt;median&quot; , &quot;HDI low&quot;, &quot;HDI high&quot; ) , escape = F ) %&gt;% kableExtra::kable_styling() %&gt;% kableExtra::pack_rows(index = table(forcats::fct_inorder(table_temp$software))) %&gt;% kableExtra::scroll_box(height = &quot;8in&quot;) Table 7.18: DBH Mean Error (cm)95% HDI of the posterior predictive distribution quality DBH Mean Error (cm)median HDI low HDI high METASHAPE ultra high 1.00 -3.64 5.65 high 0.95 -3.62 5.61 medium 0.57 -4.19 5.08 low -0.18 -4.83 4.42 lowest -1.42 -6.09 3.16 OPENDRONEMAP ultra high 1.23 -3.40 5.85 high 1.17 -3.54 5.73 medium 0.76 -3.90 5.38 low 0.90 -3.86 5.38 lowest 0.77 -3.76 5.48 PIX4D ultra high 0.95 -3.55 5.71 high 0.82 -3.86 5.45 medium 0.79 -3.96 5.35 low 0.75 -3.74 5.54 7.4.2.5 Software:Filtering - interaction draws_temp = ptcld_validation_data %&gt;% dplyr::distinct(depth_maps_generation_filtering_mode, software) %&gt;% tidybayes::add_epred_draws( brms_dbh_me_mod, allow_new_levels = T # this part is crucial , re_formula = ~ (1 | depth_maps_generation_filtering_mode) + (1 | software) + (1 | depth_maps_generation_filtering_mode:software) ) %&gt;% dplyr::rename(value = .epred) %&gt;% dplyr::mutate(med = tidybayes::median_hdci(value)$y) # plot draws_temp %&gt;% # plot ggplot( mapping = aes( y = value, x = software , fill = med ) ) + geom_hline(yintercept = 0, color = &quot;gray33&quot;) + tidybayes::stat_eye( point_interval = median_hdi, .width = .95 , slab_alpha = 0.98 , interval_color = &quot;black&quot;, linewidth = 1 , point_color = &quot;black&quot;, point_fill = &quot;black&quot;, point_size = 1 ) + scale_fill_stepsn( n.breaks = 7 , colors = scales::pal_div_gradient()(seq(0, 1, length.out = 7)) , limits = c(-lmt_dbh_cm_me*0.7,lmt_dbh_cm_me*0.7) , labels = scales::comma_format(accuracy = 0.1) , show.limits = T ) + scale_y_continuous(breaks = scales::extended_breaks(n=8)) + facet_grid(cols = vars(depth_maps_generation_filtering_mode)) + labs( x = &quot;software&quot;, y = &quot;DBH Mean Error (cm)&quot; , subtitle = &quot;posterior predictive distribution of DBH mean error (cm) with 95% HDI\\nby filtering mode&quot; ) + theme_light() + theme( legend.position = &quot;none&quot; , legend.direction = &quot;horizontal&quot; , axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1) , strip.text = element_text(color = &quot;black&quot;, face = &quot;bold&quot;) ) and a table of these 95% HDI values table_temp = draws_temp %&gt;% tidybayes::median_hdi(value) %&gt;% dplyr::select(-c(.point,.interval, .width,.row)) %&gt;% dplyr::arrange(software,depth_maps_generation_filtering_mode) table_temp %&gt;% dplyr::select(-c(software)) %&gt;% kableExtra::kbl( digits = 2 , caption = &quot;DBH Mean Error (cm)&lt;br&gt;95% HDI of the posterior predictive distribution&quot; , col.names = c( &quot;filtering mode&quot; , &quot;DBH Mean Error (cm)&lt;br&gt;median&quot; , &quot;HDI low&quot;, &quot;HDI high&quot; ) , escape = F ) %&gt;% kableExtra::kable_styling() %&gt;% kableExtra::pack_rows(index = table(forcats::fct_inorder(table_temp$software))) %&gt;% kableExtra::scroll_box(height = &quot;8in&quot;) Table 7.19: DBH Mean Error (cm)95% HDI of the posterior predictive distribution filtering mode DBH Mean Error (cm)median HDI low HDI high METASHAPE aggressive 0.09 -4.63 4.74 moderate 0.24 -4.35 5.03 mild 0.38 -4.25 5.12 disabled 0.37 -4.33 5.03 OPENDRONEMAP aggressive 0.76 -3.87 5.47 moderate 0.90 -3.68 5.66 mild 0.97 -3.73 5.60 disabled 0.91 -3.88 5.48 PIX4D moderate 0.68 -3.95 5.43 mild 0.73 -3.93 5.43 disabled 0.72 -3.79 5.59 7.4.2.6 Software:Quality:Filtering - interaction # get draws fltr_sftwr_draws_temp = tidyr::crossing( depth_maps_generation_quality = unique(ptcld_validation_data$depth_maps_generation_quality) , depth_maps_generation_filtering_mode = unique(ptcld_validation_data$depth_maps_generation_filtering_mode) , software = unique(ptcld_validation_data$software) ) %&gt;% tidybayes::add_epred_draws( brms_dbh_me_mod, allow_new_levels = T # this part is crucial , re_formula = ~ (1 | depth_maps_generation_quality) + # main effects (1 | depth_maps_generation_quality) + (1 | depth_maps_generation_filtering_mode) + (1 | software) + # two-way interactions (1 | depth_maps_generation_quality:depth_maps_generation_filtering_mode) + (1 | depth_maps_generation_quality:software) + (1 | depth_maps_generation_filtering_mode:software) + # three-way interactions (1 | depth_maps_generation_quality:depth_maps_generation_filtering_mode:software) ) %&gt;% dplyr::rename(value = .epred) %&gt;% dplyr::mutate(med = tidybayes::median_hdci(value)$y) # plot qlty_fltr_sftwr_dbh_me = fltr_sftwr_draws_temp %&gt;% dplyr::inner_join( ptcld_validation_data %&gt;% dplyr::distinct(software, depth_maps_generation_quality, depth_maps_generation_filtering_mode) , by = dplyr::join_by(software, depth_maps_generation_quality, depth_maps_generation_filtering_mode) ) %&gt;% dplyr::mutate(depth_maps_generation_quality = depth_maps_generation_quality %&gt;% forcats::fct_rev()) %&gt;% ggplot( mapping = aes( y = value , x = depth_maps_generation_filtering_mode , fill = med ) ) + geom_hline(yintercept = 0, color = &quot;gray33&quot;) + tidybayes::stat_eye( point_interval = median_hdi, .width = .95 , slab_alpha = 0.98 , interval_color = &quot;black&quot;, linewidth = 1 , point_color = &quot;black&quot;, point_fill = &quot;black&quot;, point_size = 1 ) + scale_fill_stepsn( n.breaks = 7 , colors = scales::pal_div_gradient()(seq(0, 1, length.out = 7)) , limits = c(-lmt_dbh_cm_me*0.7,lmt_dbh_cm_me*0.7) , labels = scales::comma_format(accuracy = 0.1) , show.limits = T ) + facet_grid( rows = vars(software) , cols = vars(depth_maps_generation_quality) # , switch = &quot;y&quot; ) + labs( x = &quot;filtering mode&quot;, y = &quot;DBH Mean Error (cm)&quot; , subtitle = &quot;posterior predictive distribution of DBH mean error (cm) with 95% HDI\\nby dense cloud quality and software&quot; # , caption = form_temp ) + theme_light() + theme( legend.position = &quot;none&quot; , legend.direction = &quot;horizontal&quot; , axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1) , strip.text = element_text(color = &quot;black&quot;, face = &quot;bold&quot;) , panel.grid = element_blank() # , strip.placement = &quot;outside&quot; ) + guides( fill = guide_legend(override.aes = list(shape = NA, size = 6, alpha = 0.9, lwd = NA)) ) # print it qlty_fltr_sftwr_dbh_me ggplot2::ggsave(&quot;../data/qlty_fltr_sftwr_dbh_me.png&quot;, height = 7, width = 10.5) and a table of these 95% HDI values table_temp = fltr_sftwr_draws_temp %&gt;% tidybayes::median_hdi(value) %&gt;% dplyr::inner_join( ptcld_validation_data %&gt;% dplyr::distinct(software, depth_maps_generation_quality, depth_maps_generation_filtering_mode) , by = dplyr::join_by(software, depth_maps_generation_quality, depth_maps_generation_filtering_mode) ) %&gt;% dplyr::mutate(depth_maps_generation_quality = depth_maps_generation_quality %&gt;% forcats::fct_rev()) %&gt;% dplyr::select(c( software, depth_maps_generation_quality, depth_maps_generation_filtering_mode , value, .lower, .upper )) %&gt;% dplyr::ungroup() %&gt;% dplyr::arrange(software, depth_maps_generation_quality, depth_maps_generation_filtering_mode) table_temp %&gt;% # dplyr::select(-c(software)) %&gt;% kableExtra::kbl( digits = 2 , caption = &quot;DBH Mean Error (cm)&lt;br&gt;95% HDI of the posterior predictive distribution&quot; , col.names = c( &quot;software&quot;, &quot;quality&quot;, &quot;filtering mode&quot; , &quot;DBH Mean Error (cm)&lt;br&gt;median&quot; , &quot;HDI low&quot;, &quot;HDI high&quot; ) , escape = F ) %&gt;% kableExtra::kable_styling() %&gt;% # kableExtra::pack_rows(index = table(forcats::fct_inorder(table_temp$software))) %&gt;% kableExtra::collapse_rows(columns = 1:2, valign = &quot;top&quot;) %&gt;% kableExtra::scroll_box(height = &quot;8in&quot;) Table 7.20: DBH Mean Error (cm)95% HDI of the posterior predictive distribution software quality filtering mode DBH Mean Error (cm)median HDI low HDI high METASHAPE lowest aggressive -1.65 -6.23 2.97 moderate -1.42 -6.13 3.11 mild -1.30 -5.93 3.28 disabled -1.36 -5.88 3.35 low aggressive -0.41 -4.99 4.19 moderate -0.17 -4.72 4.46 mild -0.08 -4.71 4.46 disabled -0.13 -4.77 4.41 medium aggressive -0.04 -4.66 4.66 moderate 0.19 -4.43 4.92 mild 0.26 -4.56 4.81 disabled 0.20 -4.41 4.93 high aggressive 0.81 -3.66 5.54 moderate 0.96 -3.58 5.62 mild 1.03 -3.57 5.61 disabled 0.98 -3.59 5.62 ultra high aggressive 0.46 -4.19 5.13 moderate 0.65 -3.93 5.43 mild 0.70 -4.00 5.33 disabled 0.65 -4.16 5.16 OPENDRONEMAP lowest aggressive 0.57 -4.01 5.17 moderate 0.76 -3.77 5.40 mild 0.84 -3.73 5.43 disabled 0.81 -3.78 5.42 low aggressive 0.76 -3.81 5.37 moderate 0.84 -3.73 5.43 mild 0.95 -3.69 5.47 disabled 0.99 -3.58 5.60 medium aggressive 0.86 -3.79 5.52 moderate 1.01 -3.53 5.79 mild 1.07 -3.63 5.67 disabled 1.06 -3.69 5.59 high aggressive 1.08 -3.45 5.78 moderate 1.19 -3.39 5.78 mild 1.21 -3.28 5.89 disabled 1.22 -3.34 5.86 ultra high aggressive 1.08 -3.62 5.65 moderate 1.19 -3.54 5.76 mild 1.22 -3.42 5.85 disabled 1.21 -3.47 5.81 PIX4D low moderate 0.74 -3.85 5.36 mild 0.79 -3.86 5.35 disabled 0.86 -3.83 5.45 medium moderate 1.18 -3.58 5.87 mild 1.20 -3.39 6.08 disabled 1.28 -3.58 5.92 high moderate 0.81 -3.80 5.43 mild 0.84 -3.59 5.64 disabled 0.89 -3.64 5.64 ultra high moderate 0.99 -3.84 5.70 mild 0.99 -3.83 5.72 disabled 1.04 -3.79 5.76 7.4.3 Model: DBH RMSE (precision) Define priors # from Kurz: gamma_a_b_from_omega_sigma = function(mode, sd) { if (mode &lt;= 0) stop(&quot;mode must be &gt; 0&quot;) if (sd &lt;= 0) stop(&quot;sd must be &gt; 0&quot;) rate = (mode + sqrt(mode^2 + 4 * sd^2)) / (2 * sd^2) shape = 1 + mode * rate return(list(shape = shape, rate = rate)) } mean_y_temp = mean(ptcld_validation_data$dbh_cm_rmse, na.rm = T) sd_y_temp = sd(ptcld_validation_data$dbh_cm_rmse, na.rm = T) omega_temp = sd_y_temp / 2 sigma_temp = 2 * sd_y_temp s_r_temp = gamma_a_b_from_omega_sigma(mode = omega_temp, sd = sigma_temp) stanvars_temp = brms::stanvar(mean_y_temp, name = &quot;mean_y&quot;) + brms::stanvar(sd_y_temp, name = &quot;sd_y&quot;) + brms::stanvar(s_r_temp$shape, name = &quot;alpha&quot;) + brms::stanvar(s_r_temp$rate, name = &quot;beta&quot;) 7.4.3.1 Prior distributions #### setting priors # required libraries: tidyverse, tidybayes, brms, palettetown, latex2exp priors_temp &lt;- c( brms::prior(normal(mean_y_temp, sd_y_temp * 5), class = &quot;Intercept&quot;) , brms::prior(gamma(s_r_temp$shape, s_r_temp$rate), class = &quot;sd&quot;) , brms::prior(cauchy(0, sd_y_temp), class = &quot;sigma&quot;) ) # plot plt_prior4 = priors_temp %&gt;% tidybayes::parse_dist() %&gt;% tidybayes::marginalize_lkjcorr(K = 2) %&gt;% tidyr::separate( .args , sep = &quot;,&quot; , into = c(&quot;a&quot;,&quot;b&quot;) , remove = F ) %&gt;% dplyr::mutate( distrib = paste0( class, &quot; ~ &quot; , .dist , &quot;(&quot; , a %&gt;% readr::parse_number() %&gt;% round(2) , &quot;,&quot; , b %&gt;% readr::parse_number() %&gt;% round(2) , &quot;)&quot; ) ) %&gt;% ggplot(., aes(dist = .dist, args = .args)) + facet_grid(cols=vars(distrib), scales = &quot;free&quot;) + ggdist::stat_halfeye( aes(fill = prior), n = 10e2, show.legend = F , fill = &quot;slategray&quot; ) + coord_flip() + theme_light() + theme( strip.text = element_text(face = &quot;bold&quot;, color = &quot;black&quot;), axis.text.y = element_blank(), axis.ticks = element_blank() , axis.text = element_text(size = 6) )+ labs( x = &quot;&quot; , title = &quot;Priors: DBH RMSE (precision)&quot; , y = &quot;&quot; ) plt_prior4 7.4.3.2 Fit the model Now fit the model. brms_dbh_rmse_mod = brms::brm( formula = dbh_cm_rmse ~ # baseline 1 + # main effects (1 | depth_maps_generation_quality) + (1 | depth_maps_generation_filtering_mode) + (1 | software) + (1 | study_site) + # only fitting main effects of site and not interactions # two-way interactions (1 | depth_maps_generation_quality:depth_maps_generation_filtering_mode) + (1 | depth_maps_generation_quality:software) + (1 | depth_maps_generation_filtering_mode:software) + # three-way interactions (1 | depth_maps_generation_quality:depth_maps_generation_filtering_mode:software) , data = ptcld_validation_data , family = brms::brmsfamily(family = &quot;gaussian&quot;) , iter = 20000, warmup = 10000, chains = 4 , control = list(adapt_delta = 0.999, max_treedepth = 13) , cores = round(parallel::detectCores()/2) , prior = c( brms::prior(normal(mean_y, sd_y * 5), class = &quot;Intercept&quot;) , brms::prior(gamma(alpha, beta), class = &quot;sd&quot;) , brms::prior(cauchy(0, sd_y), class = &quot;sigma&quot;) ) , stanvars = stanvars_temp , file = paste0(rootdir, &quot;/fits/brms_dbh_rmse_mod&quot;) ) 7.4.3.3 Quality:Filtering - interaction draws_temp = ptcld_validation_data %&gt;% dplyr::distinct(depth_maps_generation_quality, depth_maps_generation_filtering_mode) %&gt;% tidybayes::add_epred_draws( brms_dbh_rmse_mod, allow_new_levels = T # this part is crucial , re_formula = ~ (1 | depth_maps_generation_quality) + (1 | depth_maps_generation_filtering_mode) + (1 | depth_maps_generation_quality:depth_maps_generation_filtering_mode) ) %&gt;% dplyr::rename(value = .epred) %&gt;% dplyr::mutate(med = tidybayes::median_hdci(value)$y) # plot draws_temp %&gt;% dplyr::mutate(depth_maps_generation_quality = depth_maps_generation_quality %&gt;% forcats::fct_rev()) %&gt;% # plot ggplot( mapping = aes( y = value, x = depth_maps_generation_filtering_mode , fill = med ) ) + geom_hline(yintercept = 0, color = &quot;gray33&quot;) + tidybayes::stat_eye( point_interval = median_hdi, .width = .95 , slab_alpha = 0.98 , interval_color = &quot;black&quot;, linewidth = 1 , point_color = &quot;black&quot;, point_fill = &quot;black&quot;, point_size = 1 ) + scale_fill_stepsn( n.breaks = 5 , colors = viridis::mako(n = 5, begin = 0.2, end = 0.9, direction = -1) , limits = c(0,lmt_dbh_cm_rmse) , labels = scales::comma_format(accuracy = 0.01) , show.limits = T ) + facet_grid(cols = vars(depth_maps_generation_quality)) + scale_y_continuous(limits = c(-0.02,NA)) + labs( x = &quot;filtering mode&quot;, y = &quot;DBH RMSE (cm)&quot; , subtitle = &quot;posterior predictive distribution of DBH RMSE (cm) with 95% HDI\\nby dense cloud quality&quot; ) + theme_light() + theme( legend.position = &quot;none&quot; , legend.direction = &quot;horizontal&quot; , axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1) , strip.text = element_text(color = &quot;black&quot;, face = &quot;bold&quot;) ) and a table of these 95% HDI values table_temp = draws_temp %&gt;% tidybayes::median_hdi(value) %&gt;% dplyr::select(-c(.point,.interval, .width,.row)) %&gt;% dplyr::arrange(depth_maps_generation_quality,depth_maps_generation_filtering_mode) table_temp %&gt;% dplyr::select(-c(depth_maps_generation_quality)) %&gt;% kableExtra::kbl( digits = 2 , caption = &quot;DBH RMSE (cm)&lt;br&gt;95% HDI of the posterior predictive distribution&quot; , col.names = c( &quot;filtering mode&quot; , &quot;DBH RMSE (cm)&lt;br&gt;median&quot; , &quot;HDI low&quot;, &quot;HDI high&quot; ) , escape = F ) %&gt;% kableExtra::kable_styling() %&gt;% kableExtra::pack_rows(index = table(forcats::fct_inorder(table_temp$depth_maps_generation_quality))) %&gt;% kableExtra::scroll_box(height = &quot;8in&quot;) Table 7.21: DBH RMSE (cm)95% HDI of the posterior predictive distribution filtering mode DBH RMSE (cm)median HDI low HDI high ultra high aggressive 6.03 2.13 9.74 moderate 5.95 2.11 9.73 mild 5.90 2.09 9.69 disabled 5.87 2.05 9.65 high aggressive 6.21 2.33 9.93 moderate 6.13 2.30 9.89 mild 6.07 2.20 9.79 disabled 6.06 2.19 9.78 medium aggressive 6.41 2.64 10.26 moderate 6.33 2.57 10.17 mild 6.26 2.41 9.96 disabled 6.25 2.45 10.05 low aggressive 6.67 2.80 10.42 moderate 6.61 2.77 10.37 mild 6.48 2.67 10.24 disabled 6.45 2.63 10.20 lowest aggressive 6.88 3.15 10.76 moderate 6.81 2.97 10.57 mild 6.68 2.87 10.48 disabled 6.69 2.76 10.37 we can also make pairwise comparisons # make the contrasts using compare_levels brms_contrast_temp = draws_temp %&gt;% tidybayes::compare_levels( value , by = depth_maps_generation_quality , comparison = contrast_list # tidybayes::emmeans_comparison(&quot;revpairwise&quot;) #&quot;pairwise&quot; ) %&gt;% dplyr::rename(contrast = depth_maps_generation_quality) # separate contrast brms_contrast_temp = brms_contrast_temp %&gt;% dplyr::ungroup() %&gt;% tidyr::separate_wider_delim( cols = contrast , delim = &quot; - &quot; , names = paste0( &quot;sorter&quot; , 1:(max(stringr::str_count(brms_contrast_temp$contrast, &quot;-&quot;))+1) ) , too_few = &quot;align_start&quot; , cols_remove = F ) %&gt;% dplyr::filter(sorter1!=sorter2) %&gt;% dplyr::mutate( dplyr::across( tidyselect::starts_with(&quot;sorter&quot;) , .fns = function(x){factor( x, ordered = T , levels = levels(ptcld_validation_data$depth_maps_generation_quality) )} ) , contrast = contrast %&gt;% forcats::fct_reorder( paste0(as.numeric(sorter1), as.numeric(sorter2)) %&gt;% as.numeric() ) , depth_maps_generation_filtering_mode = depth_maps_generation_filtering_mode %&gt;% factor( levels = levels(ptcld_validation_data$depth_maps_generation_filtering_mode) , ordered = T ) ) %&gt;% # median_hdi summary for coloring dplyr::group_by(contrast,depth_maps_generation_filtering_mode) %&gt;% make_contrast_vars() plot it plt_contrast( brms_contrast_temp # , caption_text = form_temp , y_axis_title = &quot;quality&quot; , facet = &quot;depth_maps_generation_filtering_mode&quot; , label_size = 1.7 , x_expand = c(0.2,0.05) ) + labs( subtitle = &quot;posterior predictive distribution of group constrasts with 95% &amp; 50% HDI\\nby filtering mode&quot; , x = &quot;constrast DBH RMSE (cm)&quot; ) + theme( axis.text.x = element_text(size = 7) ) ggplot2::ggsave( &quot;../data/qlty_fltr_comp_dbh_rmse.png&quot; , plot = ggplot2::last_plot() + labs(subtitle = &quot;&quot;) , height = 7, width = 10.5 ) and summarize these contrasts brms_contrast_temp %&gt;% dplyr::group_by(contrast, depth_maps_generation_filtering_mode, pr_lt_zero) %&gt;% tidybayes::median_hdi(value) %&gt;% dplyr::arrange(contrast, depth_maps_generation_filtering_mode) %&gt;% dplyr::select(contrast, depth_maps_generation_filtering_mode, value, .lower, .upper, pr_lt_zero) %&gt;% kableExtra::kbl( digits = 2 , caption = &quot;DBH RMSE (cm)&lt;br&gt;95% HDI of the posterior predictive distribution of group contrasts&quot; , col.names = c( &quot;quality contrast&quot; , &quot;filtering mode&quot; , &quot;median difference&lt;br&gt;DBH RMSE (cm)&quot; , &quot;HDI low&quot;, &quot;HDI high&quot; , &quot;Pr(diff&lt;0)&quot; ) , escape = F ) %&gt;% kableExtra::kable_styling() %&gt;% kableExtra::scroll_box(height = &quot;8in&quot;) Table 7.22: DBH RMSE (cm)95% HDI of the posterior predictive distribution of group contrasts quality contrast filtering mode median differenceDBH RMSE (cm) HDI low HDI high Pr(diff&lt;0) ultra high - high aggressive -0.18 -0.71 0.34 77% ultra high - high moderate -0.18 -0.69 0.33 76% ultra high - high mild -0.16 -0.69 0.34 75% ultra high - high disabled -0.19 -0.70 0.32 78% ultra high - medium aggressive -0.39 -0.94 0.16 92% ultra high - medium moderate -0.38 -0.91 0.16 92% ultra high - medium mild -0.35 -0.88 0.19 90% ultra high - medium disabled -0.38 -0.90 0.17 92% ultra high - low aggressive -0.65 -1.24 -0.04 98% ultra high - low moderate -0.67 -1.22 -0.04 98% ultra high - low mild -0.59 -1.12 0.04 96% ultra high - low disabled -0.60 -1.14 0.02 97% ultra high - lowest aggressive -0.87 -1.49 -0.08 99% ultra high - lowest moderate -0.88 -1.52 -0.10 99% ultra high - lowest mild -0.80 -1.43 -0.04 98% ultra high - lowest disabled -0.84 -1.45 -0.06 98% high - medium aggressive -0.20 -0.73 0.34 79% high - medium moderate -0.20 -0.72 0.31 80% high - medium mild -0.19 -0.70 0.34 78% high - medium disabled -0.19 -0.70 0.34 77% high - low aggressive -0.46 -1.01 0.10 95% high - low moderate -0.49 -1.04 0.05 96% high - low mild -0.42 -0.94 0.14 93% high - low disabled -0.40 -0.93 0.16 92% high - lowest aggressive -0.68 -1.27 0.02 97% high - lowest moderate -0.70 -1.31 0.00 98% high - lowest mild -0.63 -1.22 0.06 96% high - lowest disabled -0.64 -1.21 0.07 96% medium - low aggressive -0.25 -0.81 0.27 84% medium - low moderate -0.28 -0.80 0.24 86% medium - low mild -0.23 -0.74 0.30 81% medium - low disabled -0.21 -0.72 0.32 80% medium - lowest aggressive -0.46 -1.06 0.15 93% medium - lowest moderate -0.49 -1.08 0.13 94% medium - lowest mild -0.43 -1.03 0.18 92% medium - lowest disabled -0.44 -1.03 0.17 93% low - lowest aggressive -0.20 -0.76 0.38 77% low - lowest moderate -0.21 -0.77 0.36 78% low - lowest mild -0.21 -0.77 0.35 78% low - lowest disabled -0.22 -0.80 0.34 80% 7.4.3.4 Software:Quality - interaction draws_temp = tidyr::crossing( depth_maps_generation_quality = unique(ptcld_validation_data$depth_maps_generation_quality) , software = unique(ptcld_validation_data$software) ) %&gt;% tidybayes::add_epred_draws( brms_dbh_rmse_mod, allow_new_levels = T # this part is crucial , re_formula = ~ (1 | depth_maps_generation_quality) + (1 | software) + (1 | depth_maps_generation_quality:software) ) %&gt;% dplyr::rename(value = .epred) %&gt;% dplyr::mutate(med = tidybayes::median_hdci(value)$y) # plot draws_temp %&gt;% # remove out-of-sample obs dplyr::inner_join( ptcld_validation_data %&gt;% dplyr::distinct(depth_maps_generation_quality, software) , by = dplyr::join_by(depth_maps_generation_quality, software) ) %&gt;% dplyr::mutate(depth_maps_generation_quality = depth_maps_generation_quality %&gt;% forcats::fct_rev()) %&gt;% # plot ggplot( mapping = aes( y = value, x = software , fill = med ) ) + geom_hline(yintercept = 0, color = &quot;gray33&quot;) + tidybayes::stat_eye( point_interval = median_hdi, .width = .95 , slab_alpha = 0.98 , interval_color = &quot;black&quot;, linewidth = 1 , point_color = &quot;black&quot;, point_fill = &quot;black&quot;, point_size = 1 ) + scale_fill_stepsn( n.breaks = 5 , colors = viridis::mako(n = 5, begin = 0.2, end = 0.9, direction = -1) , limits = c(0,lmt_dbh_cm_rmse) , labels = scales::comma_format(accuracy = 0.01) , show.limits = T ) + facet_grid(cols = vars(depth_maps_generation_quality)) + scale_y_continuous(limits = c(-0.02,NA)) + labs( x = &quot;software&quot;, y = &quot;DBH RMSE (cm)&quot; , subtitle = &quot;posterior predictive distribution of DBH RMSE (cm) with 95% HDI\\nby dense cloud quality&quot; ) + theme_light() + theme( legend.position = &quot;none&quot; , legend.direction = &quot;horizontal&quot; , axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1) , strip.text = element_text(color = &quot;black&quot;, face = &quot;bold&quot;) ) and a table of these 95% HDI values table_temp = draws_temp %&gt;% tidybayes::median_hdi(value) %&gt;% # remove out-of-sample obs dplyr::inner_join( ptcld_validation_data %&gt;% dplyr::distinct(depth_maps_generation_quality, software) , by = dplyr::join_by(depth_maps_generation_quality, software) ) %&gt;% dplyr::select(-c(.point,.interval, .width,.row)) %&gt;% dplyr::arrange(software,depth_maps_generation_quality) table_temp %&gt;% dplyr::select(-c(software)) %&gt;% kableExtra::kbl( digits = 2 , caption = &quot;DBH RMSE (cm)&lt;br&gt;95% HDI of the posterior predictive distribution&quot; , col.names = c( &quot;quality&quot; , &quot;DBH RMSE (cm)&lt;br&gt;median&quot; , &quot;HDI low&quot;, &quot;HDI high&quot; ) , escape = F ) %&gt;% kableExtra::kable_styling() %&gt;% kableExtra::pack_rows(index = table(forcats::fct_inorder(table_temp$software))) %&gt;% kableExtra::scroll_box(height = &quot;8in&quot;) Table 7.23: DBH RMSE (cm)95% HDI of the posterior predictive distribution quality DBH RMSE (cm)median HDI low HDI high METASHAPE ultra high 6.08 2.67 9.63 high 6.23 2.79 9.75 medium 6.40 2.93 9.89 low 6.80 3.34 10.27 lowest 7.16 3.73 10.68 OPENDRONEMAP ultra high 5.83 2.35 9.31 high 6.21 2.80 9.76 medium 6.49 3.07 10.02 low 6.58 3.11 10.08 lowest 6.71 3.28 10.22 PIX4D ultra high 5.76 2.26 9.23 high 5.83 2.37 9.33 medium 6.02 2.57 9.54 low 6.34 2.89 9.85 we can also make pairwise comparisons # calculate contrast brms_contrast_temp = draws_temp %&gt;% tidybayes::compare_levels( value , by = depth_maps_generation_quality , comparison = contrast_list ) %&gt;% dplyr::rename(contrast = depth_maps_generation_quality) # separate contrast brms_contrast_temp = brms_contrast_temp %&gt;% dplyr::ungroup() %&gt;% tidyr::separate_wider_delim( cols = contrast , delim = &quot; - &quot; , names = paste0( &quot;sorter&quot; , 1:(max(stringr::str_count(brms_contrast_temp$contrast, &quot;-&quot;))+1) ) , too_few = &quot;align_start&quot; , cols_remove = F ) %&gt;% dplyr::filter(sorter1!=sorter2) %&gt;% dplyr::mutate( dplyr::across( tidyselect::starts_with(&quot;sorter&quot;) , .fns = function(x){factor( x, ordered = T , levels = levels(ptcld_validation_data$depth_maps_generation_quality) )} ) , contrast = contrast %&gt;% forcats::fct_reorder( paste0(as.numeric(sorter1), as.numeric(sorter2)) %&gt;% as.numeric() ) ) %&gt;% # median_hdi summary for coloring dplyr::group_by(contrast, software) %&gt;% make_contrast_vars() # remove out-of-sample obs brms_contrast_temp = brms_contrast_temp %&gt;% dplyr::inner_join( ptcld_validation_data %&gt;% dplyr::distinct(software, depth_maps_generation_quality) , by = dplyr::join_by(software, sorter1 == depth_maps_generation_quality) ) %&gt;% dplyr::inner_join( ptcld_validation_data %&gt;% dplyr::distinct(software, depth_maps_generation_quality) , by = dplyr::join_by(software, sorter2 == depth_maps_generation_quality) ) plot it plt_contrast( brms_contrast_temp # , caption_text = form_temp , y_axis_title = &quot;quality&quot; , facet = &quot;software&quot; , label_size = 1.8 , x_expand = c(0.33,0.05) ) + labs( subtitle = &quot;posterior predictive distribution of group constrasts with 95% &amp; 50% HDI\\nby software&quot; , x = &quot;constrast DBH RMSE (cm)&quot; ) ggplot2::ggsave( &quot;../data/qlty_sftwr_comp_dbh_rmse.png&quot; , plot = ggplot2::last_plot() + labs(subtitle = &quot;&quot;) , height = 7, width = 10.5 ) create plot for combining with other RMSE contrasts for publication ptchwrk_qlty_sftwr_comp_dbh_rmse = plt_contrast( brms_contrast_temp , y_axis_title = &quot;quality contrast&quot; , facet = &quot;software&quot; , label_size = 1.5 , label = &quot;pr_diff_lab_sm&quot; , annotate_size = 1.8 ) + labs( subtitle = &quot;&quot; # &quot;constrast Height RMSE (m)&quot; , x = &quot;DBH RMSE (cm) constrast&quot; ) + theme( legend.position=&quot;none&quot; , axis.title.y = element_text(size = 10, face = &quot;bold&quot;) , axis.title.x = element_text(size = 8) ) # ptchwrk_qlty_sftwr_comp_dbh_rmse and summarize these contrasts table_temp = brms_contrast_temp %&gt;% dplyr::group_by(contrast, software, pr_lt_zero) %&gt;% tidybayes::median_hdi(value) %&gt;% dplyr::arrange(contrast, software) %&gt;% dplyr::select(contrast, software, value, .lower, .upper, pr_lt_zero) %&gt;% dplyr::arrange(software, contrast) table_temp %&gt;% dplyr::select(-c(software)) %&gt;% kableExtra::kbl( digits = 1 , caption = &quot;DBH RMSE (cm)&lt;br&gt;95% HDI of the posterior predictive distribution of group contrasts&quot; , col.names = c( &quot;quality contrast&quot; , &quot;median difference&lt;br&gt;DBH RMSE (cm)&quot; , &quot;HDI low&quot;, &quot;HDI high&quot; , &quot;Pr(diff&lt;0)&quot; ) , escape = F ) %&gt;% kableExtra::kable_styling() %&gt;% kableExtra::pack_rows(index = table(forcats::fct_inorder(table_temp$software))) %&gt;% kableExtra::scroll_box(height = &quot;8in&quot;) Table 7.24: DBH RMSE (cm)95% HDI of the posterior predictive distribution of group contrasts quality contrast median differenceDBH RMSE (cm) HDI low HDI high Pr(diff&lt;0) METASHAPE ultra high - high -0.1 -0.6 0.3 74% ultra high - medium -0.3 -0.8 0.2 91% ultra high - low -0.7 -1.2 -0.2 100% ultra high - lowest -1.1 -1.6 -0.6 100% high - medium -0.2 -0.6 0.3 78% high - low -0.6 -1.0 -0.1 99% high - lowest -0.9 -1.5 -0.4 100% medium - low -0.4 -0.9 0.1 96% medium - lowest -0.7 -1.3 -0.2 100% low - lowest -0.4 -0.8 0.1 93% OPENDRONEMAP ultra high - high -0.4 -0.9 0.1 94% ultra high - medium -0.7 -1.2 -0.2 100% ultra high - low -0.8 -1.2 -0.3 100% ultra high - lowest -0.9 -1.4 -0.4 100% high - medium -0.3 -0.7 0.2 89% high - low -0.4 -0.8 0.1 94% high - lowest -0.5 -1.0 0.0 97% medium - low -0.1 -0.6 0.4 65% medium - lowest -0.2 -0.7 0.3 78% low - lowest -0.1 -0.6 0.4 71% PIX4D ultra high - high -0.1 -0.6 0.5 62% ultra high - medium -0.3 -0.8 0.3 83% ultra high - low -0.6 -1.1 0.0 98% high - medium -0.2 -0.7 0.3 78% high - low -0.5 -1.0 0.0 98% medium - low -0.3 -0.8 0.2 90% The contrasts above address the question “are there differences in RMSE based on dense point cloud generation quality within each software?”. To address the different question of “are there differences in RMSE based on the processing software used at a given dense point cloud generation quality?” we need to utilize a different formulation of the comparison parameter within our call to the tidybayes::compare_levels function and calculate the contrast by software instead # calculate contrast brms_contrast_temp = draws_temp %&gt;% tidybayes::compare_levels( value , by = software , comparison = &quot;pairwise&quot; ) %&gt;% dplyr::rename(contrast = software) %&gt;% # median_hdi summary for coloring dplyr::group_by(contrast, depth_maps_generation_quality) %&gt;% make_contrast_vars() # remove out-of-sample obs brms_contrast_temp = brms_contrast_temp %&gt;% tidyr::separate_wider_delim( cols = contrast , delim = &quot; - &quot; , names = paste0( &quot;sorter&quot; , 1:(max(stringr::str_count(brms_contrast_temp$contrast, &quot;-&quot;))+1) ) , too_few = &quot;align_start&quot; , cols_remove = F ) %&gt;% dplyr::filter(sorter1!=sorter2) %&gt;% dplyr::inner_join( ptcld_validation_data %&gt;% dplyr::distinct(software, depth_maps_generation_quality) , by = dplyr::join_by(sorter1 == software, depth_maps_generation_quality) ) %&gt;% dplyr::inner_join( ptcld_validation_data %&gt;% dplyr::distinct(software, depth_maps_generation_quality) , by = dplyr::join_by(sorter2 == software, depth_maps_generation_quality) ) plot it plt_contrast( brms_contrast_temp # , caption_text = form_temp , y_axis_title = &quot;software&quot; , facet = &quot;depth_maps_generation_quality&quot; , label_size = 1.9 # , x_expand = c(0.25,0.1) ) + facet_wrap(facets = vars(depth_maps_generation_quality), ncol = 2) + labs( subtitle = &quot;posterior predictive distribution of group constrasts with 95% &amp; 50% HDI\\nby dense cloud quality&quot; , x = &quot;constrast DBH RMSE (cm)&quot; ) + theme( legend.position = c(.75, .13) ) + guides(fill = guide_colorbar(theme = theme( legend.key.width = unit(1, &quot;lines&quot;), legend.key.height = unit(7, &quot;lines&quot;) ))) ggplot2::ggsave( &quot;../data/sftwr_qlty_comp_dbh_rmse.png&quot; , plot = ggplot2::last_plot() + labs(subtitle = &quot;&quot;) , height = 7, width = 10.5 ) create plot for combining with other RMSE contrasts for publication ptchwrk_sftwr_qlty_comp_dbh_rmse = plt_contrast( brms_contrast_temp , y_axis_title = &quot;software contrast&quot; , facet = &quot;depth_maps_generation_quality&quot; , label_size = 1.7 , label = &quot;pr_diff_lab_sm&quot; , annotate_size = 1.8 ) + facet_wrap(facets = vars(depth_maps_generation_quality), ncol = 3) + labs( subtitle = &quot;&quot; , x = &quot;DBH RMSE (cm) constrast&quot; ) + theme( legend.position = &quot;inside&quot; , legend.position.inside = c(.8, .13) , axis.title.y = element_text(size = 10, face = &quot;bold&quot;) , axis.title.x = element_text(size = 8) ) + guides(fill = guide_colorbar(theme = theme( legend.key.width = unit(1, &quot;lines&quot;), legend.key.height = unit(6.5, &quot;lines&quot;) ))) # ptchwrk_sftwr_qlty_comp_dbh_rmse and summarize these contrasts table_temp = brms_contrast_temp %&gt;% dplyr::group_by(contrast, depth_maps_generation_quality, pr_lt_zero) %&gt;% tidybayes::median_hdi(value) %&gt;% dplyr::arrange(contrast, depth_maps_generation_quality) %&gt;% dplyr::select(contrast, depth_maps_generation_quality, value, .lower, .upper, pr_lt_zero) table_temp %&gt;% dplyr::select(-c(contrast)) %&gt;% kableExtra::kbl( digits = 1 , caption = &quot;DBH RMSE (cm)&lt;br&gt;95% HDI of the posterior predictive distribution of group contrasts&quot; , col.names = c( &quot;quality contrast&quot; , &quot;median difference&lt;br&gt;DBH RMSE (cm)&quot; , &quot;HDI low&quot;, &quot;HDI high&quot; , &quot;Pr(diff&lt;0)&quot; ) , escape = F ) %&gt;% kableExtra::kable_styling() %&gt;% kableExtra::pack_rows(index = table(forcats::fct_inorder(table_temp$contrast))) %&gt;% kableExtra::scroll_box(height = &quot;8in&quot;) Table 7.25: DBH RMSE (cm)95% HDI of the posterior predictive distribution of group contrasts quality contrast median differenceDBH RMSE (cm) HDI low HDI high Pr(diff&lt;0) OPENDRONEMAP - METASHAPE ultra high -0.2 -0.7 0.2 86% high 0.0 -0.5 0.5 55% medium 0.1 -0.4 0.6 39% low -0.2 -0.7 0.3 83% lowest -0.4 -1.0 0.1 96% PIX4D - METASHAPE ultra high -0.3 -0.9 0.2 88% high -0.4 -0.9 0.1 93% medium -0.4 -0.9 0.2 92% low -0.5 -1.0 0.1 96% PIX4D - OPENDRONEMAP ultra high -0.1 -0.6 0.5 61% high -0.4 -0.9 0.2 93% medium -0.5 -1.0 0.1 96% low -0.2 -0.8 0.3 83% 7.4.3.5 Software:Filtering - interaction draws_temp = tidyr::crossing( depth_maps_generation_filtering_mode = unique(ptcld_validation_data$depth_maps_generation_filtering_mode) , software = unique(ptcld_validation_data$software) ) %&gt;% tidybayes::add_epred_draws( brms_dbh_rmse_mod, allow_new_levels = T # this part is crucial , re_formula = ~ (1 | depth_maps_generation_filtering_mode) + (1 | software) + (1 | depth_maps_generation_filtering_mode:software) ) %&gt;% dplyr::rename(value = .epred) %&gt;% dplyr::mutate(med = tidybayes::median_hdci(value)$y) # plot draws_temp %&gt;% # remove out-of-sample obs dplyr::inner_join( ptcld_validation_data %&gt;% dplyr::distinct(depth_maps_generation_filtering_mode, software) , by = dplyr::join_by(depth_maps_generation_filtering_mode, software) ) %&gt;% # plot ggplot( mapping = aes( y = value, x = software , fill = med ) ) + geom_hline(yintercept = 0, color = &quot;gray33&quot;) + tidybayes::stat_eye( point_interval = median_hdi, .width = .95 , slab_alpha = 0.98 , interval_color = &quot;black&quot;, linewidth = 1 , point_color = &quot;black&quot;, point_fill = &quot;black&quot;, point_size = 1 ) + scale_fill_stepsn( n.breaks = 5 , colors = viridis::mako(n = 5, begin = 0.2, end = 0.9, direction = -1) , limits = c(0,lmt_dbh_cm_rmse) , labels = scales::comma_format(accuracy = 0.01) , show.limits = T ) + facet_grid(cols = vars(depth_maps_generation_filtering_mode)) + scale_y_continuous(limits = c(-0.02,NA)) + labs( x = &quot;software&quot;, y = &quot;DBH RMSE (cm)&quot; , subtitle = &quot;posterior predictive distribution of DBH RMSE (cm) with 95% HDI\\nby filtering mode&quot; ) + theme_light() + theme( legend.position = &quot;none&quot; , legend.direction = &quot;horizontal&quot; , axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1) , strip.text = element_text(color = &quot;black&quot;, face = &quot;bold&quot;) ) and a table of these 95% HDI values table_temp = draws_temp %&gt;% tidybayes::median_hdi(value) %&gt;% dplyr::select(-c(.point,.interval, .width,.row)) %&gt;% dplyr::arrange(software,depth_maps_generation_filtering_mode) table_temp %&gt;% dplyr::select(-c(software)) %&gt;% kableExtra::kbl( digits = 2 , caption = &quot;DBH RMSE (cm)&lt;br&gt;95% HDI of the posterior predictive distribution&quot; , col.names = c( &quot;filtering mode&quot; , &quot;DBH RMSE (cm)&lt;br&gt;median&quot; , &quot;HDI low&quot;, &quot;HDI high&quot; ) , escape = F ) %&gt;% kableExtra::kable_styling() %&gt;% kableExtra::pack_rows(index = table(forcats::fct_inorder(table_temp$software))) %&gt;% kableExtra::scroll_box(height = &quot;8in&quot;) Table 7.26: DBH RMSE (cm)95% HDI of the posterior predictive distribution filtering mode DBH RMSE (cm)median HDI low HDI high METASHAPE aggressive 6.73 3.15 10.19 moderate 6.57 3.04 10.06 mild 6.42 2.99 9.99 disabled 6.42 2.93 9.95 OPENDRONEMAP aggressive 6.42 3.00 10.01 moderate 6.37 2.90 9.90 mild 6.36 2.94 9.93 disabled 6.33 2.90 9.90 PIX4D aggressive 6.23 2.71 9.81 moderate 6.20 2.66 9.71 mild 6.03 2.45 9.47 disabled 6.01 2.59 9.61 we can also make pairwise comparisons # calculate contrast brms_contrast_temp = draws_temp %&gt;% tidybayes::compare_levels( value , by = depth_maps_generation_filtering_mode , comparison = &quot;pairwise&quot; ) %&gt;% dplyr::rename(contrast = depth_maps_generation_filtering_mode) # separate contrast brms_contrast_temp = brms_contrast_temp %&gt;% dplyr::ungroup() %&gt;% tidyr::separate_wider_delim( cols = contrast , delim = &quot; - &quot; , names = paste0( &quot;sorter&quot; , 1:(max(stringr::str_count(brms_contrast_temp$contrast, &quot;-&quot;))+1) ) , too_few = &quot;align_start&quot; , cols_remove = F ) %&gt;% dplyr::filter(sorter1!=sorter2) %&gt;% dplyr::mutate( dplyr::across( tidyselect::starts_with(&quot;sorter&quot;) , .fns = function(x){factor( x, ordered = T , levels = levels(ptcld_validation_data$depth_maps_generation_filtering_mode) )} ) , contrast = contrast %&gt;% forcats::fct_reorder( paste0(as.numeric(sorter1), as.numeric(sorter2)) %&gt;% as.numeric() ) %&gt;% # re order for filtering mode forcats::fct_rev() ) %&gt;% # median_hdi summary for coloring dplyr::group_by(contrast, software) %&gt;% make_contrast_vars() # remove out-of-sample obs brms_contrast_temp = brms_contrast_temp %&gt;% dplyr::inner_join( ptcld_validation_data %&gt;% dplyr::distinct(software, depth_maps_generation_filtering_mode) , by = dplyr::join_by(software, sorter1 == depth_maps_generation_filtering_mode) ) %&gt;% dplyr::inner_join( ptcld_validation_data %&gt;% dplyr::distinct(software, depth_maps_generation_filtering_mode) , by = dplyr::join_by(software, sorter2 == depth_maps_generation_filtering_mode) ) plot it plt_contrast( brms_contrast_temp # , caption_text = form_temp , y_axis_title = &quot;filtering mode&quot; , facet = &quot;software&quot; , label_size = 1.8 , x_expand = c(0.33,0.1) ) + labs( subtitle = &quot;posterior predictive distribution of group constrasts with 95% &amp; 50% HDI\\nby software&quot; , x = &quot;constrast DBH RMSE (cm)&quot; ) ggplot2::ggsave( &quot;../data/fltr_sftwr_comp_dbh_rmse.png&quot; , plot = ggplot2::last_plot() + labs(subtitle = &quot;&quot;) , height = 7, width = 10.5 ) create plot for combining with other RMSE contrasts for publication ptchwrk_fltr_sftwr_comp_dbh_rmse = plt_contrast( brms_contrast_temp , y_axis_title = &quot;filtering mode contrast&quot; , facet = &quot;software&quot; , label_size = 1.7 , label = &quot;pr_diff_lab_sm&quot; , annotate_size = 1.8 ) + labs( subtitle = &quot;&quot; # &quot;constrast Height RMSE (m)&quot; , x = &quot;DBH RMSE (cm) constrast&quot; ) + theme( legend.position=&quot;none&quot; , axis.title.y = element_text(size = 10, face = &quot;bold&quot;) , axis.title.x = element_text(size = 8) ) # ptchwrk_fltr_sftwr_comp_dbh_rmse and summarize these contrasts table_temp = brms_contrast_temp %&gt;% dplyr::group_by(contrast, software, pr_lt_zero) %&gt;% tidybayes::median_hdi(value) %&gt;% dplyr::arrange(contrast, software) %&gt;% dplyr::select(contrast, software, value, .lower, .upper, pr_lt_zero) %&gt;% dplyr::arrange(software, contrast) table_temp %&gt;% dplyr::select(-c(software)) %&gt;% kableExtra::kbl( digits = 1 , caption = &quot;DBH RMSE (cm)&lt;br&gt;95% HDI of the posterior predictive distribution of group contrasts&quot; , col.names = c( &quot;filtering contrast&quot; , &quot;median difference&lt;br&gt;DBH RMSE (cm)&quot; , &quot;HDI low&quot;, &quot;HDI high&quot; , &quot;Pr(diff&lt;0)&quot; ) , escape = F ) %&gt;% kableExtra::kable_styling() %&gt;% kableExtra::pack_rows(index = table(forcats::fct_inorder(table_temp$software))) %&gt;% kableExtra::scroll_box(height = &quot;8in&quot;) Table 7.27: DBH RMSE (cm)95% HDI of the posterior predictive distribution of group contrasts filtering contrast median differenceDBH RMSE (cm) HDI low HDI high Pr(diff&lt;0) METASHAPE disabled - mild 0.0 -0.3 0.4 49% disabled - moderate -0.1 -0.5 0.2 79% disabled - aggressive -0.3 -0.7 0.1 93% mild - moderate -0.1 -0.5 0.2 80% mild - aggressive -0.3 -0.8 0.1 94% moderate - aggressive -0.1 -0.6 0.2 78% OPENDRONEMAP disabled - mild 0.0 -0.4 0.3 55% disabled - moderate 0.0 -0.4 0.4 57% disabled - aggressive -0.1 -0.5 0.3 68% mild - moderate 0.0 -0.4 0.4 52% mild - aggressive -0.1 -0.5 0.3 63% moderate - aggressive -0.1 -0.4 0.3 63% PIX4D disabled - mild 0.0 -0.4 0.4 55% disabled - moderate -0.2 -0.6 0.2 83% mild - moderate -0.1 -0.6 0.2 80% 7.4.3.6 Software:Quality:Filtering - interaction # get draws fltr_sftwr_draws_temp = tidyr::crossing( depth_maps_generation_quality = unique(ptcld_validation_data$depth_maps_generation_quality) , depth_maps_generation_filtering_mode = unique(ptcld_validation_data$depth_maps_generation_filtering_mode) , software = unique(ptcld_validation_data$software) ) %&gt;% tidybayes::add_epred_draws( brms_dbh_rmse_mod, allow_new_levels = T # this part is crucial , re_formula = ~ (1 | depth_maps_generation_quality) + # main effects (1 | depth_maps_generation_quality) + (1 | depth_maps_generation_filtering_mode) + (1 | software) + # two-way interactions (1 | depth_maps_generation_quality:depth_maps_generation_filtering_mode) + (1 | depth_maps_generation_quality:software) + (1 | depth_maps_generation_filtering_mode:software) + # three-way interactions (1 | depth_maps_generation_quality:depth_maps_generation_filtering_mode:software) ) %&gt;% dplyr::rename(value = .epred) %&gt;% dplyr::mutate(med = tidybayes::median_hdci(value)$y) # plot qlty_fltr_sftwr_dbh_rmse = fltr_sftwr_draws_temp %&gt;% dplyr::inner_join( ptcld_validation_data %&gt;% dplyr::distinct(software, depth_maps_generation_quality, depth_maps_generation_filtering_mode) , by = dplyr::join_by(software, depth_maps_generation_quality, depth_maps_generation_filtering_mode) ) %&gt;% dplyr::mutate(depth_maps_generation_quality = depth_maps_generation_quality %&gt;% forcats::fct_rev()) %&gt;% ggplot( mapping = aes( y = value , x = depth_maps_generation_filtering_mode , fill = med ) ) + geom_hline(yintercept = 0, color = &quot;gray33&quot;) + tidybayes::stat_eye( point_interval = median_hdi, .width = .95 , slab_alpha = 0.98 , interval_color = &quot;black&quot;, linewidth = 1 , point_color = &quot;black&quot;, point_fill = &quot;black&quot;, point_size = 1 ) + scale_fill_stepsn( n.breaks = 5 , colors = viridis::mako(n = 5, begin = 0.2, end = 0.9, direction = -1) , limits = c(0,lmt_dbh_cm_rmse) , labels = scales::comma_format(accuracy = 0.01) , show.limits = T ) + facet_grid( rows = vars(software) , cols = vars(depth_maps_generation_quality) # , switch = &quot;y&quot; ) + scale_y_continuous(limits = c(-0.02,NA)) + labs( x = &quot;filtering mode&quot;, y = &quot;DBH RMSE (cm)&quot; , subtitle = &quot;posterior predictive distribution of DBH RMSE (cm) with 95% HDI\\nby dense cloud quality and software&quot; # , caption = form_temp ) + theme_light() + theme( legend.position = &quot;none&quot; , legend.direction = &quot;horizontal&quot; , axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1) , strip.text = element_text(color = &quot;black&quot;, face = &quot;bold&quot;) , panel.grid = element_blank() # , strip.placement = &quot;outside&quot; ) + guides( fill = guide_legend(override.aes = list(shape = NA, size = 6, alpha = 0.9, lwd = NA)) ) # print it qlty_fltr_sftwr_dbh_rmse ggplot2::ggsave(&quot;../data/qlty_fltr_sftwr_dbh_rmse.png&quot;, height = 7, width = 10.5) and a table of these 95% HDI values table_temp = fltr_sftwr_draws_temp %&gt;% tidybayes::median_hdi(value) %&gt;% dplyr::inner_join( ptcld_validation_data %&gt;% dplyr::distinct(software, depth_maps_generation_quality, depth_maps_generation_filtering_mode) , by = dplyr::join_by(software, depth_maps_generation_quality, depth_maps_generation_filtering_mode) ) %&gt;% dplyr::mutate(depth_maps_generation_quality = depth_maps_generation_quality %&gt;% forcats::fct_rev()) %&gt;% dplyr::select(c( software, depth_maps_generation_quality, depth_maps_generation_filtering_mode , value, .lower, .upper )) %&gt;% dplyr::ungroup() %&gt;% dplyr::arrange(software, depth_maps_generation_quality, depth_maps_generation_filtering_mode) table_temp %&gt;% # dplyr::select(-c(software)) %&gt;% kableExtra::kbl( digits = 2 , caption = &quot;DBH RMSE (cm)&lt;br&gt;95% HDI of the posterior predictive distribution&quot; , col.names = c( &quot;software&quot;, &quot;quality&quot;, &quot;filtering mode&quot; , &quot;DBH RMSE (cm)&lt;br&gt;median&quot; , &quot;HDI low&quot;, &quot;HDI high&quot; ) , escape = F ) %&gt;% kableExtra::kable_styling() %&gt;% # kableExtra::pack_rows(index = table(forcats::fct_inorder(table_temp$software))) %&gt;% kableExtra::collapse_rows(columns = 1:2, valign = &quot;top&quot;) %&gt;% kableExtra::scroll_box(height = &quot;8in&quot;) Table 7.28: DBH RMSE (cm)95% HDI of the posterior predictive distribution software quality filtering mode DBH RMSE (cm)median HDI low HDI high METASHAPE lowest aggressive 7.42 3.93 10.89 moderate 7.28 3.87 10.76 mild 7.02 3.56 10.48 disabled 7.05 3.69 10.60 low aggressive 7.06 3.67 10.57 moderate 6.88 3.45 10.36 mild 6.67 3.32 10.21 disabled 6.68 3.24 10.13 medium aggressive 6.62 3.18 10.09 moderate 6.43 2.95 9.85 mild 6.29 2.90 9.82 disabled 6.30 2.81 9.73 high aggressive 6.43 2.97 9.89 moderate 6.25 2.81 9.74 mild 6.12 2.68 9.59 disabled 6.14 2.73 9.63 ultra high aggressive 6.27 2.89 9.82 moderate 6.11 2.67 9.57 mild 6.00 2.64 9.55 disabled 5.98 2.61 9.50 OPENDRONEMAP lowest aggressive 6.78 3.36 10.26 moderate 6.73 3.36 10.25 mild 6.68 3.39 10.31 disabled 6.67 3.28 10.17 low aggressive 6.67 3.27 10.17 moderate 6.60 3.15 10.07 mild 6.56 3.21 10.13 disabled 6.52 3.08 10.01 medium aggressive 6.56 3.26 10.13 moderate 6.48 3.12 10.04 mild 6.50 3.12 10.01 disabled 6.48 3.04 9.93 high aggressive 6.26 2.99 9.92 moderate 6.18 2.83 9.73 mild 6.22 2.86 9.77 disabled 6.20 2.81 9.72 ultra high aggressive 5.86 2.43 9.31 moderate 5.80 2.40 9.29 mild 5.84 2.39 9.28 disabled 5.77 2.33 9.26 PIX4D low moderate 6.48 3.02 9.94 mild 6.22 2.81 9.68 disabled 6.16 2.68 9.58 medium moderate 6.08 2.70 9.63 mild 5.92 2.49 9.38 disabled 5.90 2.52 9.43 high moderate 5.87 2.42 9.34 mild 5.73 2.39 9.29 disabled 5.72 2.28 9.19 ultra high moderate 5.80 2.37 9.28 mild 5.69 2.19 9.09 disabled 5.64 2.18 9.10 we can also make pairwise comparisons # calculate contrast brms_contrast_temp = fltr_sftwr_draws_temp %&gt;% tidybayes::compare_levels( value , by = depth_maps_generation_filtering_mode , comparison = &quot;pairwise&quot; ) %&gt;% dplyr::rename(contrast = depth_maps_generation_filtering_mode) # separate contrast brms_contrast_temp = brms_contrast_temp %&gt;% dplyr::ungroup() %&gt;% tidyr::separate_wider_delim( cols = contrast , delim = &quot; - &quot; , names = paste0( &quot;sorter&quot; , 1:(max(stringr::str_count(brms_contrast_temp$contrast, &quot;-&quot;))+1) ) , too_few = &quot;align_start&quot; , cols_remove = F ) %&gt;% dplyr::filter(sorter1!=sorter2) %&gt;% dplyr::mutate( dplyr::across( tidyselect::starts_with(&quot;sorter&quot;) , .fns = function(x){factor( x, ordered = T , levels = levels(ptcld_validation_data$depth_maps_generation_filtering_mode) )} ) , contrast = contrast %&gt;% forcats::fct_reorder( paste0(as.numeric(sorter1), as.numeric(sorter2)) %&gt;% as.numeric() ) %&gt;% # re order for filtering mode forcats::fct_rev() ) %&gt;% # median_hdi summary for coloring dplyr::group_by(contrast, software, depth_maps_generation_quality) %&gt;% make_contrast_vars() # remove out-of-sample obs brms_contrast_temp = brms_contrast_temp %&gt;% dplyr::inner_join( ptcld_validation_data %&gt;% dplyr::distinct(software, depth_maps_generation_quality, depth_maps_generation_filtering_mode) , by = dplyr::join_by(software, depth_maps_generation_quality, sorter1==depth_maps_generation_filtering_mode) ) %&gt;% dplyr::inner_join( ptcld_validation_data %&gt;% dplyr::distinct(software, depth_maps_generation_quality, depth_maps_generation_filtering_mode) , by = dplyr::join_by(software, depth_maps_generation_quality, sorter2==depth_maps_generation_filtering_mode) ) %&gt;% dplyr::mutate(depth_maps_generation_quality = depth_maps_generation_quality %&gt;% forcats::fct_rev()) plot it brms_contrast_temp %&gt;% plt_contrast( facet = c(&quot;depth_maps_generation_quality&quot;, &quot;software&quot;) , y_axis_title = &quot;filtering mode&quot; , label_size = 0 , x_expand = c(-0.1,-0.1) ) + facet_grid( rows = vars(software) , cols = vars(depth_maps_generation_quality) ) + labs( subtitle = &quot;posterior predictive distribution of group constrasts with 95% &amp; 50% HDI\\nby dense cloud quality and software&quot; , x = &quot;constrast DBH RMSE (cm)&quot; ) ggplot2::ggsave( &quot;../data/qlty_fltr_sftwr_comp_dbh_rmse.png&quot; , plot = ggplot2::last_plot() + labs(subtitle = &quot;&quot;) , height = 7, width = 10.5 ) Export some final images for publication p1_temp = qlty_fltr_sftwr_dbh_me + labs(subtitle = &quot;A: DBH Mean Error (cm)&quot;) + theme(plot.subtitle = element_text(face=&quot;bold&quot;)) p2_temp = qlty_fltr_sftwr_dbh_rmse + labs(subtitle = &quot;B: DBH RMSE (cm)&quot;) + theme(plot.subtitle = element_text(face=&quot;bold&quot;)) # export p1_temp / p2_temp ggplot2::ggsave( filename = paste0(&quot;../data/qlty_fltr_sftwr_dbh_comb.jpeg&quot;) , plot = ggplot2::last_plot() , width = 8.5 , height = 11 , units = &quot;in&quot; , dpi = &quot;print&quot; ) patchwork of Height RMSE contrasts layout_temp = c( # area(t, l, b, r) patchwork::area(2, 1, 2, 1) , patchwork::area(2, 3, 2, 3) , patchwork::area(4, 1, 4, 3) ) # check the layout # plot(layout_temp) ############################ # patchwork for height ############################ ptchwrk_qlty_sftwr_comp_ht_rmse + labs(subtitle = &quot;A: Quality Contrast by Software&quot;) + theme(plot.background = element_rect(colour = &quot;gray88&quot;, fill=NA, size=3)) + ptchwrk_fltr_sftwr_comp_ht_rmse + labs(subtitle = &quot;B: Filtering Mode Contrast by Software&quot;) + theme(plot.background = element_rect(colour = &quot;gray88&quot;, fill=NA, size=3)) + patchwork::free( ptchwrk_sftwr_qlty_comp_ht_rmse + labs(subtitle = &quot;C: Software Contrast by Quality&quot;) + theme(plot.background = element_rect(colour = &quot;gray88&quot;, fill=NA, size=3)) ) + # plot_annotation(tag_levels = list(c(&#39;#&#39;, &#39;&amp;&#39;), &#39;1&#39;)) + patchwork::plot_layout( design = layout_temp , widths = c(1,0.01,1) , heights = c(0.01,1,0.01,1,0.01) ) &amp; scale_x_continuous( limits = c(-0.7,0.45) , breaks = seq(-0.8,0.4,0.2) , labels = seq(-0.8,0.4,0.2) %&gt;% scales::number(accuracy = 0.1) ) &amp; theme( axis.title.y = element_blank() , plot.subtitle = element_text(face = &quot;bold&quot;, hjust = 0.0) # , plot.background = element_rect(colour = &quot;gray88&quot;, fill=NA, size=3) ) ggplot2::ggsave( filename = paste0(&quot;../data/all_ht_rmse_contrasts.jpeg&quot;) , plot = ggplot2::last_plot() , width = 11 , height = 8.5 , units = &quot;in&quot; , dpi = &quot;print&quot; ) patchwork of DBH RMSE contrasts layout_temp = c( # area(t, l, b, r) patchwork::area(2, 1, 2, 1) , patchwork::area(2, 3, 2, 3) , patchwork::area(4, 1, 4, 3) ) # check the layout # plot(layout_temp) ############################ # patchwork for height ############################ ptchwrk_qlty_sftwr_comp_dbh_rmse + labs(subtitle = &quot;A: Quality Contrast by Software&quot;) + theme(plot.background = element_rect(colour = &quot;gray88&quot;, fill=NA, size=3)) + ptchwrk_fltr_sftwr_comp_dbh_rmse + labs(subtitle = &quot;B: Filtering Mode Contrast by Software&quot;) + theme(plot.background = element_rect(colour = &quot;gray88&quot;, fill=NA, size=3)) + patchwork::free( ptchwrk_sftwr_qlty_comp_dbh_rmse + labs(subtitle = &quot;C: Software Contrast by Quality&quot;) + theme(plot.background = element_rect(colour = &quot;gray88&quot;, fill=NA, size=3)) ) + # plot_annotation(tag_levels = list(c(&#39;#&#39;, &#39;&amp;&#39;), &#39;1&#39;)) + patchwork::plot_layout( design = layout_temp , widths = c(1,0.01,1) , heights = c(0.01,1,0.01,1,0.01) ) &amp; scale_x_continuous( limits = c(-3,2) , breaks = seq(-4,2,2) , labels = seq(-4,2,2) %&gt;% scales::number(accuracy = 1) ) &amp; theme( axis.title.y = element_blank() , plot.subtitle = element_text(face = &quot;bold&quot;, hjust = 0.0) # , plot.background = element_rect(colour = &quot;gray88&quot;, fill=NA, size=3) ) ggplot2::ggsave( filename = paste0(&quot;../data/all_dbh_rmse_contrasts.jpeg&quot;) , plot = ggplot2::last_plot() , width = 11 , height = 8.5 , units = &quot;in&quot; , dpi = &quot;print&quot; ) 7.5 Posterior Predictive Checks Markov chain Monte Carlo (MCMC) simulations were conducted using the brms package (Bürkner 2017) to estimate posterior predictive distributions of the parameters of interest. We ran three chains of 100,000 iterations with the first 50,000 discarded as burn-in. Trace-plots were utilized to visually assess model convergence and sufficient convergence was checked with \\(\\hat{R}\\) values near 1 (Brooks &amp; Gelman, 1998). Posterior predictive checks were used to evaluate model goodness-of-fit by comparing data simulated from the model with the observed data used to estimate the model parameters (Hobbs &amp; Hooten, 2015). Calculating the proportion of MCMC iterations in which the test statistic (i.e., mean and sum of squares) from the simulated data and observed data are more extreme than one another provides the Bayesian P-value. Lack of fit is indicated by a value close to 0 or 1 while a value of 0.5 indicates perfect fit (Hobbs &amp; Hooten, 2015). To learn more about this approach to posterior predictive checks, check out Gabry’s (2022) vignette, Graphical posterior predictive checks using the bayesplot package. 7.5.1 Prior Distriubutions plt_prior1+plt_prior2+plt_prior3+plt_prior4 &amp; theme(strip.text = element_text(size = 6)) 7.5.2 Trace-plots check the trace plots for problems with convergence of the Markov chains 7.5.2.1 Height Mean Error # height mean error plot(brms_ht_me_mod) 7.5.2.2 Height RMSE # height rmse plot(brms_ht_rmse_mod) 7.5.2.3 DBH Mean Error # dbh me plot(brms_dbh_me_mod) 7.5.2.4 DBH RMSE # dbh rmse plot(brms_dbh_rmse_mod) 7.5.3 \\(\\hat{R}\\) values plt_rhat_temp &lt;- function(my_mod) { my_mod %&gt;% brms::rhat() %&gt;% as.data.frame() %&gt;% tibble::rownames_to_column(var = &quot;parameter&quot;) %&gt;% dplyr::rename_with(tolower) %&gt;% dplyr::rename(rhat = 2) %&gt;% dplyr::filter( stringr::str_starts(parameter, &quot;b_&quot;) | stringr::str_starts(parameter, &quot;r_&quot;) | stringr::str_starts(parameter, &quot;sd_&quot;) | parameter == &quot;phi&quot; | parameter == &quot;sigma&quot; ) %&gt;% dplyr::mutate( parameter = parameter %&gt;% stringr::str_replace_all(&quot;depth_maps_generation_quality&quot;, &quot;quality&quot;) %&gt;% stringr::str_replace_all(&quot;depth_maps_generation_filtering_mode&quot;, &quot;filtering&quot;) , chk = (rhat &lt;= 1*0.998 | rhat &gt;= 1*1.002) ) %&gt;% ggplot(aes(x = rhat, y = parameter, color = chk, fill = chk)) + geom_vline(xintercept = 1, linetype = &quot;dashed&quot;, color = &quot;gray44&quot;, lwd = 1.2) + geom_vline(xintercept = 1*0.998, lwd = 1.5) + geom_vline(xintercept = 1*1.002, lwd = 1.5) + geom_vline(xintercept = 1*0.999, lwd = 1.2, color = &quot;gray33&quot;) + geom_vline(xintercept = 1*1.001, lwd = 1.2, color = &quot;gray33&quot;) + geom_point() + scale_fill_manual(values = c(&quot;navy&quot;, &quot;firebrick&quot;)) + scale_color_manual(values = c(&quot;navy&quot;, &quot;firebrick&quot;)) + scale_y_discrete(NULL, breaks = NULL) + labs( x = latex2exp::TeX(&quot;$\\\\hat{R}$&quot;) , subtitle = latex2exp::TeX(&quot;MCMC chain convergence check for $\\\\hat{R}$ values&quot;) ) + theme_light() + theme( legend.position = &quot;none&quot; , axis.text.y = element_text(size = 3) , panel.grid.major.x = element_blank() , panel.grid.minor.x = element_blank() , plot.title = element_text(size = 9) , plot.subtitle = element_text(size = 8) , axis.title.y = element_blank() , axis.title.x = element_text(size = 9) , panel.grid = element_blank() , axis.text.x = element_text(size = 6.5) ) } # plot together with patchwork # height mean error brms_ht_me_mod %&gt;% plt_rhat_temp() + labs(title = &quot;Height Mean Error (bias)&quot;) + # height rmse brms_ht_rmse_mod %&gt;% plt_rhat_temp() + labs(title = &quot;Height RMSE (precision)&quot;) + # dbh me brms_dbh_me_mod %&gt;% plt_rhat_temp() + labs(title = &quot;DBH Mean Error (bias)&quot;) + # dbh rmse brms_dbh_rmse_mod %&gt;% plt_rhat_temp() + labs(title = &quot;DBH RMSE (precision)&quot;) &amp; theme(plot.subtitle = element_blank()) 7.5.4 ESS values The effective length of an MCMC chain is indicated by the effective sample size (ESS), which refers to the sample size of the MCMC chain not to the sample size of the data Kruschke (2015) notes: One simple guideline is this: For reasonably accurate and stable estimates of the limits of the 95% HDI, an ESS of 10,000 is recommended. This is merely a heuristic based on experience with practical applications, it is not a requirement. If accuracy of the HDI limits is not crucial for your application, then a smaller ESS may be sufficient. (p.184) plt_ess_temp &lt;- function(my_mod) { # get ess values from model summary dplyr::bind_rows( summary(my_mod) %&gt;% purrr::pluck(&quot;random&quot;) %&gt;% purrr::flatten() %&gt;% purrr::keep_at(~ .x == &quot;Bulk_ESS&quot;) %&gt;% unlist() %&gt;% dplyr::as_tibble() , summary(my_mod) %&gt;% purrr::pluck(&quot;fixed&quot;) %&gt;% purrr::flatten() %&gt;% purrr::keep_at(~ .x == &quot;Bulk_ESS&quot;) %&gt;% unlist() %&gt;% dplyr::as_tibble() ) %&gt;% dplyr::rename(ess = 1) %&gt;% dplyr::mutate(parameter = dplyr::row_number(), chk = ess&lt;10000) %&gt;% ggplot(aes(x = ess, y = parameter, color = chk, fill = chk)) + geom_vline(xintercept = 10000, linetype = &quot;dashed&quot;, color = &quot;gray44&quot;, lwd = 1.2) + geom_segment( aes(x = 0, xend=ess, yend=parameter), color=&quot;black&quot;) + geom_point() + scale_fill_manual(values = c(&quot;blue4&quot;, &quot;blue3&quot;)) + scale_color_manual(values = c(&quot;blue4&quot;, &quot;blue3&quot;)) + scale_y_continuous(NULL, breaks = NULL) + scale_x_continuous(labels = scales::comma) + labs( x = &quot;ESS&quot; , subtitle = &quot;MCMC chain resolution check for effective sample size (ESS) values&quot; , y = &quot;&quot; ) + theme_light() + theme( legend.position = &quot;none&quot; , axis.text.y = element_text(size = 4) , panel.grid.major.x = element_blank() , panel.grid.minor.x = element_blank() , plot.title = element_text(size = 9) , plot.subtitle = element_text(size = 8) , axis.title.y = element_blank() , axis.title.x = element_text(size = 9) , axis.text.x = element_text(size = 6.5) ) } # plot together with patchwork # height mean error brms_ht_me_mod %&gt;% plt_ess_temp() + labs(title = &quot;Height Mean Error (bias)&quot;) + # height rmse brms_ht_rmse_mod %&gt;% plt_ess_temp() + labs(title = &quot;Height RMSE (precision)&quot;) + # dbh me brms_dbh_me_mod %&gt;% plt_ess_temp() + labs(title = &quot;DBH Mean Error (bias)&quot;) + # dbh rmse brms_dbh_rmse_mod %&gt;% plt_ess_temp() + labs(title = &quot;DBH RMSE (precision)&quot;) &amp; theme(plot.subtitle = element_blank()) 7.5.5 Mean and SD posterior predictive check for the overall model combining mean and sd plt_pp_temp &lt;- function(my_mod) { my_mod %&gt;% brms::pp_check(type = &quot;stat_2d&quot;, ndraws = 5000) + theme_light() + theme( legend.position = &quot;top&quot;, legend.direction = &quot;horizontal&quot; , legend.text = element_text(size = 8) , plot.title = element_text(size = 9) ) } # plot together with patchwork # height mean error brms_ht_me_mod %&gt;% plt_pp_temp() + labs(title = &quot;Height Mean Error (bias)&quot;) + # height rmse brms_ht_rmse_mod %&gt;% plt_pp_temp() + labs(title = &quot;Height RMSE (precision)&quot;) + # dbh me brms_dbh_me_mod %&gt;% plt_pp_temp() + labs(title = &quot;DBH Mean Error (bias)&quot;) + # dbh rmse brms_dbh_rmse_mod %&gt;% plt_pp_temp() + labs(title = &quot;DBH RMSE (precision)&quot;) 7.5.6 Bayesian p-value The Bayesian p-value is the probability that a test statistic in the reference distribution exceeds its value in the data. The Bayesian p-value is calculated from the posterior predictive distribution of the new data and the distribution of the observed data. We estimate the probability that the test statistic calculated from “new” data arising from our model (\\(y_{new}\\)) is more extreme than the test statistic calculated from the observed data (\\(y\\)): \\(\\text{P-value}(y) = Pr(T(y_{new}) &gt; T(y))\\) where the test statistic \\(T(y)\\) describes the distribution of the data as a summary of the data; it could be the mean, variance, the coefﬁcient of variation, the kurtosis, the maximum, or the minimum of the observed data set, or it might be an “omnibus” statistic like a squared discrepancy or a chi-square value Hobbs and Hooten (2015, p. 188) Bayesian P values for mean and standard deviation test statistics The P values for the mean (P mean) give the probability that the mean of the data of new, out-of-sample observations simulated from the model exceeds the mean of the observed data. The P values for the standard deviation (P SD) give the probability that the standard deviation of new, out-of-sample observations simulated from the model exceeds the standard deviation of the observed data. Large (\\(\\gtrapprox 0.90\\)) or small (\\(\\lessapprox 0.10\\)) values indicate lack of fit. Hobbs and Hooten (2015);Hobbs et al. (2024, Appendix S2 p. 8) Check the Bayesian p-values between the models # get the model p-values set.seed(16) # replicate results dplyr::bind_rows( get_mod_p_val(brms_ht_me_mod, ndraws = 5000) %&gt;% dplyr::mutate(model = &quot;brms_ht_me_mod&quot;) , get_mod_p_val(brms_ht_rmse_mod, ndraws = 5000) %&gt;% dplyr::mutate(model = &quot;brms_ht_rmse_mod&quot;) , get_mod_p_val(brms_dbh_me_mod, ndraws = 5000) %&gt;% dplyr::mutate(model = &quot;brms_dbh_me_mod&quot;) , get_mod_p_val(brms_dbh_rmse_mod, ndraws = 5000) %&gt;% dplyr::mutate(model = &quot;brms_dbh_rmse_mod&quot;) ) %&gt;% dplyr::relocate(model) %&gt;% kableExtra::kbl(digits = 3) %&gt;% kableExtra::kable_styling() model P.mean P.sd brms_ht_me_mod 0.500 0.575 brms_ht_rmse_mod 0.510 0.621 brms_dbh_me_mod 0.506 0.557 brms_dbh_rmse_mod 0.506 0.556 "],["stand_ba.html", "Section 8 Statistical Analysis: Stand Basal Area 8.1 Setup 8.2 BA Percentage Error (bias) 8.3 BA Absolute Percentage Error (precision) 8.4 Posterior Predictive Checks", " Section 8 Statistical Analysis: Stand Basal Area In this section, we’ll evaluate the influence of the processing parameters on UAS-determined stand basal area. The accuracy UAS-derived stand basal area is impacted by the detection of individual trees (modeled in this section) and the estimated DBH of those detected trees (modeled in this section). Even though there are concerns with the under-detection of smaller trees in the understory (Tinkham &amp; Swayze 2021), the use of tree lists derived from remote sensing data (i.e. UAS SfM and Lidar) can still be useful for monitoring aspects of ecosystem function that are driven by large trees (Jeronimo et al. 2018). Jeronimo et al. 2018 summarize this idea: Large trees dominate basal area and biomass (Lutz et al. 2012; Bastin et al. 2015), carbon accumulation and growth (Sillett et al. 2010; Stephenson et al. 2014), and stand spatial heterogeneity (Lutz et al. 2013), and they provide unique structures that are keystone elements of many vertebrate species’ habitat requirements (Tews et al. 2004; North et al. 2017). Analysis of ITD results can capture the majority of variation in these processes even while omitting many smaller trees. For example, several studies have predicted biomass and volume directly from ITD results using allometric equations, explaining 67–93 percent of variation in even-aged pine plantations (Bortolot and Wynne 2005; Popescu 2007) and achieving error rates less than about 30 percent for Douglas-fir forests in various successional stages (Edson and Wing 2011). (p. 341) We will utilize our “full” model presented here 8.1 Setup load the data if needed # load data if needed if(ls()[ls() %in% &quot;ptcld_validation_data&quot;] %&gt;% length()==0){ ptcld_validation_data = readr::read_csv(&quot;../data/ptcld_full_analysis_data.csv&quot;) %&gt;% dplyr::mutate( depth_maps_generation_quality = factor( depth_maps_generation_quality %&gt;% tolower() %&gt;% stringr::str_replace_all(&quot;ultrahigh&quot;, &quot;ultra high&quot;) , ordered = TRUE , levels = c( &quot;lowest&quot; , &quot;low&quot; , &quot;medium&quot; , &quot;high&quot; , &quot;ultra high&quot; ) ) %&gt;% forcats::fct_rev() , depth_maps_generation_filtering_mode = factor( depth_maps_generation_filtering_mode %&gt;% tolower() , ordered = TRUE , levels = c( &quot;disabled&quot; , &quot;mild&quot; , &quot;moderate&quot; , &quot;aggressive&quot; ) ) %&gt;% forcats::fct_rev() ) } load our plotting functions if needed (not showing these functions here but see the prior section for function definitions) 8.2 BA Percentage Error (bias) 8.2.1 Summary Statistics # summarize data dta_temp = ptcld_validation_data %&gt;% dplyr::group_by(software, depth_maps_generation_quality, depth_maps_generation_filtering_mode) %&gt;% # collapse across study site dplyr::summarise( basal_area_pct_error = mean(basal_area_pct_error, na.rm = T) , n = dplyr::n() ) # set limits for color scale lmt_basal_area_pct_error = ceiling(10*max(abs(range(dta_temp$basal_area_pct_error, na.rm = T))))/10 # scales::show_col(scales::pal_dichromat(&quot;BluetoOrange.10&quot;)(10)) # scales::show_col(scales::pal_div_gradient()(seq(0, 1, length.out = 7))) # plot it dta_temp %&gt;% ggplot(mapping = aes( y = depth_maps_generation_quality , x = depth_maps_generation_filtering_mode , fill = basal_area_pct_error , label = paste0(scales::percent(basal_area_pct_error,accuracy = 0.1), &quot;\\n(n=&quot;, n,&quot;)&quot;) )) + geom_tile(color = &quot;white&quot;) + geom_text(color = &quot;white&quot;, size = 3) + facet_grid(cols = vars(software)) + scale_x_discrete(expand = c(0, 0)) + scale_y_discrete(expand = c(0, 0)) + scale_fill_stepsn( n.breaks = 7 , colors = scales::pal_div_gradient()(seq(0, 1, length.out = 7)) , limits = c(-lmt_basal_area_pct_error,lmt_basal_area_pct_error) , labels = scales::percent_format(accuracy = 1) , show.limits = T ) + labs( x = &quot;filtering mode&quot; , y = &quot;quality&quot; , fill = &quot;Basal Area % Error&quot; , title = &quot;mean basal area percentage error and # of study sites&quot; , subtitle = paste( &quot;negative values = UAS basal area &lt; field basal area&quot; , &quot; || &quot; , &quot;positive values = UAS basal area &gt; field basal area&quot; ) ) + theme_light() + theme( # legend.position = &quot;none&quot; axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1) , panel.background = element_blank() , panel.grid = element_blank() # , plot.title = element_text(hjust = 0.5) # , plot.subtitle = element_text(hjust = 0.5) , strip.text = element_text(color = &quot;black&quot;, face = &quot;bold&quot;) ) let’s check the distribution (of our dependent or \\(y\\) variable) # distribution ptcld_validation_data %&gt;% ggplot(mapping = aes(x = basal_area_pct_error)) + geom_hline(yintercept = 0, color = &quot;gray77&quot;) + geom_vline(xintercept = 0, color = &quot;gray77&quot;) + # geom_vline(xintercept = c(0,1)) + geom_density(fill = &quot;lightblue&quot;, alpha = 0.7, color = NA) + labs(y=&quot;&quot;,x=&quot;Basal Area % Error&quot;) + scale_y_continuous(breaks = c(0)) + scale_x_continuous(breaks = scales::extended_breaks(10), labels = scales::percent_format(accuracy = 1)) + theme_light() + theme(panel.grid = element_blank()) and the summary statistics ptcld_validation_data %&gt;% dplyr::ungroup() %&gt;% dplyr::select(basal_area_pct_error) %&gt;% dplyr::summarise( dplyr::across( dplyr::everything() , .fns = list( mean = ~ mean(.x,na.rm=T), median = ~ median(.x,na.rm=T), sd = ~ sd(.x,na.rm=T) , min = ~ min(.x,na.rm=T), max = ~ max(.x,na.rm=T) , q25 = ~ quantile(.x, 0.25, na.rm = T) , q75 = ~ quantile(.x, 0.75, na.rm = T) ) , .names = &quot;{.fn}&quot; ) ) %&gt;% tidyr::pivot_longer(everything()) %&gt;% kableExtra::kbl(caption = &quot;summary: `basal_area_pct_error`&quot;, digits = 3, col.names = NULL) %&gt;% kableExtra::kable_styling() Table 8.1: summary: basal_area_pct_error mean -0.131 median -0.104 sd 0.338 min -1.000 max 0.519 q25 -0.275 q75 0.066 8.2.2 Model: BA percentage error # from Kurz: gamma_a_b_from_omega_sigma = function(mode, sd) { if (mode &lt;= 0) stop(&quot;mode must be &gt; 0&quot;) if (sd &lt;= 0) stop(&quot;sd must be &gt; 0&quot;) rate = (mode + sqrt(mode^2 + 4 * sd^2)) / (2 * sd^2) shape = 1 + mode * rate return(list(shape = shape, rate = rate)) } mean_y_temp = mean(ptcld_validation_data$basal_area_pct_error, na.rm = T) sd_y_temp = sd(ptcld_validation_data$basal_area_pct_error, na.rm = T) omega_temp = sd_y_temp / 2 sigma_temp = 2 * sd_y_temp s_r_temp = gamma_a_b_from_omega_sigma(mode = omega_temp, sd = sigma_temp) stanvars_temp = brms::stanvar(mean_y_temp, name = &quot;mean_y&quot;) + brms::stanvar(sd_y_temp, name = &quot;sd_y&quot;) + brms::stanvar(s_r_temp$shape, name = &quot;alpha&quot;) + brms::stanvar(s_r_temp$rate, name = &quot;beta&quot;) 8.2.2.1 Prior distributions #### setting priors # required libraries: tidyverse, tidybayes, brms, palettetown, latex2exp priors_temp &lt;- c( brms::prior(normal(mean_y_temp, sd_y_temp * 5), class = &quot;Intercept&quot;) , brms::prior(gamma(s_r_temp$shape, s_r_temp$rate), class = &quot;sd&quot;) , brms::prior(cauchy(0, sd_y_temp), class = &quot;sigma&quot;) ) # plot plt_prior11 = priors_temp %&gt;% tidybayes::parse_dist() %&gt;% tidybayes::marginalize_lkjcorr(K = 2) %&gt;% tidyr::separate( .args , sep = &quot;,&quot; , into = c(&quot;a&quot;,&quot;b&quot;) , remove = F ) %&gt;% dplyr::mutate( distrib = dplyr::case_when( !is.na(b) ~ paste0( class, &quot; ~ &quot; , .dist , &quot;(&quot; , a %&gt;% readr::parse_number() %&gt;% round(2) , &quot;,&quot; , b %&gt;% readr::parse_number() %&gt;% round(2) , &quot;)&quot; ) , T ~ paste0( class, &quot; ~ &quot; , .dist , &quot;(&quot; , a %&gt;% readr::parse_number() %&gt;% round(2) , &quot;)&quot; ) ) ) %&gt;% ggplot(., aes(dist = .dist, args = .args)) + facet_grid(cols = vars(distrib), scales = &quot;free&quot;) + ggdist::stat_halfeye( aes(fill = prior), n = 10e2, show.legend = F , fill = &quot;slategray&quot; ) + coord_flip() + theme_light() + theme( strip.text = element_text(face = &quot;bold&quot;, color = &quot;black&quot;), axis.text.y = element_blank(), axis.ticks = element_blank() , axis.text = element_text(size = 6) )+ labs( x = &quot;&quot; , title = &quot;Priors: Basal Area Percentage Error&quot; , y = &quot;&quot; ) plt_prior11 8.2.2.2 Fit the model Now fit the model. brms_ba_pe_mod = brms::brm( formula = basal_area_pct_error ~ # baseline 1 + # main effects (1 | depth_maps_generation_quality) + (1 | depth_maps_generation_filtering_mode) + (1 | software) + (1 | study_site) + # only fitting main effects of site and not interactions # two-way interactions (1 | depth_maps_generation_quality:depth_maps_generation_filtering_mode) + (1 | depth_maps_generation_quality:software) + (1 | depth_maps_generation_filtering_mode:software) + # three-way interactions (1 | depth_maps_generation_quality:depth_maps_generation_filtering_mode:software) , data = ptcld_validation_data , family = brms::brmsfamily(family = &quot;gaussian&quot;) , iter = 20000, warmup = 10000, chains = 4 , control = list(adapt_delta = 0.999, max_treedepth = 13) , cores = round(parallel::detectCores()/2) , prior = c( brms::prior(normal(mean_y, sd_y * 5), class = &quot;Intercept&quot;) , brms::prior(gamma(alpha, beta), class = &quot;sd&quot;) , brms::prior(cauchy(0, sd_y), class = &quot;sigma&quot;) ) , stanvars = stanvars_temp , file = paste0(rootdir, &quot;/fits/brms_ba_pe_mod&quot;) ) 8.2.2.3 Quality:Filtering - interaction draws_temp = ptcld_validation_data %&gt;% dplyr::distinct(depth_maps_generation_quality, depth_maps_generation_filtering_mode) %&gt;% tidybayes::add_epred_draws( brms_ba_pe_mod, allow_new_levels = T # this part is crucial , re_formula = ~ (1 | depth_maps_generation_quality) + (1 | depth_maps_generation_filtering_mode) + (1 | depth_maps_generation_quality:depth_maps_generation_filtering_mode) ) %&gt;% dplyr::rename(value = .epred) %&gt;% dplyr::mutate(med = tidybayes::median_hdci(value)$y) # plot draws_temp %&gt;% dplyr::mutate(depth_maps_generation_quality = depth_maps_generation_quality %&gt;% forcats::fct_rev()) %&gt;% # plot ggplot( mapping = aes( y = value, x = depth_maps_generation_filtering_mode , fill = med ) ) + geom_hline(yintercept = 0, color = &quot;gray33&quot;) + tidybayes::stat_eye( point_interval = median_hdi, .width = 0.95 , slab_alpha = 0.98 , interval_color = &quot;black&quot;, linewidth = 1 , point_color = &quot;black&quot;, point_fill = &quot;black&quot;, point_size = 1 ) + scale_fill_stepsn( n.breaks = 7 , colors = scales::pal_div_gradient()(seq(0, 1, length.out = 7)) , limits = c(-lmt_basal_area_pct_error*.5,lmt_basal_area_pct_error*.5) , labels = scales::percent_format(accuracy = 1) , show.limits = T ) + facet_grid(cols = vars(depth_maps_generation_quality)) + scale_y_continuous( labels = scales::percent_format(accuracy = 1) , limits = c(-lmt_basal_area_pct_error*1.2,lmt_basal_area_pct_error*1.2) ) + labs( x = &quot;filtering mode&quot;, y = &quot;Basal Area % Error&quot; , subtitle = &quot;posterior predictive distribution of basal area percentage error with 95% HDI\\nby dense cloud quality&quot; ) + theme_light() + theme( legend.position = &quot;none&quot; , legend.direction = &quot;horizontal&quot; , axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1) , strip.text = element_text(color = &quot;black&quot;, face = &quot;bold&quot;) ) and a table of these 95% HDI values table_temp = draws_temp %&gt;% tidybayes::median_hdi(value) %&gt;% dplyr::select(-c(.point,.interval, .width,.row)) %&gt;% dplyr::arrange(depth_maps_generation_quality,depth_maps_generation_filtering_mode) %&gt;% dplyr::mutate(dplyr::across(.cols = is.numeric, .fns = ~ scales::percent(.x,accuracy = 0.1))) table_temp %&gt;% dplyr::select(-c(depth_maps_generation_quality)) %&gt;% kableExtra::kbl( digits = 2 , caption = &quot;Basal Area % Error&lt;br&gt;95% HDI of the posterior predictive distribution&quot; , col.names = c( &quot;filtering mode&quot; , &quot;Basal Area % Error&lt;br&gt;median&quot; , &quot;HDI low&quot;, &quot;HDI high&quot; ) , escape = F ) %&gt;% kableExtra::kable_styling() %&gt;% kableExtra::pack_rows(index = table(forcats::fct_inorder(table_temp$depth_maps_generation_quality))) %&gt;% kableExtra::scroll_box(height = &quot;8in&quot;) Table 8.2: Basal Area % Error95% HDI of the posterior predictive distribution filtering mode Basal Area % Errormedian HDI low HDI high ultra high aggressive -1.8% -54.6% 52.8% moderate 0.9% -51.2% 54.3% mild 3.3% -49.2% 56.1% disabled 3.1% -49.6% 56.3% high aggressive -5.9% -57.4% 48.5% moderate -3.2% -54.5% 49.6% mild -0.9% -52.9% 51.2% disabled -0.1% -51.5% 52.3% medium aggressive -16.4% -71.7% 35.3% moderate -12.1% -63.7% 41.5% mild -9.5% -61.4% 42.7% disabled -8.5% -62.4% 42.5% low aggressive -25.3% -79.0% 27.1% moderate -20.7% -72.6% 32.2% mild -16.9% -66.7% 37.6% disabled -15.5% -66.9% 37.2% lowest aggressive -37.2% -89.6% 20.2% moderate -34.1% -86.5% 22.4% mild -30.3% -83.9% 25.0% disabled -29.5% -81.9% 27.5% 8.2.2.4 Software:Quality - interaction draws_temp = ptcld_validation_data %&gt;% dplyr::distinct(depth_maps_generation_quality, software) %&gt;% tidybayes::add_epred_draws( brms_ba_pe_mod, allow_new_levels = T # this part is crucial , re_formula = ~ (1 | depth_maps_generation_quality) + (1 | software) + (1 | depth_maps_generation_quality:software) ) %&gt;% dplyr::rename(value = .epred) %&gt;% dplyr::mutate(med = tidybayes::median_hdci(value)$y) # plot draws_temp %&gt;% dplyr::mutate(depth_maps_generation_quality = depth_maps_generation_quality %&gt;% forcats::fct_rev()) %&gt;% # plot ggplot( mapping = aes( y = value, x = software , fill = med ) ) + geom_hline(yintercept = 0, color = &quot;gray33&quot;) + tidybayes::stat_eye( point_interval = median_hdi, .width = .95 , slab_alpha = 0.98 , interval_color = &quot;black&quot;, linewidth = 1 , point_color = &quot;black&quot;, point_fill = &quot;black&quot;, point_size = 1 ) + scale_fill_stepsn( n.breaks = 7 , colors = scales::pal_div_gradient()(seq(0, 1, length.out = 7)) , limits = c(-lmt_basal_area_pct_error*.5,lmt_basal_area_pct_error*.5) , labels = scales::percent_format(accuracy = 1) , show.limits = T ) + facet_grid(cols = vars(depth_maps_generation_quality)) + scale_y_continuous( labels = scales::percent_format(accuracy = 1) , limits = c(-lmt_basal_area_pct_error*1.2,lmt_basal_area_pct_error*1.2) ) + labs( x = &quot;software&quot;, y = &quot;Basal Area % Error&quot; , subtitle = &quot;posterior predictive distribution of basal area percentage error with 95% HDI\\nby dense cloud quality&quot; ) + theme_light() + theme( legend.position = &quot;none&quot; , legend.direction = &quot;horizontal&quot; , axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1) , strip.text = element_text(color = &quot;black&quot;, face = &quot;bold&quot;) ) and a table of these 95% HDI values table_temp = draws_temp %&gt;% tidybayes::median_hdi(value) %&gt;% # remove out-of-sample obs dplyr::inner_join( ptcld_validation_data %&gt;% dplyr::distinct(depth_maps_generation_quality, software) , by = dplyr::join_by(depth_maps_generation_quality, software) ) %&gt;% dplyr::select(-c(.point,.interval, .width,.row)) %&gt;% dplyr::arrange(software,depth_maps_generation_quality) %&gt;% dplyr::mutate(dplyr::across(.cols = is.numeric, .fns = ~ scales::percent(.x,accuracy = 0.1))) table_temp %&gt;% dplyr::select(-c(software)) %&gt;% kableExtra::kbl( digits = 2 , caption = &quot;Basal Area % Error&lt;br&gt;95% HDI of the posterior predictive distribution&quot; , col.names = c( &quot;quality&quot; , &quot;Basal Area % Error&lt;br&gt;median&quot; , &quot;HDI low&quot;, &quot;HDI high&quot; ) , escape = F ) %&gt;% kableExtra::kable_styling() %&gt;% kableExtra::pack_rows(index = table(forcats::fct_inorder(table_temp$software))) %&gt;% kableExtra::scroll_box(height = &quot;8in&quot;) Table 8.3: Basal Area % Error95% HDI of the posterior predictive distribution quality Basal Area % Errormedian HDI low HDI high METASHAPE ultra high 7.5% -30.6% 46.2% high 3.7% -35.5% 41.8% medium -5.1% -43.7% 33.1% low -23.4% -62.0% 15.1% lowest -50.7% -89.0% -12.0% OPENDRONEMAP ultra high -1.7% -39.9% 37.9% high -10.4% -48.9% 29.0% medium -31.7% -70.2% 7.6% low -32.4% -71.1% 6.8% lowest -33.8% -71.8% 5.8% PIX4D ultra high 7.4% -31.9% 47.1% high 5.9% -33.8% 45.1% medium 2.6% -36.0% 43.4% low -6.9% -46.6% 33.4% 8.2.2.5 Software:Filtering - interaction draws_temp = ptcld_validation_data %&gt;% dplyr::distinct(depth_maps_generation_filtering_mode, software) %&gt;% tidybayes::add_epred_draws( brms_ba_pe_mod, allow_new_levels = T # this part is crucial , re_formula = ~ (1 | depth_maps_generation_filtering_mode) + (1 | software) + (1 | depth_maps_generation_filtering_mode:software) ) %&gt;% dplyr::rename(value = .epred) %&gt;% dplyr::mutate(med = tidybayes::median_hdci(value)$y) # plot draws_temp %&gt;% # plot ggplot( mapping = aes( y = value, x = software , fill = med ) ) + geom_hline(yintercept = 0, color = &quot;gray33&quot;) + tidybayes::stat_eye( point_interval = median_hdi, .width = .95 , slab_alpha = 0.98 , interval_color = &quot;black&quot;, linewidth = 1 , point_color = &quot;black&quot;, point_fill = &quot;black&quot;, point_size = 1 ) + scale_fill_stepsn( n.breaks = 7 , colors = scales::pal_div_gradient()(seq(0, 1, length.out = 7)) , limits = c(-lmt_basal_area_pct_error*.5,lmt_basal_area_pct_error*.5) , labels = scales::percent_format(accuracy = 1) , show.limits = T ) + facet_grid(cols = vars(depth_maps_generation_filtering_mode)) + scale_y_continuous( labels = scales::percent_format(accuracy = 1) , limits = c(-lmt_basal_area_pct_error*1.2,lmt_basal_area_pct_error*1.2) ) + labs( x = &quot;software&quot;, y = &quot;Basal Area % Error&quot; , subtitle = &quot;posterior predictive distribution of basal area percentage error with 95% HDI\\nby filtering mode&quot; ) + theme_light() + theme( legend.position = &quot;none&quot; , legend.direction = &quot;horizontal&quot; , axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1) , strip.text = element_text(color = &quot;black&quot;, face = &quot;bold&quot;) ) and a table of these 95% HDI values table_temp = draws_temp %&gt;% tidybayes::median_hdi(value) %&gt;% dplyr::select(-c(.point,.interval, .width,.row)) %&gt;% dplyr::arrange(software,depth_maps_generation_filtering_mode) %&gt;% dplyr::mutate(dplyr::across(.cols = is.numeric, .fns = ~ scales::percent(.x,accuracy = 0.1))) table_temp %&gt;% dplyr::select(-c(software)) %&gt;% kableExtra::kbl( digits = 2 , caption = &quot;Basal Area % Error&lt;br&gt;95% HDI of the posterior predictive distribution&quot; , col.names = c( &quot;filtering mode&quot; , &quot;Basal Area % Error&lt;br&gt;median&quot; , &quot;HDI low&quot;, &quot;HDI high&quot; ) , escape = F ) %&gt;% kableExtra::kable_styling() %&gt;% kableExtra::pack_rows(index = table(forcats::fct_inorder(table_temp$software))) %&gt;% kableExtra::scroll_box(height = &quot;8in&quot;) Table 8.4: Basal Area % Error95% HDI of the posterior predictive distribution filtering mode Basal Area % Errormedian HDI low HDI high METASHAPE aggressive -31.0% -73.2% 11.4% moderate -15.4% -57.2% 27.5% mild -5.2% -46.6% 37.7% disabled -2.9% -44.4% 40.1% OPENDRONEMAP aggressive -19.3% -61.5% 22.8% moderate -22.1% -65.7% 18.6% mild -22.8% -65.7% 19.2% disabled -22.8% -68.1% 16.6% PIX4D moderate -5.3% -49.5% 36.7% mild -0.5% -43.9% 42.1% disabled 1.5% -42.6% 43.4% 8.2.2.6 Software:Quality:Filtering - interaction # get draws fltr_sftwr_draws_temp = tidyr::crossing( depth_maps_generation_quality = unique(ptcld_validation_data$depth_maps_generation_quality) , depth_maps_generation_filtering_mode = unique(ptcld_validation_data$depth_maps_generation_filtering_mode) , software = unique(ptcld_validation_data$software) ) %&gt;% tidybayes::add_epred_draws( brms_ba_pe_mod, allow_new_levels = T # this part is crucial , re_formula = ~ (1 | depth_maps_generation_quality) + # main effects (1 | depth_maps_generation_quality) + (1 | depth_maps_generation_filtering_mode) + (1 | software) + # two-way interactions (1 | depth_maps_generation_quality:depth_maps_generation_filtering_mode) + (1 | depth_maps_generation_quality:software) + (1 | depth_maps_generation_filtering_mode:software) + # three-way interactions (1 | depth_maps_generation_quality:depth_maps_generation_filtering_mode:software) ) %&gt;% dplyr::rename(value = .epred) %&gt;% dplyr::mutate(med = tidybayes::median_hdci(value)$y) # plot qlty_fltr_sftwr_ba_pe = fltr_sftwr_draws_temp %&gt;% dplyr::inner_join( ptcld_validation_data %&gt;% dplyr::distinct(software, depth_maps_generation_quality, depth_maps_generation_filtering_mode) , by = dplyr::join_by(software, depth_maps_generation_quality, depth_maps_generation_filtering_mode) ) %&gt;% dplyr::mutate(depth_maps_generation_quality = depth_maps_generation_quality %&gt;% forcats::fct_rev()) %&gt;% ggplot( mapping = aes( y = value , x = depth_maps_generation_filtering_mode , fill = med ) ) + geom_hline(yintercept = 0, color = &quot;gray33&quot;) + tidybayes::stat_eye( point_interval = median_hdi, .width = .95 , slab_alpha = 0.98 , interval_color = &quot;black&quot;, linewidth = 1 , point_color = &quot;black&quot;, point_fill = &quot;black&quot;, point_size = 1 ) + scale_fill_stepsn( n.breaks = 7 , colors = scales::pal_div_gradient()(seq(0, 1, length.out = 7)) , limits = c(-lmt_basal_area_pct_error*.5,lmt_basal_area_pct_error*.5) , labels = scales::percent_format(accuracy = 1) , show.limits = T ) + facet_grid( rows = vars(software) , cols = vars(depth_maps_generation_quality) # , switch = &quot;y&quot; ) + scale_y_continuous( labels = scales::percent_format(accuracy = 1) , limits = c(-lmt_basal_area_pct_error*1.5,lmt_basal_area_pct_error*1.2) ) + labs( x = &quot;filtering mode&quot;, y = &quot;Basal Area % Error&quot; , subtitle = &quot;posterior predictive distribution of basal area percentage error with 95% HDI\\nby dense cloud quality and software&quot; # , caption = form_temp ) + theme_light() + theme( legend.position = &quot;none&quot; , legend.direction = &quot;horizontal&quot; , axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1) , strip.text = element_text(color = &quot;black&quot;, face = &quot;bold&quot;) , panel.grid = element_blank() # , strip.placement = &quot;outside&quot; ) + guides( fill = guide_legend(override.aes = list(shape = NA, size = 6, alpha = 0.9, lwd = NA)) ) # print it qlty_fltr_sftwr_ba_pe ggplot2::ggsave(&quot;../data/qlty_fltr_sftwr_ba_pe.png&quot;, height = 7, width = 10.5) and a table of these 95% HDI values table_temp = fltr_sftwr_draws_temp %&gt;% tidybayes::median_hdi(value) %&gt;% dplyr::inner_join( ptcld_validation_data %&gt;% dplyr::distinct(software, depth_maps_generation_quality, depth_maps_generation_filtering_mode) , by = dplyr::join_by(software, depth_maps_generation_quality, depth_maps_generation_filtering_mode) ) %&gt;% dplyr::mutate(depth_maps_generation_quality = depth_maps_generation_quality %&gt;% forcats::fct_rev()) %&gt;% dplyr::select(c( software, depth_maps_generation_quality, depth_maps_generation_filtering_mode , value, .lower, .upper )) %&gt;% dplyr::ungroup() %&gt;% dplyr::arrange(software, depth_maps_generation_quality, depth_maps_generation_filtering_mode) %&gt;% dplyr::mutate(dplyr::across(.cols = is.numeric, .fns = ~ scales::percent(.x,accuracy = 0.1))) table_temp %&gt;% # dplyr::select(-c(software)) %&gt;% kableExtra::kbl( digits = 2 , caption = &quot;Basal Area % Error&lt;br&gt;95% HDI of the posterior predictive distribution&quot; , col.names = c( &quot;software&quot;, &quot;quality&quot;, &quot;filtering mode&quot; , &quot;Basal Area % Error&lt;br&gt;median&quot; , &quot;HDI low&quot;, &quot;HDI high&quot; ) , escape = F ) %&gt;% kableExtra::kable_styling() %&gt;% # kableExtra::pack_rows(index = table(forcats::fct_inorder(table_temp$software))) %&gt;% kableExtra::collapse_rows(columns = 1:2, valign = &quot;top&quot;) %&gt;% kableExtra::scroll_box(height = &quot;8in&quot;) Table 8.5: Basal Area % Error95% HDI of the posterior predictive distribution software quality filtering mode Basal Area % Errormedian HDI low HDI high METASHAPE lowest aggressive -68.6% -103.4% -34.0% moderate -53.0% -89.6% -15.4% mild -53.1% -90.1% -16.2% disabled -53.1% -91.3% -17.4% low aggressive -42.6% -77.7% -8.0% moderate -25.8% -63.0% 11.5% mild -25.1% -62.2% 11.7% disabled -24.3% -61.6% 12.6% medium aggressive -43.0% -79.9% -4.8% moderate -26.2% -64.8% 13.9% mild -26.9% -65.7% 13.1% disabled -27.2% -65.6% 12.7% high aggressive -12.7% -47.1% 21.9% moderate 1.9% -34.3% 39.9% mild 0.9% -35.6% 38.0% disabled 1.0% -35.1% 38.7% ultra high aggressive -11.1% -48.7% 26.5% moderate 3.7% -35.1% 43.4% mild 2.8% -36.1% 42.3% disabled 1.7% -36.9% 41.9% OPENDRONEMAP lowest aggressive -33.0% -67.3% 1.8% moderate -35.1% -73.8% 2.7% mild -29.6% -67.7% 8.9% disabled -28.0% -67.5% 8.8% low aggressive -32.3% -67.8% 2.0% moderate -34.0% -72.2% 4.1% mild -27.7% -66.8% 10.0% disabled -24.8% -62.5% 14.0% medium aggressive -12.6% -51.2% 26.2% moderate -13.6% -55.7% 26.8% mild -9.1% -50.3% 32.2% disabled -6.6% -49.5% 33.4% high aggressive -8.2% -43.7% 25.2% moderate -10.9% -48.2% 27.8% mild -6.7% -45.1% 31.2% disabled -4.7% -42.8% 33.4% ultra high aggressive -6.0% -44.1% 33.4% moderate -8.6% -51.5% 31.0% mild -4.0% -45.9% 36.9% disabled -3.1% -44.1% 38.7% PIX4D low moderate -7.9% -49.1% 32.9% mild -5.6% -45.7% 34.9% disabled 3.3% -36.9% 43.5% medium moderate 3.2% -45.3% 50.4% mild 3.8% -42.8% 51.4% disabled 13.2% -32.3% 61.4% high moderate 4.4% -35.7% 46.3% mild 6.4% -34.0% 46.3% disabled 14.5% -25.3% 55.0% ultra high moderate 9.3% -39.8% 58.4% mild 10.5% -38.5% 58.6% disabled 17.8% -32.1% 65.0% 8.3 BA Absolute Percentage Error (precision) 8.3.1 Summary Statistics # summarize data dta_temp = ptcld_validation_data %&gt;% dplyr::group_by(software, depth_maps_generation_quality, depth_maps_generation_filtering_mode) %&gt;% # collapse across study site dplyr::summarise( basal_area_abs_pct_error = mean(basal_area_abs_pct_error, na.rm = T) , n = dplyr::n() ) # set limits for color scale lmt_basal_area_abs_pct_error = ceiling(1.02*10*max(abs(range(dta_temp$basal_area_abs_pct_error, na.rm = T))))/10 # scales::show_col(viridis::mako(n = 10, begin = 0.2, end = 0.9, direction = -1)) # scales::show_col(scales::pal_div_gradient()(seq(0, 1, length.out = 7))) # plot it dta_temp %&gt;% ggplot(mapping = aes( y = depth_maps_generation_quality , x = depth_maps_generation_filtering_mode , fill = basal_area_abs_pct_error , label = paste0(scales::percent(basal_area_abs_pct_error,accuracy = 0.1), &quot;\\n(n=&quot;, n,&quot;)&quot;) )) + geom_tile(color = &quot;white&quot;) + geom_text(color = &quot;white&quot;, size = 3) + facet_grid(cols = vars(software)) + scale_x_discrete(expand = c(0, 0)) + scale_y_discrete(expand = c(0, 0)) + scale_fill_stepsn( n.breaks = 5 , colors = viridis::mako(n = 5, begin = 0.2, end = 0.9, direction = -1) , limits = c(0,lmt_basal_area_abs_pct_error) , labels = scales::percent_format(accuracy = 1) , show.limits = T ) + labs( x = &quot;filtering mode&quot; , y = &quot;quality&quot; , fill = &quot;Basal Area Abs. % Error&quot; , title = &quot;mean basal area absolute percentage error and # of study sites&quot; ) + theme_light() + theme( legend.position = &quot;none&quot; , axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1) , panel.background = element_blank() , panel.grid = element_blank() # , plot.title = element_text(hjust = 0.5) # , plot.subtitle = element_text(hjust = 0.5) , strip.text = element_text(color = &quot;black&quot;, face = &quot;bold&quot;) ) let’s check the distribution (of our dependent or \\(y\\) variable) # distribution ptcld_validation_data %&gt;% ggplot(mapping = aes(x = basal_area_abs_pct_error)) + geom_hline(yintercept = 0, color = &quot;gray77&quot;) + geom_vline(xintercept = 0, color = &quot;gray77&quot;) + # geom_vline(xintercept = c(0,1)) + geom_density(fill = &quot;lightblue&quot;, alpha = 0.7, color = NA) + labs(y=&quot;&quot;,x=&quot;Basal Area Abs. % Error&quot;) + scale_y_continuous(breaks = c(0)) + scale_x_continuous(breaks = scales::extended_breaks(10), labels = scales::percent_format(accuracy = 1)) + theme_light() + theme(panel.grid = element_blank()) and the summary statistics ptcld_validation_data %&gt;% dplyr::ungroup() %&gt;% dplyr::select(basal_area_abs_pct_error) %&gt;% dplyr::summarise( dplyr::across( dplyr::everything() , .fns = list( mean = ~ mean(.x,na.rm=T), median = ~ median(.x,na.rm=T), sd = ~ sd(.x,na.rm=T) , min = ~ min(.x,na.rm=T), max = ~ max(.x,na.rm=T) , q25 = ~ quantile(.x, 0.25, na.rm = T) , q75 = ~ quantile(.x, 0.75, na.rm = T) ) , .names = &quot;{.fn}&quot; ) ) %&gt;% tidyr::pivot_longer(everything()) %&gt;% kableExtra::kbl(caption = &quot;summary: `basal_area_abs_pct_error`&quot;, digits = 3, col.names = NULL) %&gt;% kableExtra::kable_styling() Table 8.6: summary: basal_area_abs_pct_error mean 0.263 median 0.190 sd 0.248 min 0.003 max 1.000 q25 0.088 q75 0.359 8.3.2 Model: BA Absolute percentage error We’ll model the BA APE using the gamma likelihood to accurately represent the dependent variable which is continuous and strictly positive (i.e. it is impossible to have a negative APE). The gamma distribution is a great alternative that accounts for data with a zero lower limit and any right skew. We borrow here from the excellent series on causal inference by A. Solomon Kurz 8.3.2.1 Prior distributions First, let’s set the priors # desired priors m_temp &lt;- mean(ptcld_validation_data$basal_area_abs_pct_error) # desired mean s_temp &lt;- sd(ptcld_validation_data$basal_area_abs_pct_error) # desired SD # use the equations to get the lognormal parameter values mu_temp &lt;- log(m_temp / sqrt((s_temp*5)^2 / m_temp^2 + 1)) sigma_temp &lt;- sqrt(log((s_temp*5)^2 / m_temp^2 + 1)) # what are the lognormal parameter values? # mu_temp # sigma_temp # exp(mu_temp) stanvars_temp = brms::stanvar(mu_temp, name = &quot;mu_temp&quot;) + brms::stanvar(sigma_temp, name = &quot;sigma_temp&quot;) #### setting priors # required libraries: tidyverse, tidybayes, brms, palettetown, latex2exp brms_ba_ape_mod_priors_temp &lt;- c( brms::prior(normal(mu_temp, sigma_temp), class = &quot;Intercept&quot;) , brms::prior(student_t(3, 0, 2.5), class = &quot;sd&quot;) , brms::prior(gamma(0.1, 0.1), class = shape) # , brms::prior(exponential(0.5), class = shape) ) plot the priors # plot plt_prior12 = brms_ba_ape_mod_priors_temp %&gt;% tidybayes::parse_dist() %&gt;% tidybayes::marginalize_lkjcorr(K = 2) %&gt;% tidyr::separate( .args , sep = &quot;,&quot; , into = c(&quot;a&quot;,&quot;b&quot;) , remove = F ) %&gt;% dplyr::mutate( distrib = dplyr::case_when( !is.na(b) ~ paste0( class, &quot; ~ &quot; , .dist , &quot;(&quot; , a %&gt;% readr::parse_number() %&gt;% round(2) , &quot;,&quot; , b %&gt;% readr::parse_number() %&gt;% round(2) , &quot;)&quot; ) , T ~ paste0( class, &quot; ~ &quot; , .dist , &quot;(&quot; , a %&gt;% readr::parse_number() %&gt;% round(2) , &quot;)&quot; ) ) ) %&gt;% ggplot(., aes(dist = .dist, args = .args)) + facet_grid(cols = vars(distrib), scales = &quot;free&quot;) + ggdist::stat_halfeye( aes(fill = prior), n = 10e2, show.legend = F , fill = &quot;slategray&quot; ) + coord_flip() + theme_light() + theme( strip.text = element_text(face = &quot;bold&quot;, color = &quot;black&quot;), axis.text.y = element_blank(), axis.ticks = element_blank() , axis.text = element_text(size = 6) )+ labs( x = &quot;&quot; , title = &quot;Priors: Basal Area Absolute Percentage Error&quot; , y = &quot;&quot; ) plt_prior12 8.3.2.2 Fit the model Now fit the model. #### Fit the model brms_ba_ape_mod = brms::brm( formula = basal_area_abs_pct_error ~ # baseline 1 + # main effects (1 | depth_maps_generation_quality) + (1 | depth_maps_generation_filtering_mode) + (1 | software) + (1 | study_site) + # only fitting main effects of site and not interactions # two-way interactions (1 | depth_maps_generation_quality:depth_maps_generation_filtering_mode) + (1 | depth_maps_generation_quality:software) + (1 | depth_maps_generation_filtering_mode:software) + # three-way interactions (1 | depth_maps_generation_quality:depth_maps_generation_filtering_mode:software) , data = ptcld_validation_data # , family = brms::brmsfamily(&quot;Gamma&quot;, link = &quot;log&quot;) , family = brms::brmsfamily(&quot;weibull&quot;, link = &quot;log&quot;) # priors , prior = brms_ba_ape_mod_priors_temp , stanvars = stanvars_temp # mcmc , iter = 20000, warmup = 10000, chains = 4 , control = list(adapt_delta = 0.999, max_treedepth = 13) , cores = round(parallel::detectCores()/2) , file = paste0(rootdir, &quot;/fits/brms_ba_ape_mod&quot;) ) 8.3.2.3 Quality:Filtering - interaction draws_temp = ptcld_validation_data %&gt;% dplyr::distinct(depth_maps_generation_quality, depth_maps_generation_filtering_mode) %&gt;% tidybayes::add_epred_draws( brms_ba_ape_mod, allow_new_levels = T # this part is crucial , re_formula = ~ (1 | depth_maps_generation_quality) + (1 | depth_maps_generation_filtering_mode) + (1 | depth_maps_generation_quality:depth_maps_generation_filtering_mode) ) %&gt;% dplyr::rename(value = .epred) %&gt;% dplyr::mutate(med = tidybayes::median_hdci(value)$y) # plot draws_temp %&gt;% dplyr::mutate(depth_maps_generation_quality = depth_maps_generation_quality %&gt;% forcats::fct_rev()) %&gt;% # plot ggplot( mapping = aes( y = value, x = depth_maps_generation_filtering_mode , fill = med ) ) + geom_hline(yintercept = 0, color = &quot;gray33&quot;) + tidybayes::stat_eye( point_interval = median_hdi, .width = .95 , slab_alpha = 0.98 , interval_color = &quot;black&quot;, linewidth = 1 , point_color = &quot;black&quot;, point_fill = &quot;black&quot;, point_size = 1 ) + scale_fill_stepsn( n.breaks = 5 , colors = viridis::mako(n = 5, begin = 0.2, end = 0.9, direction = -1) , limits = c(0,lmt_basal_area_abs_pct_error*.6) , labels = scales::percent_format(accuracy = 0.1) , show.limits = T ) + facet_grid(cols = vars(depth_maps_generation_quality)) + scale_y_continuous( limits = c(-0.005,lmt_basal_area_abs_pct_error*1.1) , labels = scales::percent_format(accuracy = 1) ) + labs( x = &quot;filtering mode&quot;, y = &quot;BA Abs. % Error&quot; , subtitle = &quot;posterior predictive distribution of BA Abs. % Error with 95% HDI\\nby dense cloud quality&quot; ) + theme_light() + theme( legend.position = &quot;none&quot; , legend.direction = &quot;horizontal&quot; , axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1) , strip.text = element_text(color = &quot;black&quot;, face = &quot;bold&quot;) ) and a table of these 95% HDI values table_temp = draws_temp %&gt;% tidybayes::median_hdi(value) %&gt;% dplyr::select(-c(.point,.interval, .width,.row)) %&gt;% dplyr::arrange(depth_maps_generation_quality,depth_maps_generation_filtering_mode) %&gt;% dplyr::mutate(dplyr::across(.cols = is.numeric, .fns = ~ scales::percent(.x,accuracy = 0.1))) table_temp %&gt;% dplyr::select(-c(depth_maps_generation_quality)) %&gt;% kableExtra::kbl( digits = 2 , caption = &quot;BA Abs. % Error&lt;br&gt;95% HDI of the posterior predictive distribution&quot; , col.names = c( &quot;filtering mode&quot; , &quot;BA Abs. % Error&lt;br&gt;median&quot; , &quot;HDI low&quot;, &quot;HDI high&quot; ) , escape = F ) %&gt;% kableExtra::kable_styling() %&gt;% kableExtra::pack_rows(index = table(forcats::fct_inorder(table_temp$depth_maps_generation_quality))) %&gt;% kableExtra::scroll_box(height = &quot;8in&quot;) Table 8.7: BA Abs. % Error95% HDI of the posterior predictive distribution filtering mode BA Abs. % Errormedian HDI low HDI high ultra high aggressive 15.8% 1.6% 35.3% moderate 15.0% 1.7% 32.5% mild 14.4% 1.7% 31.6% disabled 13.3% 1.4% 28.8% high aggressive 18.0% 2.0% 39.3% moderate 16.7% 1.7% 35.2% mild 16.1% 1.9% 34.5% disabled 15.4% 2.1% 33.1% medium aggressive 23.6% 2.2% 51.2% moderate 20.8% 2.3% 44.0% mild 19.8% 2.2% 42.3% disabled 18.7% 1.9% 39.7% low aggressive 29.5% 3.4% 64.5% moderate 26.3% 4.0% 57.0% mild 24.1% 2.8% 51.0% disabled 22.3% 3.4% 48.6% lowest aggressive 37.8% 3.6% 85.9% moderate 35.0% 4.2% 78.2% mild 32.4% 3.5% 72.5% disabled 30.7% 3.9% 69.1% we can also make pairwise comparisons # first we need to define the contrasts to make contrast_list = tidyr::crossing( x1 = unique(ptcld_validation_data$depth_maps_generation_quality) , x2 = unique(ptcld_validation_data$depth_maps_generation_quality) ) %&gt;% dplyr::mutate( dplyr::across( dplyr::everything() , .fns = function(x){factor( x, ordered = T , levels = levels(ptcld_validation_data$depth_maps_generation_quality) )} ) ) %&gt;% dplyr::filter(x1&lt;x2) %&gt;% dplyr::arrange(x1,x2) %&gt;% dplyr::mutate(dplyr::across(dplyr::everything(), as.character)) %&gt;% purrr::transpose() # make the contrasts using compare_levels brms_contrast_temp = draws_temp %&gt;% tidybayes::compare_levels( value , by = depth_maps_generation_quality , comparison = contrast_list # tidybayes::emmeans_comparison(&quot;revpairwise&quot;) #&quot;pairwise&quot; ) %&gt;% dplyr::rename(contrast = depth_maps_generation_quality) # separate contrast brms_contrast_temp = brms_contrast_temp %&gt;% dplyr::ungroup() %&gt;% tidyr::separate_wider_delim( cols = contrast , delim = &quot; - &quot; , names = paste0( &quot;sorter&quot; , 1:(max(stringr::str_count(brms_contrast_temp$contrast, &quot;-&quot;))+1) ) , too_few = &quot;align_start&quot; , cols_remove = F ) %&gt;% dplyr::filter(sorter1!=sorter2) %&gt;% dplyr::mutate( dplyr::across( tidyselect::starts_with(&quot;sorter&quot;) , .fns = function(x){factor( x, ordered = T , levels = levels(ptcld_validation_data$depth_maps_generation_quality) )} ) , contrast = contrast %&gt;% forcats::fct_reorder( paste0(as.numeric(sorter1), as.numeric(sorter2)) %&gt;% as.numeric() ) , depth_maps_generation_filtering_mode = depth_maps_generation_filtering_mode %&gt;% factor( levels = levels(ptcld_validation_data$depth_maps_generation_filtering_mode) , ordered = T ) ) %&gt;% # median_hdi summary for coloring dplyr::group_by(contrast,depth_maps_generation_filtering_mode) %&gt;% make_contrast_vars() plot it plt_contrast( brms_contrast_temp # , caption_text = form_temp , y_axis_title = &quot;quality&quot; , facet = &quot;depth_maps_generation_filtering_mode&quot; , label_size = 1.55 ) + scale_x_continuous( labels = scales::percent_format(accuracy = 1) , limits = c(-1.2,0.3) , breaks = seq(-1,1,0.5) ) + labs( subtitle = &quot;posterior predictive distribution of group constrasts with 95% &amp; 50% HDI\\nby filtering mode&quot; , x = &quot;constrast BA Abs. % Error&quot; ) + theme( axis.text.x = element_text(size = 7) ) ggplot2::ggsave( &quot;../data/qlty_fltr_comp_ba_ape.png&quot; , plot = ggplot2::last_plot() + labs(subtitle = &quot;&quot;) , height = 7, width = 10.5 ) and summarize these contrasts brms_contrast_temp %&gt;% dplyr::group_by(contrast, depth_maps_generation_filtering_mode, pr_lt_zero) %&gt;% tidybayes::median_hdi(value) %&gt;% dplyr::arrange(contrast, depth_maps_generation_filtering_mode) %&gt;% dplyr::select(contrast, depth_maps_generation_filtering_mode, value, .lower, .upper, pr_lt_zero) %&gt;% dplyr::mutate(dplyr::across(.cols = is.numeric, .fns = ~ scales::percent(.x,accuracy = 0.1))) %&gt;% kableExtra::kbl( digits = 2 , caption = &quot;BA Abs. % Error&lt;br&gt;95% HDI of the posterior predictive distribution of group contrasts&quot; , col.names = c( &quot;quality contrast&quot; , &quot;filtering mode&quot; , &quot;median difference&lt;br&gt;BA Abs. % Error&quot; , &quot;HDI low&quot;, &quot;HDI high&quot; , &quot;Pr(diff&lt;0)&quot; ) , escape = F ) %&gt;% kableExtra::kable_styling() %&gt;% kableExtra::scroll_box(height = &quot;8in&quot;) Table 8.8: BA Abs. % Error95% HDI of the posterior predictive distribution of group contrasts quality contrast filtering mode median differenceBA Abs. % Error HDI low HDI high Pr(diff&lt;0) ultra high - high aggressive -1.8% -14.5% 8.7% 68% ultra high - high moderate -1.4% -12.6% 8.1% 67% ultra high - high mild -1.4% -12.1% 8.1% 67% ultra high - high disabled -1.7% -12.3% 6.7% 72% ultra high - medium aggressive -7.1% -25.7% 5.1% 92% ultra high - medium moderate -5.3% -20.3% 5.5% 88% ultra high - medium mild -4.9% -19.4% 5.5% 87% ultra high - medium disabled -4.9% -18.2% 5.1% 89% ultra high - low aggressive -12.9% -38.8% 2.5% 97% ultra high - low moderate -10.9% -31.5% 2.9% 96% ultra high - low mild -9.1% -28.2% 3.8% 94% ultra high - low disabled -8.5% -26.4% 3.8% 94% ultra high - lowest aggressive -21.4% -59.5% 2.8% 98% ultra high - lowest moderate -19.5% -54.1% 2.4% 98% ultra high - lowest mild -17.5% -49.6% 3.4% 97% ultra high - lowest disabled -16.8% -46.8% 2.9% 98% high - medium aggressive -5.0% -22.8% 7.0% 84% high - medium moderate -3.6% -17.8% 7.5% 80% high - medium mild -3.3% -16.8% 7.5% 79% high - medium disabled -2.9% -16.4% 6.9% 77% high - low aggressive -10.8% -35.5% 4.0% 95% high - low moderate -9.1% -29.2% 4.0% 94% high - low mild -7.4% -25.6% 5.2% 91% high - low disabled -6.5% -24.0% 5.4% 89% high - lowest aggressive -19.2% -55.4% 4.4% 97% high - lowest moderate -17.7% -50.3% 3.9% 97% high - lowest mild -15.8% -46.2% 4.2% 96% high - lowest disabled -14.7% -44.1% 3.7% 96% medium - low aggressive -5.2% -26.9% 10.0% 81% medium - low aggressive -5.2% 10.1% 10.9% 81% medium - low moderate -5.0% -23.0% 9.0% 82% medium - low mild -3.7% -21.0% 8.9% 77% medium - low disabled -3.2% -19.4% -18.7% 75% medium - low disabled -3.2% -18.4% 9.1% 75% medium - lowest aggressive -13.3% -47.6% 7.9% 92% medium - lowest moderate -13.3% -44.8% 5.5% 94% medium - lowest mild -11.7% -40.5% 6.1% 93% medium - lowest disabled -11.2% -38.7% 5.6% 93% low - lowest aggressive -7.4% -40.2% 14.1% 80% low - lowest moderate -7.6% -37.8% -37.8% 83% low - lowest moderate -7.6% -36.6% 11.9% 83% low - lowest mild -7.5% -35.0% 10.2% 84% low - lowest disabled -7.5% -33.7% 9.0% 86% 8.3.2.4 Software:Quality - interaction draws_temp = tidyr::crossing( depth_maps_generation_quality = unique(ptcld_validation_data$depth_maps_generation_quality) , software = unique(ptcld_validation_data$software) ) %&gt;% tidybayes::add_epred_draws( brms_ba_ape_mod, allow_new_levels = T # this part is crucial , re_formula = ~ (1 | depth_maps_generation_quality) + (1 | software) + (1 | depth_maps_generation_quality:software) ) %&gt;% dplyr::rename(value = .epred) %&gt;% dplyr::mutate(med = tidybayes::median_hdci(value)$y) # plot draws_temp %&gt;% # remove out-of-sample obs dplyr::inner_join( ptcld_validation_data %&gt;% dplyr::distinct(depth_maps_generation_quality, software) , by = dplyr::join_by(depth_maps_generation_quality, software) ) %&gt;% dplyr::mutate(depth_maps_generation_quality = depth_maps_generation_quality %&gt;% forcats::fct_rev()) %&gt;% # plot ggplot( mapping = aes( y = value, x = software , fill = med ) ) + geom_hline(yintercept = 0, color = &quot;gray33&quot;) + tidybayes::stat_eye( point_interval = median_hdi, .width = .95 , slab_alpha = 0.98 , interval_color = &quot;black&quot;, linewidth = 1 , point_color = &quot;black&quot;, point_fill = &quot;black&quot;, point_size = 1 ) + scale_fill_stepsn( n.breaks = 5 , colors = viridis::mako(n = 5, begin = 0.2, end = 0.9, direction = -1) , limits = c(0,lmt_basal_area_abs_pct_error*.6) , labels = scales::percent_format(accuracy = 0.1) , show.limits = T ) + facet_grid(cols = vars(depth_maps_generation_quality)) + scale_y_continuous( limits = c(-0.005,lmt_basal_area_abs_pct_error*1.1) , labels = scales::percent_format(accuracy = 1) ) + labs( x = &quot;software&quot;, y = &quot;BA Abs. % Error&quot; , subtitle = &quot;posterior predictive distribution of BA Abs. % Error with 95% HDI\\nby dense cloud quality&quot; ) + theme_light() + theme( legend.position = &quot;none&quot; , legend.direction = &quot;horizontal&quot; , axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1) , strip.text = element_text(color = &quot;black&quot;, face = &quot;bold&quot;) ) and a table of these 95% HDI values table_temp = draws_temp %&gt;% tidybayes::median_hdi(value) %&gt;% # remove out-of-sample obs dplyr::inner_join( ptcld_validation_data %&gt;% dplyr::distinct(depth_maps_generation_quality, software) , by = dplyr::join_by(depth_maps_generation_quality, software) ) %&gt;% dplyr::select(-c(.point,.interval, .width,.row)) %&gt;% dplyr::arrange(software,depth_maps_generation_quality) %&gt;% dplyr::mutate(dplyr::across(.cols = is.numeric, .fns = ~ scales::percent(.x,accuracy = 0.1))) table_temp %&gt;% dplyr::select(-c(software)) %&gt;% kableExtra::kbl( digits = 2 , caption = &quot;BA Abs. % Error&lt;br&gt;95% HDI of the posterior predictive distribution&quot; , col.names = c( &quot;quality&quot; , &quot;BA Abs. % Error&lt;br&gt;median&quot; , &quot;HDI low&quot;, &quot;HDI high&quot; ) , escape = F ) %&gt;% kableExtra::kable_styling() %&gt;% kableExtra::pack_rows(index = table(forcats::fct_inorder(table_temp$software))) %&gt;% kableExtra::scroll_box(height = &quot;8in&quot;) Table 8.9: BA Abs. % Error95% HDI of the posterior predictive distribution quality BA Abs. % Errormedian HDI low HDI high METASHAPE ultra high 14.9% 4.9% 28.7% high 16.3% 5.6% 31.7% medium 18.5% 6.3% 36.2% low 26.6% 9.0% 51.2% lowest 45.6% 15.5% 88.4% OPENDRONEMAP ultra high 14.0% 4.7% 27.5% high 18.8% 6.0% 36.2% medium 32.0% 9.3% 61.5% low 34.4% 11.5% 66.7% lowest 38.0% 12.8% 75.0% PIX4D ultra high 13.5% 4.4% 27.0% high 14.0% 4.7% 27.8% medium 15.9% 5.0% 31.8% low 21.4% 6.5% 42.3% we can also make pairwise comparisons # calculate contrast brms_contrast_temp = draws_temp %&gt;% tidybayes::compare_levels( value , by = depth_maps_generation_quality , comparison = contrast_list ) %&gt;% dplyr::rename(contrast = depth_maps_generation_quality) # separate contrast brms_contrast_temp = brms_contrast_temp %&gt;% dplyr::ungroup() %&gt;% tidyr::separate_wider_delim( cols = contrast , delim = &quot; - &quot; , names = paste0( &quot;sorter&quot; , 1:(max(stringr::str_count(brms_contrast_temp$contrast, &quot;-&quot;))+1) ) , too_few = &quot;align_start&quot; , cols_remove = F ) %&gt;% dplyr::filter(sorter1!=sorter2) %&gt;% dplyr::mutate( dplyr::across( tidyselect::starts_with(&quot;sorter&quot;) , .fns = function(x){factor( x, ordered = T , levels = levels(ptcld_validation_data$depth_maps_generation_quality) )} ) , contrast = contrast %&gt;% forcats::fct_reorder( paste0(as.numeric(sorter1), as.numeric(sorter2)) %&gt;% as.numeric() ) ) %&gt;% # median_hdi summary for coloring dplyr::group_by(contrast, software) %&gt;% make_contrast_vars() # remove out-of-sample obs brms_contrast_temp = brms_contrast_temp %&gt;% dplyr::inner_join( ptcld_validation_data %&gt;% dplyr::distinct(software, depth_maps_generation_quality) , by = dplyr::join_by(software, sorter1 == depth_maps_generation_quality) ) %&gt;% dplyr::inner_join( ptcld_validation_data %&gt;% dplyr::distinct(software, depth_maps_generation_quality) , by = dplyr::join_by(software, sorter2 == depth_maps_generation_quality) ) plot it plt_contrast( brms_contrast_temp # , caption_text = form_temp , y_axis_title = &quot;quality&quot; , facet = &quot;software&quot; , label_size = 1.7 ) + scale_x_continuous( labels = scales::percent_format(accuracy = 1) , limits = c(-1.1,0.3) , breaks = seq(-1,1,0.5) ) + labs( subtitle = &quot;posterior predictive distribution of group constrasts with 95% &amp; 50% HDI\\nby software&quot; , x = &quot;constrast BA Abs. % Error&quot; ) ggplot2::ggsave( &quot;../data/qlty_sftwr_comp_ba_ape.png&quot; , plot = ggplot2::last_plot() + labs(subtitle = &quot;&quot;) , height = 7, width = 10.5 ) create plot for combining with other APE contrasts for publication ptchwrk_qlty_sftwr_comp_ba_ape = plt_contrast( brms_contrast_temp , y_axis_title = &quot;quality contrast&quot; , facet = &quot;software&quot; , label_size = 1.5 , label = &quot;pr_diff_lab_sm&quot; , annotate_size = 1.6 ) + labs( subtitle = &quot;&quot; # &quot;constrast BA Abs. % Error&quot; , x = &quot;BA Abs. % Error constrast&quot; ) + theme( legend.position=&quot;none&quot; , axis.title.y = element_text(size = 10, face = &quot;bold&quot;) , axis.title.x = element_text(size = 8) ) # ptchwrk_qlty_sftwr_comp_ba_ape and summarize these contrasts table_temp = brms_contrast_temp %&gt;% dplyr::group_by(contrast, software, pr_lt_zero) %&gt;% tidybayes::median_hdi(value) %&gt;% dplyr::arrange(contrast, software) %&gt;% dplyr::select(contrast, software, value, .lower, .upper, pr_lt_zero) %&gt;% dplyr::arrange(software, contrast) %&gt;% dplyr::mutate(dplyr::across(.cols = is.numeric, .fns = ~ scales::percent(.x,accuracy = 0.1))) table_temp %&gt;% dplyr::select(-c(software)) %&gt;% kableExtra::kbl( digits = 2 , caption = &quot;BA Abs. % Error&lt;br&gt;95% HDI of the posterior predictive distribution of group contrasts&quot; , col.names = c( &quot;quality contrast&quot; , &quot;median difference&lt;br&gt;BA Abs. % Error&quot; , &quot;HDI low&quot;, &quot;HDI high&quot; , &quot;Pr(diff&lt;0)&quot; ) , escape = F ) %&gt;% kableExtra::kable_styling() %&gt;% kableExtra::pack_rows(index = table(forcats::fct_inorder(table_temp$software))) %&gt;% kableExtra::scroll_box(height = &quot;8in&quot;) Table 8.10: BA Abs. % Error95% HDI of the posterior predictive distribution of group contrasts quality contrast median differenceBA Abs. % Error HDI low HDI high Pr(diff&lt;0) METASHAPE ultra high - high -1.3% -10.0% 6.3% 66% ultra high - medium -3.4% -13.9% 5.5% 82% ultra high - low -11.3% -27.3% -0.5% 99% ultra high - lowest -30.2% -62.1% -7.8% 100% high - medium -2.1% -12.3% 6.9% 71% high - low -9.9% -25.5% 0.5% 98% high - lowest -28.7% -60.6% -7.7% 100% medium - low -7.6% -22.6% 3.3% 94% medium - lowest -26.4% -56.5% -4.9% 100% low - lowest -18.2% -44.9% -0.3% 99% OPENDRONEMAP ultra high - high -4.6% -15.3% 3.3% 90% ultra high - medium -17.5% -39.1% -2.8% 100% ultra high - low -19.9% -42.6% -4.2% 100% ultra high - lowest -23.5% -50.0% -5.3% 100% high - medium -12.6% -32.3% -0.3% 99% high - low -14.9% -35.4% -1.4% 100% high - lowest -18.5% -42.9% -2.1% 100% medium - low -2.3% -20.3% 14.0% 63% medium - lowest -5.4% -29.1% 13.9% 74% low - lowest -3.3% -24.6% 16.3% 66% PIX4D ultra high - high -0.5% -8.7% 7.5% 56% ultra high - medium -2.3% -12.6% 6.4% 73% ultra high - low -7.5% -21.3% 2.5% 96% high - medium -1.8% -11.7% 7.0% 70% high - low -7.0% -20.5% 2.9% 95% medium - low -5.1% -18.8% 4.6% 88% The contrasts above address the question “are there differences in APE based on dense point cloud generation quality within each software?”. To address the different question of “are there differences in APE based on the processing software used at a given dense point cloud generation quality?” we need to utilize a different formulation of the comparison parameter within our call to the tidybayes::compare_levels function and calculate the contrast by software instead # calculate contrast brms_contrast_temp = draws_temp %&gt;% tidybayes::compare_levels( value , by = software , comparison = &quot;pairwise&quot; ) %&gt;% dplyr::rename(contrast = software) %&gt;% # median_hdi summary for coloring dplyr::group_by(contrast, depth_maps_generation_quality) %&gt;% make_contrast_vars() # remove out-of-sample obs brms_contrast_temp = brms_contrast_temp %&gt;% tidyr::separate_wider_delim( cols = contrast , delim = &quot; - &quot; , names = paste0( &quot;sorter&quot; , 1:(max(stringr::str_count(brms_contrast_temp$contrast, &quot;-&quot;))+1) ) , too_few = &quot;align_start&quot; , cols_remove = F ) %&gt;% dplyr::filter(sorter1!=sorter2) %&gt;% dplyr::inner_join( ptcld_validation_data %&gt;% dplyr::distinct(software, depth_maps_generation_quality) , by = dplyr::join_by(sorter1 == software, depth_maps_generation_quality) ) %&gt;% dplyr::inner_join( ptcld_validation_data %&gt;% dplyr::distinct(software, depth_maps_generation_quality) , by = dplyr::join_by(sorter2 == software, depth_maps_generation_quality) ) plot it plt_contrast( brms_contrast_temp # , caption_text = form_temp , y_axis_title = &quot;software&quot; , facet = &quot;depth_maps_generation_quality&quot; , label_size = 1.7 ) + scale_x_continuous( labels = scales::percent_format(accuracy = 1) , limits = c(-0.7,0.6) , breaks = seq(-0.6,0.6,0.3) ) + facet_wrap(facets = vars(depth_maps_generation_quality), ncol = 2) + labs( subtitle = &quot;posterior predictive distribution of group constrasts with 95% &amp; 50% HDI\\nby dense cloud quality&quot; , x = &quot;constrast BA Abs. % Error&quot; ) + theme( legend.position = c(.75, .13) ) + guides(fill = guide_colorbar(theme = theme( legend.key.width = unit(1, &quot;lines&quot;), legend.key.height = unit(7, &quot;lines&quot;) ))) ggplot2::ggsave( &quot;../data/sftwr_qlty_comp_ba_ape.png&quot; , plot = ggplot2::last_plot() + labs(subtitle = &quot;&quot;) , height = 7, width = 10.5 ) create plot for combining with other APE contrasts for publication ptchwrk_sftwr_qlty_comp_ba_ape = plt_contrast( brms_contrast_temp , y_axis_title = &quot;software contrast&quot; , facet = &quot;depth_maps_generation_quality&quot; , label_size = 1.7 , label = &quot;pr_diff_lab_sm&quot; , annotate_size = 1.8 ) + facet_wrap(facets = vars(depth_maps_generation_quality), ncol = 3) + labs( subtitle = &quot;&quot; , x = &quot;BA Abs. % Error constrast&quot; ) + theme( legend.position = &quot;inside&quot; , legend.position.inside = c(.8, .10) , axis.title.y = element_text(size = 10, face = &quot;bold&quot;) , axis.title.x = element_text(size = 8) ) + guides(fill = guide_colorbar(theme = theme( legend.key.width = unit(1, &quot;lines&quot;), legend.key.height = unit(6.5, &quot;lines&quot;) ))) # ptchwrk_sftwr_qlty_comp_ba_ape and summarize these contrasts table_temp = brms_contrast_temp %&gt;% dplyr::group_by(contrast, depth_maps_generation_quality, pr_lt_zero) %&gt;% tidybayes::median_hdi(value) %&gt;% dplyr::arrange(contrast, depth_maps_generation_quality) %&gt;% dplyr::select(contrast, depth_maps_generation_quality, value, .lower, .upper, pr_lt_zero) %&gt;% dplyr::mutate(dplyr::across(.cols = is.numeric, .fns = ~ scales::percent(.x,accuracy = 0.1))) table_temp %&gt;% dplyr::select(-c(contrast)) %&gt;% kableExtra::kbl( digits = 2 , caption = &quot;BA Abs. % Error&lt;br&gt;95% HDI of the posterior predictive distribution of group contrasts&quot; , col.names = c( &quot;quality&quot; , &quot;median difference&lt;br&gt;BA Abs. % Error&quot; , &quot;HDI low&quot;, &quot;HDI high&quot; , &quot;Pr(diff&lt;0)&quot; ) , escape = F ) %&gt;% kableExtra::kable_styling() %&gt;% kableExtra::pack_rows(index = table(forcats::fct_inorder(table_temp$contrast))) %&gt;% kableExtra::scroll_box(height = &quot;8in&quot;) Table 8.11: BA Abs. % Error95% HDI of the posterior predictive distribution of group contrasts quality median differenceBA Abs. % Error HDI low HDI high Pr(diff&lt;0) OPENDRONEMAP - METASHAPE ultra high -0.8% -9.4% 7.2% 60% high 2.4% -6.8% 12.9% 26% medium 12.9% -1.3% 33.8% 2% low 7.1% -7.5% 26.2% 13% low 7.1% 26.7% 27.4% 13% lowest -6.9% -34.3% 15.1% 77% PIX4D - METASHAPE ultra high -1.2% -10.2% 7.1% 66% high -2.1% -11.9% 6.6% 73% medium -2.4% -13.3% 7.8% 72% low -4.8% -20.9% 8.6% 80% PIX4D - OPENDRONEMAP ultra high -0.4% -9.6% 8.6% 55% high -4.5% -15.9% 4.9% 87% medium -15.5% -37.4% -0.5% 99% low -12.3% -33.8% 3.1% 96% 8.3.2.5 Software:Filtering - interaction draws_temp = tidyr::crossing( depth_maps_generation_filtering_mode = unique(ptcld_validation_data$depth_maps_generation_filtering_mode) , software = unique(ptcld_validation_data$software) ) %&gt;% tidybayes::add_epred_draws( brms_ba_ape_mod, allow_new_levels = T # this part is crucial , re_formula = ~ (1 | depth_maps_generation_filtering_mode) + (1 | software) + (1 | depth_maps_generation_filtering_mode:software) ) %&gt;% dplyr::rename(value = .epred) %&gt;% dplyr::mutate(med = tidybayes::median_hdci(value)$y) # plot draws_temp %&gt;% # remove out-of-sample obs dplyr::inner_join( ptcld_validation_data %&gt;% dplyr::distinct(depth_maps_generation_filtering_mode, software) , by = dplyr::join_by(depth_maps_generation_filtering_mode, software) ) %&gt;% # plot ggplot( mapping = aes( y = value, x = software , fill = med ) ) + geom_hline(yintercept = 0, color = &quot;gray33&quot;) + tidybayes::stat_eye( point_interval = median_hdi, .width = .95 , slab_alpha = 0.98 , interval_color = &quot;black&quot;, linewidth = 1 , point_color = &quot;black&quot;, point_fill = &quot;black&quot;, point_size = 1 ) + scale_fill_stepsn( n.breaks = 5 , colors = viridis::mako(n = 5, begin = 0.2, end = 0.9, direction = -1) , limits = c(0,lmt_basal_area_abs_pct_error*.6) , labels = scales::percent_format(accuracy = 0.1) , show.limits = T ) + facet_grid(cols = vars(depth_maps_generation_filtering_mode)) + scale_y_continuous( limits = c(-0.005,lmt_basal_area_abs_pct_error*1.1) , labels = scales::percent_format(accuracy = 1) ) + labs( x = &quot;software&quot;, y = &quot;BA Abs. % Error&quot; , subtitle = &quot;posterior predictive distribution of BA Abs. % Error with 95% HDI\\nby filtering mode&quot; ) + theme_light() + theme( legend.position = &quot;none&quot; , legend.direction = &quot;horizontal&quot; , axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1) , strip.text = element_text(color = &quot;black&quot;, face = &quot;bold&quot;) ) and a table of these 95% HDI values table_temp = draws_temp %&gt;% tidybayes::median_hdi(value) %&gt;% dplyr::select(-c(.point,.interval, .width,.row)) %&gt;% dplyr::arrange(software,depth_maps_generation_filtering_mode) %&gt;% dplyr::mutate(dplyr::across(.cols = is.numeric, .fns = ~ scales::percent(.x,accuracy = 0.1))) table_temp %&gt;% dplyr::select(-c(software)) %&gt;% kableExtra::kbl( digits = 2 , caption = &quot;BA Abs. % Error&lt;br&gt;95% HDI of the posterior predictive distribution&quot; , col.names = c( &quot;filtering mode&quot; , &quot;BA Abs. % Error&lt;br&gt;median&quot; , &quot;HDI low&quot;, &quot;HDI high&quot; ) , escape = F ) %&gt;% kableExtra::kable_styling() %&gt;% kableExtra::pack_rows(index = table(forcats::fct_inorder(table_temp$software))) %&gt;% kableExtra::scroll_box(height = &quot;8in&quot;) Table 8.12: BA Abs. % Error95% HDI of the posterior predictive distribution filtering mode BA Abs. % Errormedian HDI low HDI high METASHAPE aggressive 28.1% 7.4% 59.5% moderate 21.6% 5.3% 44.2% mild 20.0% 5.1% 41.1% disabled 18.6% 4.7% 38.5% OPENDRONEMAP aggressive 25.5% 6.3% 53.5% moderate 25.8% 7.1% 54.3% mild 25.0% 6.5% 51.8% disabled 22.4% 5.9% 46.8% PIX4D aggressive 20.4% 4.6% 46.0% moderate 18.9% 5.0% 39.8% mild 17.1% 4.5% 36.0% disabled 16.2% 4.1% 33.9% we can also make pairwise comparisons # calculate contrast brms_contrast_temp = draws_temp %&gt;% tidybayes::compare_levels( value , by = depth_maps_generation_filtering_mode , comparison = &quot;pairwise&quot; ) %&gt;% dplyr::rename(contrast = depth_maps_generation_filtering_mode) # separate contrast brms_contrast_temp = brms_contrast_temp %&gt;% dplyr::ungroup() %&gt;% tidyr::separate_wider_delim( cols = contrast , delim = &quot; - &quot; , names = paste0( &quot;sorter&quot; , 1:(max(stringr::str_count(brms_contrast_temp$contrast, &quot;-&quot;))+1) ) , too_few = &quot;align_start&quot; , cols_remove = F ) %&gt;% dplyr::filter(sorter1!=sorter2) %&gt;% dplyr::mutate( dplyr::across( tidyselect::starts_with(&quot;sorter&quot;) , .fns = function(x){factor( x, ordered = T , levels = levels(ptcld_validation_data$depth_maps_generation_filtering_mode) )} ) , contrast = contrast %&gt;% forcats::fct_reorder( paste0(as.numeric(sorter1), as.numeric(sorter2)) %&gt;% as.numeric() ) %&gt;% # re order for filtering mode forcats::fct_rev() ) %&gt;% # median_hdi summary for coloring dplyr::group_by(contrast, software) %&gt;% make_contrast_vars() # remove out-of-sample obs brms_contrast_temp = brms_contrast_temp %&gt;% dplyr::inner_join( ptcld_validation_data %&gt;% dplyr::distinct(software, depth_maps_generation_filtering_mode) , by = dplyr::join_by(software, sorter1 == depth_maps_generation_filtering_mode) ) %&gt;% dplyr::inner_join( ptcld_validation_data %&gt;% dplyr::distinct(software, depth_maps_generation_filtering_mode) , by = dplyr::join_by(software, sorter2 == depth_maps_generation_filtering_mode) ) plot it plt_contrast( brms_contrast_temp # , caption_text = form_temp , y_axis_title = &quot;filtering mode&quot; , facet = &quot;software&quot; , label_size = 1.6 ) + scale_x_continuous( labels = scales::percent_format(accuracy = 1) , limits = c(-0.8,0.65) , breaks = seq(-0.8,0.8,0.4) ) + labs( subtitle = &quot;posterior predictive distribution of group constrasts with 95% &amp; 50% HDI\\nby software&quot; , x = &quot;constrast BA Abs. % Error&quot; ) ggplot2::ggsave( &quot;../data/fltr_sftwr_comp_ba_ape.png&quot; , plot = ggplot2::last_plot() + labs(subtitle = &quot;&quot;) , height = 7, width = 10.5 ) create plot for combining with other APE contrasts for publication ptchwrk_fltr_sftwr_comp_ba_ape = plt_contrast( brms_contrast_temp , y_axis_title = &quot;filtering mode contrast&quot; , facet = &quot;software&quot; , label_size = 1.7 , label = &quot;pr_diff_lab_sm&quot; , annotate_size = 1.6 ) + labs( subtitle = &quot;&quot; # &quot;constrast BA Abs. % Error&quot; , x = &quot;BA Abs. % Error constrast&quot; ) + theme( legend.position=&quot;none&quot; , axis.title.y = element_text(size = 10, face = &quot;bold&quot;) , axis.title.x = element_text(size = 8) ) # ptchwrk_fltr_sftwr_comp_ba_ape and summarize these contrasts table_temp = brms_contrast_temp %&gt;% dplyr::group_by(contrast, software, pr_lt_zero) %&gt;% tidybayes::median_hdi(value) %&gt;% dplyr::arrange(contrast, software) %&gt;% dplyr::select(contrast, software, value, .lower, .upper, pr_lt_zero) %&gt;% dplyr::arrange(software, contrast) %&gt;% dplyr::mutate(dplyr::across(.cols = is.numeric, .fns = ~ scales::percent(.x,accuracy = 0.1))) table_temp %&gt;% dplyr::select(-c(software)) %&gt;% kableExtra::kbl( digits = 2 , caption = &quot;BA Abs. % Error&lt;br&gt;95% HDI of the posterior predictive distribution of group contrasts&quot; , col.names = c( &quot;filtering contrast&quot; , &quot;median difference&lt;br&gt;BA Abs. % Error&quot; , &quot;HDI low&quot;, &quot;HDI high&quot; , &quot;Pr(diff&lt;0)&quot; ) , escape = F ) %&gt;% kableExtra::kable_styling() %&gt;% kableExtra::pack_rows(index = table(forcats::fct_inorder(table_temp$software))) %&gt;% kableExtra::scroll_box(height = &quot;8in&quot;) Table 8.13: BA Abs. % Error95% HDI of the posterior predictive distribution of group contrasts filtering contrast median differenceBA Abs. % Error HDI low HDI high Pr(diff&lt;0) METASHAPE disabled - mild -1.2% -9.8% 6.4% 66% disabled - moderate -2.6% -12.4% 4.8% 80% disabled - aggressive -9.0% -26.0% 1.0% 98% mild - moderate -1.4% -10.5% 6.9% 67% mild - aggressive -7.5% -23.7% 2.2% 96% moderate - aggressive -6.0% -21.7% 3.4% 93% OPENDRONEMAP disabled - mild -2.2% -13.5% 6.7% 74% disabled - moderate -3.1% -15.1% 5.6% 81% disabled - aggressive -2.8% -16.5% 7.7% 75% mild - moderate -0.8% -11.7% -11.6% 59% mild - moderate -0.8% -11.4% 9.8% 59% mild - aggressive -0.5% -13.4% 11.6% 55% moderate - aggressive 0.2% -11.7% 12.6% 48% moderate - aggressive 0.2% 12.8% 12.9% 48% PIX4D disabled - mild -0.8% -8.8% 6.3% 63% disabled - moderate -2.4% -11.5% 4.6% 81% mild - moderate -1.5% -10.6% 5.8% 71% 8.3.2.6 Software:Quality:Filtering - interaction # get draws fltr_sftwr_draws_temp = tidyr::crossing( depth_maps_generation_quality = unique(ptcld_validation_data$depth_maps_generation_quality) , depth_maps_generation_filtering_mode = unique(ptcld_validation_data$depth_maps_generation_filtering_mode) , software = unique(ptcld_validation_data$software) ) %&gt;% tidybayes::add_epred_draws( brms_ba_ape_mod, allow_new_levels = T # this part is crucial , re_formula = ~ (1 | depth_maps_generation_quality) + # main effects (1 | depth_maps_generation_quality) + (1 | depth_maps_generation_filtering_mode) + (1 | software) + # two-way interactions (1 | depth_maps_generation_quality:depth_maps_generation_filtering_mode) + (1 | depth_maps_generation_quality:software) + (1 | depth_maps_generation_filtering_mode:software) + # three-way interactions (1 | depth_maps_generation_quality:depth_maps_generation_filtering_mode:software) ) %&gt;% dplyr::rename(value = .epred) %&gt;% dplyr::mutate(med = tidybayes::median_hdci(value)$y) # plot qlty_fltr_sftwr_ba_ape = fltr_sftwr_draws_temp %&gt;% dplyr::inner_join( ptcld_validation_data %&gt;% dplyr::distinct(software, depth_maps_generation_quality, depth_maps_generation_filtering_mode) , by = dplyr::join_by(software, depth_maps_generation_quality, depth_maps_generation_filtering_mode) ) %&gt;% dplyr::mutate(depth_maps_generation_quality = depth_maps_generation_quality %&gt;% forcats::fct_rev()) %&gt;% ggplot( mapping = aes( y = value , x = depth_maps_generation_filtering_mode , fill = med ) ) + geom_hline(yintercept = 0, color = &quot;gray33&quot;) + tidybayes::stat_eye( point_interval = median_hdi, .width = .95 , slab_alpha = 0.98 , interval_color = &quot;black&quot;, linewidth = 1 , point_color = &quot;black&quot;, point_fill = &quot;black&quot;, point_size = 1 ) + scale_fill_stepsn( n.breaks = 5 , colors = viridis::mako(n = 5, begin = 0.2, end = 0.9, direction = -1) , limits = c(0,lmt_basal_area_abs_pct_error*.6) , labels = scales::percent_format(accuracy = 0.1) , show.limits = T ) + facet_grid( rows = vars(software) , cols = vars(depth_maps_generation_quality) # , switch = &quot;y&quot; ) + scale_y_continuous( limits = c(-0.005,lmt_basal_area_abs_pct_error*1.45) , labels = scales::percent_format(accuracy = 1) ) + labs( x = &quot;filtering mode&quot;, y = &quot;BA Abs. % Error&quot; , subtitle = &quot;posterior predictive distribution of BA Abs. % Error with 95% HDI\\nby dense cloud quality and software&quot; # , caption = form_temp ) + theme_light() + theme( legend.position = &quot;none&quot; , legend.direction = &quot;horizontal&quot; , axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1) , strip.text = element_text(color = &quot;black&quot;, face = &quot;bold&quot;) , panel.grid = element_blank() # , strip.placement = &quot;outside&quot; ) + guides( fill = guide_legend(override.aes = list(shape = NA, size = 6, alpha = 0.9, lwd = NA)) ) # print it qlty_fltr_sftwr_ba_ape ggplot2::ggsave(&quot;../data/qlty_fltr_sftwr_ba_ape.png&quot;, height = 7, width = 10.5) and a table of these 95% HDI values table_temp = fltr_sftwr_draws_temp %&gt;% tidybayes::median_hdi(value) %&gt;% dplyr::inner_join( ptcld_validation_data %&gt;% dplyr::distinct(software, depth_maps_generation_quality, depth_maps_generation_filtering_mode) , by = dplyr::join_by(software, depth_maps_generation_quality, depth_maps_generation_filtering_mode) ) %&gt;% dplyr::mutate(depth_maps_generation_quality = depth_maps_generation_quality %&gt;% forcats::fct_rev()) %&gt;% dplyr::select(c( software, depth_maps_generation_quality, depth_maps_generation_filtering_mode , value, .lower, .upper )) %&gt;% dplyr::ungroup() %&gt;% dplyr::arrange(software, depth_maps_generation_quality, depth_maps_generation_filtering_mode) %&gt;% dplyr::mutate(dplyr::across(.cols = is.numeric, .fns = ~ scales::percent(.x,accuracy = 0.1))) table_temp %&gt;% # dplyr::select(-c(software)) %&gt;% kableExtra::kbl( digits = 2 , caption = &quot;BA Abs. % Error&lt;br&gt;95% HDI of the posterior predictive distribution&quot; , col.names = c( &quot;software&quot;, &quot;quality&quot;, &quot;filtering mode&quot; , &quot;BA Abs. % Error&lt;br&gt;median&quot; , &quot;HDI low&quot;, &quot;HDI high&quot; ) , escape = F ) %&gt;% kableExtra::kable_styling() %&gt;% # kableExtra::pack_rows(index = table(forcats::fct_inorder(table_temp$software))) %&gt;% kableExtra::collapse_rows(columns = 1:2, valign = &quot;top&quot;) %&gt;% kableExtra::scroll_box(height = &quot;8in&quot;) Table 8.14: BA Abs. % Error95% HDI of the posterior predictive distribution software quality filtering mode BA Abs. % Errormedian HDI low HDI high METASHAPE lowest aggressive 61.5% 23.2% 116.0% moderate 47.4% 18.7% 88.3% mild 41.8% 15.5% 78.8% disabled 39.2% 14.9% 74.3% low aggressive 38.1% 14.1% 70.6% moderate 27.0% 10.1% 50.3% mild 23.8% 8.8% 44.6% disabled 21.6% 7.7% 40.7% medium aggressive 25.5% 9.1% 47.6% moderate 17.9% 7.0% 34.2% mild 16.8% 6.2% 31.8% disabled 15.6% 5.3% 29.2% high aggressive 20.7% 7.7% 39.4% moderate 15.9% 6.0% 29.6% mild 15.3% 5.9% 28.5% disabled 14.4% 5.8% 27.2% ultra high aggressive 18.7% 7.1% 36.2% moderate 14.7% 5.6% 27.7% mild 14.2% 5.6% 26.5% disabled 13.0% 5.1% 24.2% OPENDRONEMAP lowest aggressive 40.5% 15.2% 77.9% moderate 41.3% 14.4% 77.2% mild 39.3% 15.1% 74.2% disabled 35.4% 12.6% 65.9% low aggressive 38.3% 13.8% 72.3% moderate 37.7% 14.2% 70.8% mild 35.2% 13.7% 65.4% disabled 31.3% 12.3% 58.2% medium aggressive 35.2% 13.5% 67.3% moderate 34.3% 12.9% 64.2% mild 33.4% 12.6% 62.6% disabled 30.0% 11.7% 56.5% high aggressive 19.3% 7.1% 36.6% moderate 20.2% 7.9% 37.4% mild 19.9% 7.3% 36.6% disabled 17.9% 7.3% 33.8% ultra high aggressive 14.3% 5.0% 27.3% moderate 15.1% 5.5% 28.1% mild 14.7% 5.6% 27.9% disabled 12.6% 4.4% 23.8% PIX4D low moderate 23.1% 8.8% 43.5% mild 19.5% 7.5% 37.4% disabled 18.0% 6.3% 34.2% medium moderate 16.2% 6.0% 30.9% mild 14.7% 5.5% 28.4% disabled 14.0% 5.1% 26.6% high moderate 14.2% 5.5% 27.1% mild 13.2% 5.0% 24.9% disabled 12.8% 4.7% 23.7% ultra high moderate 14.0% 5.3% 26.5% mild 13.0% 4.9% 24.6% disabled 12.1% 4.6% 22.9% we can also make pairwise comparisons # calculate contrast brms_contrast_temp = fltr_sftwr_draws_temp %&gt;% tidybayes::compare_levels( value , by = depth_maps_generation_filtering_mode , comparison = &quot;pairwise&quot; ) %&gt;% dplyr::rename(contrast = depth_maps_generation_filtering_mode) # separate contrast brms_contrast_temp = brms_contrast_temp %&gt;% dplyr::ungroup() %&gt;% tidyr::separate_wider_delim( cols = contrast , delim = &quot; - &quot; , names = paste0( &quot;sorter&quot; , 1:(max(stringr::str_count(brms_contrast_temp$contrast, &quot;-&quot;))+1) ) , too_few = &quot;align_start&quot; , cols_remove = F ) %&gt;% dplyr::filter(sorter1!=sorter2) %&gt;% dplyr::mutate( dplyr::across( tidyselect::starts_with(&quot;sorter&quot;) , .fns = function(x){factor( x, ordered = T , levels = levels(ptcld_validation_data$depth_maps_generation_filtering_mode) )} ) , contrast = contrast %&gt;% forcats::fct_reorder( paste0(as.numeric(sorter1), as.numeric(sorter2)) %&gt;% as.numeric() ) %&gt;% # re order for filtering mode forcats::fct_rev() ) %&gt;% # median_hdi summary for coloring dplyr::group_by(contrast, software, depth_maps_generation_quality) %&gt;% make_contrast_vars() # remove out-of-sample obs brms_contrast_temp = brms_contrast_temp %&gt;% dplyr::inner_join( ptcld_validation_data %&gt;% dplyr::distinct(software, depth_maps_generation_quality, depth_maps_generation_filtering_mode) , by = dplyr::join_by(software, depth_maps_generation_quality, sorter1==depth_maps_generation_filtering_mode) ) %&gt;% dplyr::inner_join( ptcld_validation_data %&gt;% dplyr::distinct(software, depth_maps_generation_quality, depth_maps_generation_filtering_mode) , by = dplyr::join_by(software, depth_maps_generation_quality, sorter2==depth_maps_generation_filtering_mode) ) %&gt;% dplyr::mutate(depth_maps_generation_quality = depth_maps_generation_quality %&gt;% forcats::fct_rev()) plot it brms_contrast_temp %&gt;% plt_contrast( facet = c(&quot;depth_maps_generation_quality&quot;, &quot;software&quot;) , y_axis_title = &quot;filtering mode&quot; , label_size = 0 ) + facet_grid( rows = vars(software) , cols = vars(depth_maps_generation_quality) ) + scale_x_continuous( labels = scales::percent_format(accuracy = 1) , limits = c(-0.8,0.4) , breaks = seq(-0.8,0.8,0.4) ) + labs( subtitle = &quot;posterior predictive distribution of group constrasts with 95% &amp; 50% HDI\\nby dense cloud quality and software&quot; , x = &quot;constrast BA Abs. % Error&quot; ) ggplot2::ggsave( &quot;../data/qlty_fltr_sftwr_comp_ba_ape.png&quot; , plot = ggplot2::last_plot() + labs(subtitle = &quot;&quot;) , height = 7, width = 10.5 ) Export some final images for publication p1_temp = qlty_fltr_sftwr_ba_pe + labs(subtitle = &quot;A: Basal Area % Error&quot;) + theme(plot.subtitle = element_text(face=&quot;bold&quot;)) p2_temp = qlty_fltr_sftwr_ba_ape + labs(subtitle = &quot;B: Basal Area Abs. % Error&quot;) + theme(plot.subtitle = element_text(face=&quot;bold&quot;)) # export p1_temp / p2_temp ggplot2::ggsave( filename = paste0(&quot;../data/qlty_fltr_sftwr_ba_comb.jpeg&quot;) , plot = ggplot2::last_plot() , width = 8.5 , height = 11 , units = &quot;in&quot; , dpi = &quot;print&quot; ) patchwork of Height APE contrasts layout_temp = c( # area(t, l, b, r) patchwork::area(2, 1, 2, 1) , patchwork::area(2, 3, 2, 3) , patchwork::area(4, 1, 4, 3) ) # check the layout # plot(layout_temp) ############################ # patchwork for height ############################ ptchwrk_qlty_sftwr_comp_ba_ape + labs(subtitle = &quot;A: Quality Contrast by Software&quot;) + theme(plot.background = element_rect(colour = &quot;gray88&quot;, fill=NA, size=3)) + ptchwrk_fltr_sftwr_comp_ba_ape + labs(subtitle = &quot;B: Filtering Mode Contrast by Software&quot;) + theme(plot.background = element_rect(colour = &quot;gray88&quot;, fill=NA, size=3)) + patchwork::free( ptchwrk_sftwr_qlty_comp_ba_ape + labs(subtitle = &quot;C: Software Contrast by Quality&quot;) + theme(plot.background = element_rect(colour = &quot;gray88&quot;, fill=NA, size=3)) ) + # plot_annotation(tag_levels = list(c(&#39;#&#39;, &#39;&amp;&#39;), &#39;1&#39;)) + patchwork::plot_layout( design = layout_temp , widths = c(1,0.01,1) , heights = c(0.01,1,0.01,1,0.01) ) &amp; scale_x_continuous( labels = scales::percent_format(accuracy = 1) , limits = c(-1.1,0.52) , breaks = seq(-0.8,0.8,0.4) ) &amp; theme( axis.title.y = element_blank() , plot.subtitle = element_text(face = &quot;bold&quot;, hjust = 0.0) # , plot.background = element_rect(colour = &quot;gray88&quot;, fill=NA, size=3) ) ggplot2::ggsave( filename = paste0(&quot;../data/all_ba_ape_contrasts.jpeg&quot;) , plot = ggplot2::last_plot() , width = 11 , height = 8.5 , units = &quot;in&quot; , dpi = &quot;print&quot; ) 8.4 Posterior Predictive Checks Markov chain Monte Carlo (MCMC) simulations were conducted using the brms package (Bürkner 2017) to estimate posterior predictive distributions of the parameters of interest. We ran three chains of 100,000 iterations with the first 50,000 discarded as burn-in. Trace-plots were utilized to visually assess model convergence and sufficient convergence was checked with \\(\\hat{R}\\) values near 1 (Brooks &amp; Gelman, 1998). Posterior predictive checks were used to evaluate model goodness-of-fit by comparing data simulated from the model with the observed data used to estimate the model parameters (Hobbs &amp; Hooten, 2015). Calculating the proportion of MCMC iterations in which the test statistic (i.e., mean and sum of squares) from the simulated data and observed data are more extreme than one another provides the Bayesian P-value. Lack of fit is indicated by a value close to 0 or 1 while a value of 0.5 indicates perfect fit (Hobbs &amp; Hooten, 2015). To learn more about this approach to posterior predictive checks, check out Gabry’s (2022) vignette, Graphical posterior predictive checks using the bayesplot package. 8.4.1 Prior Distriubutions plt_prior11+plt_prior12 &amp; theme(strip.text = element_text(size = 6)) 8.4.2 Trace-plots check the trace plots for problems with convergence of the Markov chains 8.4.2.1 Basal Area Percentage Error # height mean error plot(brms_ba_pe_mod) 8.4.2.2 Basal Area Abs. percentage error # height rmse plot(brms_ba_ape_mod) 8.4.3 \\(\\hat{R}\\) values plt_rhat_temp &lt;- function(my_mod) { my_mod %&gt;% brms::rhat() %&gt;% as.data.frame() %&gt;% tibble::rownames_to_column(var = &quot;parameter&quot;) %&gt;% dplyr::rename_with(tolower) %&gt;% dplyr::rename(rhat = 2) %&gt;% dplyr::filter( stringr::str_starts(parameter, &quot;b_&quot;) | stringr::str_starts(parameter, &quot;r_&quot;) | stringr::str_starts(parameter, &quot;sd_&quot;) | parameter == &quot;phi&quot; | parameter == &quot;sigma&quot; ) %&gt;% dplyr::mutate( parameter = parameter %&gt;% stringr::str_replace_all(&quot;depth_maps_generation_quality&quot;, &quot;quality&quot;) %&gt;% stringr::str_replace_all(&quot;depth_maps_generation_filtering_mode&quot;, &quot;filtering&quot;) , chk = (rhat &lt;= 1*0.998 | rhat &gt;= 1*1.002) ) %&gt;% ggplot(aes(x = rhat, y = parameter, color = chk, fill = chk)) + geom_vline(xintercept = 1, linetype = &quot;dashed&quot;, color = &quot;gray44&quot;, lwd = 1.2) + geom_vline(xintercept = 1*0.998, lwd = 1.5) + geom_vline(xintercept = 1*1.002, lwd = 1.5) + geom_vline(xintercept = 1*0.999, lwd = 1.2, color = &quot;gray33&quot;) + geom_vline(xintercept = 1*1.001, lwd = 1.2, color = &quot;gray33&quot;) + geom_point() + scale_fill_manual(values = c(&quot;navy&quot;, &quot;firebrick&quot;)) + scale_color_manual(values = c(&quot;navy&quot;, &quot;firebrick&quot;)) + scale_y_discrete(NULL, breaks = NULL) + labs( x = latex2exp::TeX(&quot;$\\\\hat{R}$&quot;) , subtitle = latex2exp::TeX(&quot;MCMC chain convergence check for $\\\\hat{R}$ values&quot;) ) + theme_light() + theme( legend.position = &quot;none&quot; , axis.text.y = element_text(size = 3) , panel.grid.major.x = element_blank() , panel.grid.minor.x = element_blank() , plot.title = element_text(size = 9) , plot.subtitle = element_text(size = 8) , axis.title.y = element_blank() , axis.title.x = element_text(size = 9) , panel.grid = element_blank() , axis.text.x = element_text(size = 6.5) ) } # plot together with patchwork brms_ba_pe_mod %&gt;% plt_rhat_temp() + labs(title = &quot;Basal Area Percentage Error&quot;) + brms_ba_ape_mod %&gt;% plt_rhat_temp() + labs(title = &quot;Basal Area Absolute Percentage Error&quot;) &amp; theme(plot.subtitle = element_blank()) 8.4.4 ESS values The effective length of an MCMC chain is indicated by the effective sample size (ESS), which refers to the sample size of the MCMC chain not to the sample size of the data Kruschke (2015) notes: One simple guideline is this: For reasonably accurate and stable estimates of the limits of the 95% HDI, an ESS of 10,000 is recommended. This is merely a heuristic based on experience with practical applications, it is not a requirement. If accuracy of the HDI limits is not crucial for your application, then a smaller ESS may be sufficient. (p.184) plt_ess_temp &lt;- function(my_mod) { # get ess values from model summary dplyr::bind_rows( summary(my_mod) %&gt;% purrr::pluck(&quot;random&quot;) %&gt;% purrr::flatten() %&gt;% purrr::keep_at(~ .x == &quot;Bulk_ESS&quot;) %&gt;% unlist() %&gt;% dplyr::as_tibble() , summary(my_mod) %&gt;% purrr::pluck(&quot;fixed&quot;) %&gt;% purrr::flatten() %&gt;% purrr::keep_at(~ .x == &quot;Bulk_ESS&quot;) %&gt;% unlist() %&gt;% dplyr::as_tibble() ) %&gt;% dplyr::rename(ess = 1) %&gt;% dplyr::mutate(parameter = dplyr::row_number(), chk = ess&lt;10000) %&gt;% ggplot(aes(x = ess, y = parameter, color = chk, fill = chk)) + geom_vline(xintercept = 10000, linetype = &quot;dashed&quot;, color = &quot;gray44&quot;, lwd = 1.2) + geom_segment( aes(x = 0, xend=ess, yend=parameter), color=&quot;black&quot;) + geom_point() + scale_fill_manual(values = c(&quot;blue4&quot;, &quot;blue3&quot;)) + scale_color_manual(values = c(&quot;blue4&quot;, &quot;blue3&quot;)) + scale_y_continuous(NULL, breaks = NULL) + scale_x_continuous(labels = scales::comma) + labs( x = &quot;ESS&quot; , subtitle = &quot;MCMC chain resolution check for effective sample size (ESS) values&quot; , y = &quot;&quot; ) + theme_light() + theme( legend.position = &quot;none&quot; , axis.text.y = element_text(size = 4) , panel.grid.major.x = element_blank() , panel.grid.minor.x = element_blank() , plot.title = element_text(size = 9) , plot.subtitle = element_text(size = 8) , axis.title.y = element_blank() , axis.title.x = element_text(size = 9) , axis.text.x = element_text(size = 6.5) ) } # plot together with patchwork brms_ba_pe_mod %&gt;% plt_ess_temp() + labs(title = &quot;Basal Area Percentage Error&quot;) + brms_ba_ape_mod %&gt;% plt_ess_temp() + labs(title = &quot;Basal Area Absolute Percentage Error&quot;) &amp; theme(plot.subtitle = element_blank()) 8.4.5 Mean and SD posterior predictive check for the overall model combining mean and sd plt_pp_temp &lt;- function(my_mod) { my_mod %&gt;% brms::pp_check(type = &quot;stat_2d&quot;, ndraws = 5000) + theme_light() + theme( legend.position = &quot;top&quot;, legend.direction = &quot;horizontal&quot; , legend.text = element_text(size = 8) , plot.title = element_text(size = 9) ) } # plot together with patchwork brms_ba_pe_mod %&gt;% plt_pp_temp() + labs(title = &quot;Basal Area Percentage Error&quot;) + brms_ba_ape_mod %&gt;% plt_pp_temp() + labs(title = &quot;Basal Area Absolute Percentage Error&quot;) &amp; theme(plot.subtitle = element_blank()) 8.4.6 Bayesian p-value The Bayesian p-value is the probability that a test statistic in the reference distribution exceeds its value in the data. The Bayesian p-value is calculated from the posterior predictive distribution of the new data and the distribution of the observed data. We estimate the probability that the test statistic calculated from “new” data arising from our model (\\(y_{new}\\)) is more extreme than the test statistic calculated from the observed data (\\(y\\)): \\(\\text{P-value}(y) = Pr(T(y_{new}) &gt; T(y))\\) where the test statistic \\(T(y)\\) describes the distribution of the data as a summary of the data; it could be the mean, variance, the coefﬁcient of variation, the kurtosis, the maximum, or the minimum of the observed data set, or it might be an “omnibus” statistic like a squared discrepancy or a chi-square value Hobbs and Hooten (2015, p. 188) Bayesian P values for mean and standard deviation test statistics The P values for the mean (P mean) give the probability that the mean of the data of new, out-of-sample observations simulated from the model exceeds the mean of the observed data. The P values for the standard deviation (P SD) give the probability that the standard deviation of new, out-of-sample observations simulated from the model exceeds the standard deviation of the observed data. Large (\\(\\gtrapprox 0.90\\)) or small (\\(\\lessapprox 0.10\\)) values indicate lack of fit. Hobbs and Hooten (2015);Hobbs et al. (2024, Appendix S2 p. 8) Check the Bayesian p-values between the models # get the model p-values set.seed(41) # replicate results dplyr::bind_rows( get_mod_p_val(brms_ba_pe_mod, ndraws = 5000) %&gt;% dplyr::mutate(model = &quot;brms_ba_pe_mod&quot;) , get_mod_p_val(brms_ba_ape_mod, ndraws = 5000) %&gt;% dplyr::mutate(model = &quot;brms_ba_ape_mod&quot;) ) %&gt;% dplyr::relocate(model) %&gt;% kableExtra::kbl(digits = 3) %&gt;% kableExtra::kable_styling() model P.mean P.sd brms_ba_pe_mod 0.513 0.569 brms_ba_ape_mod 0.661 0.894 8.4.7 \\(\\sigma\\) posteriors Finally, we can quantify the variation in our dependent variable by comparing the \\(\\sigma\\) (sd) posteriors plt_sigma_temp &lt;- function(my_mod) { # extract the posterior draws brms::as_draws_df(my_mod) %&gt;% dplyr::select(c(tidyselect::starts_with(&quot;sd_&quot;))) %&gt;% tidyr::pivot_longer(dplyr::everything()) %&gt;% # dplyr::group_by(name) %&gt;% # tidybayes::median_hdi(value) %&gt;% dplyr::mutate( name = name %&gt;% stringr::str_replace_all(&quot;depth_maps_generation_quality&quot;, &quot;quality&quot;) %&gt;% stringr::str_replace_all(&quot;depth_maps_generation_filtering_mode&quot;, &quot;filtering&quot;) %&gt;% stringr::str_remove_all(&quot;sd_&quot;) %&gt;% stringr::str_remove_all(&quot;__Intercept&quot;) %&gt;% stringr::str_replace_all(&quot;_&quot;, &quot; &quot;) %&gt;% forcats::fct_reorder(value) ) %&gt;% # plot ggplot(aes(x = value, y = name)) + tidybayes::stat_dotsinterval( point_interval = median_hdi, .width = .95 , justification = -0.04 , shape = 21 #, point_size = 3 , quantiles = 100 ) + scale_x_continuous(breaks = NULL) + labs(x = &quot;&quot;, y = &quot;&quot; , subtitle = latex2exp::TeX(&quot;$\\\\sigma_\\\\beta$ posterior distributions&quot;) ) + theme_light() + theme( plot.subtitle = element_text(size = 8) , plot.title = element_text(size = 9) ) } # plot together with patchwork brms_ba_pe_mod %&gt;% plt_sigma_temp() + labs(title = &quot;Basal Area Percentage Error&quot;) + brms_ba_ape_mod %&gt;% plt_sigma_temp() + labs(title = &quot;Basal Area Absolute Percentage Error&quot;) Variance of study site is slightly stronger than variance of depth map generation quality, but the posterior predictive distributions overlap a good deal. The study site (the “subjects” in our study) seems to have the overall strongest effect, but this comes with high uncertainty. Taken alone, the influence of quality and software comes with huge uncertainty. This makes sense as the influence of software largely depends on the depth map generation quality. Likewise, the influence of quality depends on the software. We are fairly certain of this conditional influence based on the uncertainty associated with the interaction of these two terms. Filtering mode by itself has the weakest effect on tree detection and this comes with relatively high certainty. As with the influence of software, we are certain that the effect of filtering mode is conditional on the depth map generation quality. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]

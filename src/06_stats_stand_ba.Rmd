# Statistical Analysis: Stand Basal Area{#stand_ba}

In this section, we'll evaluate the influence of the processing parameters on UAS-determined stand basal area. The accuracy UAS-derived stand basal area is impacted by the detection of individual trees (modeled in [this section](#beta_mod)) and the estimated DBH of those detected trees (modeled in [this section](#stats_detected_dbh)). 

Even though there are concerns with the under-detection of smaller trees in the understory ([Tinkham & Swayze 2021](https://scholar.google.com/scholar?cluster=11260597505702247290&hl=en&as_sdt=0,6)), the use of tree lists derived from remote sensing data (i.e. UAS SfM and Lidar) can still be useful for monitoring aspects of ecosystem function that are driven by large trees ([Jeronimo et al. 2018](https://scholar.google.com/scholar?cluster=7029219876484941766&hl=en&as_sdt=0,6)). 

[Jeronimo et al. 2018](https://scholar.google.com/scholar?cluster=7029219876484941766&hl=en&as_sdt=0,6) summarize this idea:

>Large trees dominate basal area and biomass (Lutz et al. 2012; Bastin et al. 2015), carbon accumulation and growth (Sillett et  al. 2010; Stephenson et al. 2014), and stand spatial heterogeneity (Lutz et  al. 2013), and they provide unique structures that are keystone elements of many vertebrate species’ habitat requirements (Tews et al. 2004; North et  al. 2017). Analysis of ITD results can capture the majority of variation in these processes even while omitting many smaller trees. For example, several studies have predicted biomass and volume directly from ITD results using allometric equations, explaining 67–93 percent of variation in even-aged pine plantations (Bortolot and Wynne 2005; Popescu 2007) and achieving error rates less than about 30 percent for Douglas-fir forests in various successional stages (Edson and Wing 2011). (p. 341)

We will utilize our "full" model presented [here](#stats_detected_model)

## Setup

load the data if needed 

```{r}
# load data if needed
if(ls()[ls() %in% "ptcld_validation_data"] %>% length()==0){
 ptcld_validation_data = readr::read_csv("../data/ptcld_full_analysis_data.csv") %>% 
   dplyr::mutate(
      depth_maps_generation_quality = factor(
          depth_maps_generation_quality %>% 
            tolower() %>% 
            stringr::str_replace_all("ultrahigh", "ultra high")
          , ordered = TRUE
          , levels = c(
            "lowest"
            , "low"
            , "medium"
            , "high"
            , "ultra high"
          )
        ) %>% forcats::fct_rev()
      , depth_maps_generation_filtering_mode = factor(
          depth_maps_generation_filtering_mode %>% tolower()
          , ordered = TRUE
          , levels = c(
            "disabled"
            , "mild"
            , "moderate"
            , "aggressive"
          )
        ) %>% forcats::fct_rev()
    )
}
```

load our plotting functions if needed (not showing these functions here but see the [prior section](#stats_validation) for function definitions)

```{r, include=FALSE}
# function to pull the formula for labeling below
get_frmla_text = function(frmla_chr, split_chrs = 100){
  cumsum_group = function(x, threshold) {
    cumsum = 0
    group = 1
    result = numeric()
    for (i in 1:length(x)) {
      cumsum = cumsum + x[i]
      if (cumsum > threshold) {
        group = group + 1
        cumsum = x[i]
      }
      result = c(result, group)
    }
    return (result)
  }
  
  r = stringr::str_sub(
    frmla_chr
    , # get the two column matrix of start end
      frmla_chr %>% 
        stringr::str_locate_all("\\+") %>% 
        .[[1]] %>% 
        dplyr::as_tibble() %>% 
        dplyr::select(start) %>% 
        dplyr::mutate(
          len = dplyr::coalesce(start-dplyr::lag(start),0)
          , ld = dplyr::coalesce(dplyr::lead(start)-1, stringr::str_length(frmla_chr))
          , cum = cumsum_group(len, split_chrs)
          , start = ifelse(dplyr::row_number()==1,1,start)
        ) %>% 
        dplyr::group_by(cum) %>% 
        dplyr::summarise(start = min(start), end = max(ld)) %>% 
        dplyr::ungroup() %>% 
        dplyr::select(-cum) %>% 
        as.matrix()
    ) %>% 
    stringr::str_squish() %>% 
    paste0(collapse = "\n")
  
  return(r)
}

# plot contrast function
plt_contrast <- function(
    my_data
    , x = "value"
    , y = "contrast"
    , fill = "pr_diff"
    , label = "pr_diff_lab"
    , label_pos = "pr_diff_lab_pos"
    , label_size = 3
    , x_expand = c(0.1, 0.1)
    , facet = NA
    , y_axis_title = ""
    , caption_text = "" # form_temp
    , annotate_size = 2.2
    ) {
  # df for annotation
  get_annotation_df <- function(
        my_text_list = c(
          "Bottom Left (h0,v0)","Top Left (h0,v1)"
          ,"Bottom Right h1,v0","Top Right h1,v1"
          )
        , hjust = c(0,0,1,1) # higher values = right, lower values = left 
        , vjust = c(0,1.3,0,1.3) # higher values = down, lower values = up
    ){
      df = data.frame(
        xpos = c(-Inf,-Inf,Inf,Inf)
        , ypos =  c(-Inf, Inf,-Inf,Inf)
        , annotate_text = my_text_list
        , hjustvar = hjust
        , vjustvar = vjust
      )  
      return(df)
  }
  # plot
  plt = 
    my_data %>%
    ggplot(aes(x = .data[[x]], y = .data[[y]])) +
      geom_vline(xintercept = 0, linetype = "solid", color = "gray33", lwd = 1.1) +
      tidybayes::stat_halfeye(
        mapping = aes(fill = .data[[fill]])
        , point_interval = median_hdi, .width = c(0.5,0.95)
        # , slab_fill = "gray22", slab_alpha = 1
        , interval_color = "black", point_color = "black", point_fill = "black"
        , point_size = 0.9
        , justification = -0.01
      ) +
      geom_text(
        data = get_annotation_df(
          my_text_list = c(
          "","L.H.S. < R.H.S."
          ,"","L.H.S. > R.H.S."
          )
        )
        , mapping = aes(
          x = xpos, y = ypos
          , hjust = hjustvar, vjust = vjustvar
          , label = annotate_text
          , fontface = "bold"
        )
        , size = annotate_size
        , color = "gray30" # "#2d2a4d" #"#204445"
      ) + 
      # scale_fill_fermenter(
      #   n.breaks = 5 # 10 use 10 if can go full range 0-1
      #   , palette = "PuOr" # "RdYlBu"
      #   , direction = 1
      #   , limits = c(0.5,1) # use c(0,1) if can go full range 0-1
      #   , labels = scales::percent
      # ) +
      scale_fill_stepsn(
        n.breaks = 5 # 10 use 10 if can go full range 0-1
        , colors = RColorBrewer::brewer.pal(11,"PuOr")[c(3,4,8,10,11)]
        , limits = c(0.5,1) # use c(0,1) if can go full range 0-1
        , labels = scales::percent
      ) +
      scale_x_continuous(expand = expansion(mult = x_expand)) +
      labs(
        y = y_axis_title
        , x = "constrast"
        , fill = "Pr(contrast)"
        , subtitle = "posterior predictive distribution of group constrasts with 95% & 50% HDI"
        , caption = caption_text
      ) +
      theme_light() +
      theme(
        legend.text = element_text(size = 7)
        , legend.title = element_text(size = 8)
        , axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1.05)
        , strip.text = element_text(color = "black", face = "bold")
      ) +
      guides(fill = guide_colorbar(theme = theme(
        legend.key.width  = unit(1, "lines"),
        legend.key.height = unit(12, "lines")
      )))
  # return facet or not
  if(max(is.na(facet))==0){
    return(
      plt +
        geom_text(
          data = my_data %>%
            dplyr::filter(pr_diff_lab_pos>=0) %>% 
            dplyr::ungroup() %>% 
            dplyr::select(tidyselect::all_of(c(
              y
              , fill
              , label
              , label_pos
              , facet
            ))) %>% 
            dplyr::distinct()
          , mapping = aes(x = .data[[label_pos]], label = .data[[label]])
          , vjust = -1, hjust = 0, size = label_size
        ) +
        geom_text(
          data = my_data %>%
            dplyr::filter(pr_diff_lab_pos<0) %>% 
            dplyr::ungroup() %>% 
            dplyr::select(tidyselect::all_of(c(
              y
              , fill
              , label
              , label_pos
              , facet
            ))) %>% 
            dplyr::distinct()
          , mapping = aes(x = .data[[label_pos]], label = .data[[label]])
          , vjust = -1, hjust = +1, size = label_size
        ) +
        facet_grid(cols = vars(.data[[facet]]))
        
    )
  }
  else{
    return(
      plt +
        geom_text(
          data = my_data %>%
            dplyr::filter(pr_diff_lab_pos>=0) %>% 
            dplyr::ungroup() %>% 
            dplyr::select(tidyselect::all_of(c(
              y
              , fill
              , label
              , label_pos
            ))) %>% 
            dplyr::distinct()
          , mapping = aes(x = .data[[label_pos]], label = .data[[label]])
          , vjust = -1, hjust = 0, size = label_size
        )+
        geom_text(
          data = my_data %>%
            dplyr::filter(pr_diff_lab_pos<0) %>% 
            dplyr::ungroup() %>% 
            dplyr::select(tidyselect::all_of(c(
              y
              , fill
              , label
              , label_pos
            ))) %>% 
            dplyr::distinct()
          , mapping = aes(x = .data[[label_pos]], label = .data[[label]])
          , vjust = -1, hjust = +1, size = label_size
        )
    )
  }
}
# plt_contrast(brms_contrast_temp, label = "pr_diff_lab_sm")

# calculate contrast vars
make_contrast_vars = function(my_data){
  my_data %>%
    dplyr::mutate(
      # get median_hdi
      median_hdi_est = tidybayes::median_hdci(value)$y
      , median_hdi_lower = tidybayes::median_hdci(value)$ymin
      , median_hdi_upper = tidybayes::median_hdci(value)$ymax
      # check probability of contrast
      , pr_gt_zero = mean(value > 0) %>% 
          scales::percent(accuracy = 1)
      , pr_lt_zero = mean(value < 0) %>% 
          scales::percent(accuracy = 1)
      # check probability that this direction is true
      , is_diff_dir = dplyr::case_when(
        median_hdi_est >= 0 ~ value > 0
        , median_hdi_est < 0 ~ value < 0
      )
      , pr_diff = mean(is_diff_dir)
      # make a label
      , pr_diff_lab = dplyr::case_when(
          median_hdi_est > 0 ~ paste0(
            "Pr("
            , stringr::word(contrast, 1, sep = fixed("-")) %>% 
              stringr::str_squish()
            , ">"
            , stringr::word(contrast, 2, sep = fixed("-")) %>% 
              stringr::str_squish()
            , ")="
            , pr_diff %>% scales::percent(accuracy = 1)
          )
          , median_hdi_est < 0 ~ paste0(
            "Pr("
            , stringr::word(contrast, 2, sep = fixed("-")) %>% 
              stringr::str_squish()
            , ">"
            , stringr::word(contrast, 1, sep = fixed("-")) %>% 
              stringr::str_squish()
            , ")="
            , pr_diff %>% scales::percent(accuracy = 1)
          )
        ) %>% 
        stringr::str_replace_all("OPENDRONEMAP", "ODM") %>% 
        stringr::str_replace_all("METASHAPE", "MtaShp") %>% 
        stringr::str_replace_all("PIX4D", "Pix4D")
      # make a SMALLER label
      , pr_diff_lab_sm = dplyr::case_when(
        median_hdi_est >= 0 ~ paste0(
          "Pr(>0)="
          , pr_diff %>% scales::percent(accuracy = 1)
        )
        , median_hdi_est < 0 ~ paste0(
          "Pr(<0)="
          , pr_diff %>% scales::percent(accuracy = 1)
        )
      )
      , pr_diff_lab_pos = dplyr::case_when(
        median_hdi_est > 0 ~ median_hdi_upper
        , median_hdi_est < 0 ~ median_hdi_lower
      ) * 1.075
      , sig_level = dplyr::case_when(
        pr_diff > 0.99 ~ 0
        , pr_diff > 0.95 ~ 1
        , pr_diff > 0.9 ~ 2
        , pr_diff > 0.8 ~ 3
        , T ~ 4
      ) %>% 
      factor(levels = c(0:4), labels = c(">99%","95%","90%","80%","<80%"), ordered = T)
    )
}
# brms_contrast_temp %>% dplyr::group_by(contrast) %>% make_contrast_vars() %>% dplyr::glimpse()

# bayesian p-value
get_mod_p_val = function(my_mod, ndraws = 1000){
  # get draws from the posterior predictive distribution
  brms::posterior_predict(my_mod, ndraws = ndraws) %>% 
    dplyr::as_tibble() %>% 
    dplyr::mutate(draw = dplyr::row_number()) %>% 
    tidyr::pivot_longer(cols = -draw, values_to = "y_rep") %>% 
    dplyr::mutate(y_n = readr::parse_number(name)) %>% 
    dplyr::select(-c(y_n)) %>% 
    dplyr::group_by(draw) %>% 
    # make test statistic
    dplyr::summarise(
      # test statistics y_sim
      mean_y_rep = mean(y_rep)
      , sd_y_rep = sd(y_rep)
    ) %>% 
    # # observed data test statistics
    dplyr::mutate(
    # test statistics y
      mean_y = mean(my_mod$data[,1])
      , sd_y = sd(my_mod$data[,1])
    ) %>% 
    # p-values
    dplyr::ungroup() %>% 
    dplyr::mutate(
      p_val_mean = as.numeric(mean_y_rep > mean_y)
      , p_val_sd = as.numeric(sd_y_rep > sd_y)
    ) %>% 
    # summarize p-vals
    dplyr::summarise(
      P.mean = mean(p_val_mean)
      , P.sd = mean(p_val_sd)
    )
}
```

```{r, warning=FALSE, message=FALSE, echo=FALSE, include=FALSE}
remove(list = ls()[grep("_temp",ls())])
gc()
```

## BA Percentage Error (bias)

### Summary Statistics

```{r, fig.height=8}
# summarize data
  dta_temp = ptcld_validation_data %>% 
    dplyr::group_by(software, depth_maps_generation_quality, depth_maps_generation_filtering_mode) %>%
    # collapse across study site
    dplyr::summarise(
      basal_area_pct_error = mean(basal_area_pct_error, na.rm = T)
      , n = dplyr::n()
    )
  # set limits for color scale
  lmt_basal_area_pct_error = ceiling(10*max(abs(range(dta_temp$basal_area_pct_error, na.rm = T))))/10
  # scales::show_col(scales::pal_dichromat("BluetoOrange.10")(10))
  # scales::show_col(scales::pal_div_gradient()(seq(0, 1, length.out = 7)))
  # plot it
  dta_temp %>% 
    ggplot(mapping = aes(
      y = depth_maps_generation_quality
      , x = depth_maps_generation_filtering_mode
      , fill = basal_area_pct_error
      , label = paste0(scales::percent(basal_area_pct_error,accuracy = 0.1), "\n(n=", n,")")
    )) +
    geom_tile(color = "white") +
    geom_text(color = "white", size = 3) +
    facet_grid(cols = vars(software)) + 
    scale_x_discrete(expand = c(0, 0)) +
    scale_y_discrete(expand = c(0, 0)) +
    scale_fill_stepsn(
      n.breaks = 7
      , colors = scales::pal_div_gradient()(seq(0, 1, length.out = 7))
      , limits = c(-lmt_basal_area_pct_error,lmt_basal_area_pct_error)
      , labels = scales::percent_format(accuracy = 1)
      , show.limits = T
    ) +
    labs(
      x = "filtering mode"
      , y = "quality"
      , fill = "Basal Area % Error"
      , title = "mean basal area percentage error and # of study sites"
      , subtitle = paste(
        "negative values = UAS basal area < field basal area"
        , " || "
        , "positive values = UAS basal area > field basal area"
      )
    ) +
    theme_light() + 
    theme(
      # legend.position = "none"
      axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)
      , panel.background = element_blank()
      , panel.grid = element_blank()
      # , plot.title = element_text(hjust = 0.5)
      # , plot.subtitle = element_text(hjust = 0.5)
      , strip.text = element_text(color = "black", face = "bold")
    )
```

let's check the distribution (of our dependent or $y$ variable)

```{r}
# distribution
ptcld_validation_data %>% 
  ggplot(mapping = aes(x = basal_area_pct_error)) + 
  geom_hline(yintercept = 0, color = "gray77") +
  geom_vline(xintercept = 0, color = "gray77") +
  # geom_vline(xintercept = c(0,1)) +
  geom_density(fill = "lightblue", alpha = 0.7, color = NA) +
  labs(y="",x="Basal Area % Error") +
  scale_y_continuous(breaks = c(0)) +
  scale_x_continuous(breaks = scales::extended_breaks(10), labels = scales::percent_format(accuracy = 1)) +
  theme_light() +
  theme(panel.grid = element_blank())
```

and the summary statistics

```{r}
ptcld_validation_data %>% 
  dplyr::ungroup() %>% 
  dplyr::select(basal_area_pct_error) %>% 
  dplyr::summarise(
    dplyr::across(
      dplyr::everything()
      , .fns = list(
        mean = ~ mean(.x,na.rm=T), median = ~ median(.x,na.rm=T), sd = ~ sd(.x,na.rm=T)
        , min = ~ min(.x,na.rm=T), max = ~ max(.x,na.rm=T)
        , q25 = ~ quantile(.x, 0.25, na.rm = T)
        , q75 = ~ quantile(.x, 0.75, na.rm = T)
      )
      , .names = "{.fn}"
    )
  ) %>% 
  tidyr::pivot_longer(everything()) %>% 
  kableExtra::kbl(caption = "summary: `basal_area_pct_error`", digits = 3, col.names = NULL) %>% 
  kableExtra::kable_styling()
```

### Model: BA percentage error

```{r}
# from Kurz: 
gamma_a_b_from_omega_sigma = function(mode, sd) {
  if (mode <= 0) stop("mode must be > 0")
  if (sd   <= 0) stop("sd must be > 0")
  rate = (mode + sqrt(mode^2 + 4 * sd^2)) / (2 * sd^2)
  shape = 1 + mode * rate
  return(list(shape = shape, rate = rate))
}

mean_y_temp = mean(ptcld_validation_data$basal_area_pct_error, na.rm = T)
sd_y_temp   = sd(ptcld_validation_data$basal_area_pct_error, na.rm = T)

omega_temp = sd_y_temp / 2
sigma_temp = 2 * sd_y_temp

s_r_temp = gamma_a_b_from_omega_sigma(mode = omega_temp, sd = sigma_temp)

stanvars_temp = 
  brms::stanvar(mean_y_temp,    name = "mean_y") + 
  brms::stanvar(sd_y_temp,      name = "sd_y") +
  brms::stanvar(s_r_temp$shape, name = "alpha") +
  brms::stanvar(s_r_temp$rate,  name = "beta")
```

#### Prior distributions

```{r}
#### setting priors
# required libraries: tidyverse, tidybayes, brms, palettetown, latex2exp
priors_temp <- c(
    brms::prior(normal(mean_y_temp, sd_y_temp * 5), class = "Intercept")
    , brms::prior(gamma(s_r_temp$shape, s_r_temp$rate), class = "sd")
    , brms::prior(cauchy(0, sd_y_temp), class = "sigma")
  )
# plot
plt_prior11 =
priors_temp %>% 
  tidybayes::parse_dist() %>% 
  tidybayes::marginalize_lkjcorr(K = 2) %>% 
  tidyr::separate(
    .args
    , sep = ","
    , into = c("a","b")
    , remove = F
  ) %>% 
  dplyr::mutate(
    distrib = dplyr::case_when(
        !is.na(b) ~ paste0(
          class, " ~ "
          , .dist
          , "("
          , a %>% readr::parse_number() %>% round(2)
          , ","
          , b %>% readr::parse_number() %>% round(2)
          , ")"
        )
      , T ~ paste0(
          class, " ~ "
          , .dist
          , "("
          , a %>% readr::parse_number() %>% round(2)
          , ")"
        )
    )
  ) %>% 
  ggplot(., aes(dist = .dist, args = .args)) +
  facet_grid(cols = vars(distrib), scales = "free") +
  ggdist::stat_halfeye(
    aes(fill = prior),
    n = 10e2,
    show.legend = F
    , fill = "slategray"
  ) +
  coord_flip() + 
  theme_light() +
  theme(
    strip.text = element_text(face = "bold", color = "black"),
    axis.text.y = element_blank(),
    axis.ticks = element_blank()
    , axis.text = element_text(size = 6)
  )+
  labs(
    x = ""
    , title = "Priors: Basal Area Percentage Error"
    , y = ""
  ) 
plt_prior11
```

#### Fit the model

Now fit the model.

```{r}
brms_ba_pe_mod = brms::brm(
  formula = basal_area_pct_error ~ 
    # baseline
    1 + 
    # main effects
    (1 | depth_maps_generation_quality) +
    (1 | depth_maps_generation_filtering_mode) + 
    (1 | software) +
    (1 | study_site) + # only fitting main effects of site and not interactions
    # two-way interactions
    (1 | depth_maps_generation_quality:depth_maps_generation_filtering_mode) +
    (1 | depth_maps_generation_quality:software) +
    (1 | depth_maps_generation_filtering_mode:software) +
    # three-way interactions
    (1 | depth_maps_generation_quality:depth_maps_generation_filtering_mode:software)
  , data = ptcld_validation_data
  , family = brms::brmsfamily(family = "gaussian")
  , iter = 20000, warmup = 10000, chains = 4
  , control = list(adapt_delta = 0.999, max_treedepth = 13)
  , cores = round(parallel::detectCores()/2)
  , prior = c(
    brms::prior(normal(mean_y, sd_y * 5), class = "Intercept")
    , brms::prior(gamma(alpha, beta), class = "sd")
    , brms::prior(cauchy(0, sd_y), class = "sigma")
  )
  , stanvars = stanvars_temp
  , file = paste0(rootdir, "/fits/brms_ba_pe_mod")
)
```

```{r, warning=FALSE, message=FALSE, echo=FALSE, include=FALSE}
remove(list = ls()[grep("_temp",ls())])
gc()
```

#### Quality:Filtering - interaction

```{r}
draws_temp = 
  ptcld_validation_data %>% 
    dplyr::distinct(depth_maps_generation_quality, depth_maps_generation_filtering_mode) %>% 
    tidybayes::add_epred_draws(
      brms_ba_pe_mod, allow_new_levels = T
      # this part is crucial
      , re_formula = ~ (1 | depth_maps_generation_quality) +
        (1 | depth_maps_generation_filtering_mode) + 
        (1 | depth_maps_generation_quality:depth_maps_generation_filtering_mode)
    ) %>% 
    dplyr::rename(value = .epred) %>% 
    dplyr::mutate(med = tidybayes::median_hdci(value)$y)
# plot
  draws_temp %>% 
    dplyr::mutate(depth_maps_generation_quality = depth_maps_generation_quality %>% forcats::fct_rev()) %>% 
  # plot
  ggplot(
    mapping = aes(
      y = value, x = depth_maps_generation_filtering_mode
      , fill = med
    )
  ) +
    geom_hline(yintercept = 0, color = "gray33") +
    tidybayes::stat_eye(
      point_interval = median_hdi, .width = 0.95
      , slab_alpha = 0.98
      , interval_color = "black", linewidth = 1
      , point_color = "black", point_fill = "black", point_size = 1
    ) +
    scale_fill_stepsn(
      n.breaks = 7
      , colors = scales::pal_div_gradient()(seq(0, 1, length.out = 7))
      , limits = c(-lmt_basal_area_pct_error*.5,lmt_basal_area_pct_error*.5)
      , labels = scales::percent_format(accuracy = 1)
      , show.limits = T
    ) +
    facet_grid(cols = vars(depth_maps_generation_quality)) +
    scale_y_continuous(
      labels = scales::percent_format(accuracy = 1)
      , limits = c(-lmt_basal_area_pct_error*1.2,lmt_basal_area_pct_error*1.2)
    ) +
    labs(
      x = "filtering mode", y = "Basal Area % Error"
      , subtitle = "posterior predictive distribution of basal area percentage error with 95% HDI\nby dense cloud quality"
    ) +
    theme_light() +
    theme(
      legend.position = "none"
      , legend.direction  = "horizontal"
      , axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)
      , strip.text = element_text(color = "black", face = "bold")
    ) 
```

and a table of these 95% HDI values

```{r}
table_temp =
  draws_temp %>% 
    tidybayes::median_hdi(value) %>% 
    dplyr::select(-c(.point,.interval, .width,.row)) %>% 
    dplyr::arrange(depth_maps_generation_quality,depth_maps_generation_filtering_mode) %>% 
    dplyr::mutate(dplyr::across(.cols = is.numeric, .fns = ~ scales::percent(.x,accuracy = 0.1)))

table_temp %>% 
  dplyr::select(-c(depth_maps_generation_quality)) %>% 
  kableExtra::kbl(
    digits = 2
    , caption = "Basal Area % Error<br>95% HDI of the posterior predictive distribution"
    , col.names = c(
      "filtering mode"
      , "Basal Area % Error<br>median"
      , "HDI low", "HDI high"
    )
    , escape = F
  ) %>% 
  kableExtra::kable_styling() %>% 
  kableExtra::pack_rows(index = table(forcats::fct_inorder(table_temp$depth_maps_generation_quality))) %>% 
  kableExtra::scroll_box(height = "8in")
```

#### Software:Quality - interaction

```{r}
draws_temp = 
  ptcld_validation_data %>% 
    dplyr::distinct(depth_maps_generation_quality, software) %>% 
    tidybayes::add_epred_draws(
      brms_ba_pe_mod, allow_new_levels = T
      # this part is crucial
      , re_formula = ~ (1 | depth_maps_generation_quality) +
        (1 | software) + 
        (1 | depth_maps_generation_quality:software)
    ) %>% 
    dplyr::rename(value = .epred) %>% 
    dplyr::mutate(med = tidybayes::median_hdci(value)$y)
# plot
  draws_temp %>%
    dplyr::mutate(depth_maps_generation_quality = depth_maps_generation_quality %>% forcats::fct_rev()) %>% 
  # plot
  ggplot(
    mapping = aes(
      y = value, x = software
      , fill = med
    )
  ) +
    geom_hline(yintercept = 0, color = "gray33") +
    tidybayes::stat_eye(
      point_interval = median_hdi, .width = .95
      , slab_alpha = 0.98
      , interval_color = "black", linewidth = 1
      , point_color = "black", point_fill = "black", point_size = 1
    ) +
    scale_fill_stepsn(
      n.breaks = 7
      , colors = scales::pal_div_gradient()(seq(0, 1, length.out = 7))
      , limits = c(-lmt_basal_area_pct_error*.5,lmt_basal_area_pct_error*.5)
      , labels = scales::percent_format(accuracy = 1)
      , show.limits = T
    ) +
    facet_grid(cols = vars(depth_maps_generation_quality)) +
    scale_y_continuous(
      labels = scales::percent_format(accuracy = 1)
      , limits = c(-lmt_basal_area_pct_error*1.2,lmt_basal_area_pct_error*1.2)
    ) +
    labs(
      x = "software", y = "Basal Area % Error"
      , subtitle = "posterior predictive distribution of basal area percentage error with 95% HDI\nby dense cloud quality"
    ) +
    theme_light() +
    theme(
      legend.position = "none"
      , legend.direction  = "horizontal"
      , axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)
      , strip.text = element_text(color = "black", face = "bold")
    ) 
```

and a table of these 95% HDI values

```{r}
table_temp = 
  draws_temp %>% 
  tidybayes::median_hdi(value) %>% 
  # remove out-of-sample obs
    dplyr::inner_join(
      ptcld_validation_data %>% dplyr::distinct(depth_maps_generation_quality, software)
      , by = dplyr::join_by(depth_maps_generation_quality, software)
    ) %>% 
  dplyr::select(-c(.point,.interval, .width,.row)) %>%
  dplyr::arrange(software,depth_maps_generation_quality) %>% 
  dplyr::mutate(dplyr::across(.cols = is.numeric, .fns = ~ scales::percent(.x,accuracy = 0.1)))

table_temp %>% 
  dplyr::select(-c(software)) %>% 
  kableExtra::kbl(
    digits = 2
    , caption = "Basal Area % Error<br>95% HDI of the posterior predictive distribution"
    , col.names = c(
      "quality"
      , "Basal Area % Error<br>median"
      , "HDI low", "HDI high"
    )
    , escape = F
  ) %>% 
  kableExtra::kable_styling() %>% 
  kableExtra::pack_rows(index = table(forcats::fct_inorder(table_temp$software))) %>% 
  kableExtra::scroll_box(height = "8in")
```

#### Software:Filtering - interaction

```{r}
draws_temp = 
  ptcld_validation_data %>% 
    dplyr::distinct(depth_maps_generation_filtering_mode, software) %>% 
    tidybayes::add_epred_draws(
      brms_ba_pe_mod, allow_new_levels = T
      # this part is crucial
      , re_formula = ~ (1 | depth_maps_generation_filtering_mode) +
        (1 | software) + 
        (1 | depth_maps_generation_filtering_mode:software)
    ) %>% 
    dplyr::rename(value = .epred) %>% 
    dplyr::mutate(med = tidybayes::median_hdci(value)$y)
# plot
  draws_temp %>%
  # plot
  ggplot(
    mapping = aes(
      y = value, x = software
      , fill = med
    )
  ) +
    geom_hline(yintercept = 0, color = "gray33") +
    tidybayes::stat_eye(
      point_interval = median_hdi, .width = .95
      , slab_alpha = 0.98
      , interval_color = "black", linewidth = 1
      , point_color = "black", point_fill = "black", point_size = 1
    ) +
    scale_fill_stepsn(
      n.breaks = 7
      , colors = scales::pal_div_gradient()(seq(0, 1, length.out = 7))
      , limits = c(-lmt_basal_area_pct_error*.5,lmt_basal_area_pct_error*.5)
      , labels = scales::percent_format(accuracy = 1)
      , show.limits = T
    ) +
    facet_grid(cols = vars(depth_maps_generation_filtering_mode)) +
    scale_y_continuous(
      labels = scales::percent_format(accuracy = 1)
      , limits = c(-lmt_basal_area_pct_error*1.2,lmt_basal_area_pct_error*1.2)
    ) +
    labs(
      x = "software", y = "Basal Area % Error"
      , subtitle = "posterior predictive distribution of basal area percentage error with 95% HDI\nby filtering mode"
    ) +
    theme_light() +
    theme(
      legend.position = "none"
      , legend.direction  = "horizontal"
      , axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)
      , strip.text = element_text(color = "black", face = "bold")
    ) 
```

and a table of these 95% HDI values

```{r}
table_temp = 
  draws_temp %>% 
    tidybayes::median_hdi(value) %>% 
    dplyr::select(-c(.point,.interval, .width,.row)) %>% 
    dplyr::arrange(software,depth_maps_generation_filtering_mode) %>% 
    dplyr::mutate(dplyr::across(.cols = is.numeric, .fns = ~ scales::percent(.x,accuracy = 0.1)))

table_temp %>% 
  dplyr::select(-c(software)) %>% 
  kableExtra::kbl(
    digits = 2
    , caption = "Basal Area % Error<br>95% HDI of the posterior predictive distribution"
    , col.names = c(
      "filtering mode"
      , "Basal Area % Error<br>median"
      , "HDI low", "HDI high"
    )
    , escape = F
  ) %>% 
  kableExtra::kable_styling() %>% 
  kableExtra::pack_rows(index = table(forcats::fct_inorder(table_temp$software))) %>% 
  kableExtra::scroll_box(height = "8in")
```

#### Software:Quality:Filtering - interaction

```{r}
# get draws
fltr_sftwr_draws_temp =
  tidyr::crossing(
    depth_maps_generation_quality = unique(ptcld_validation_data$depth_maps_generation_quality)
    , depth_maps_generation_filtering_mode = unique(ptcld_validation_data$depth_maps_generation_filtering_mode)
    , software = unique(ptcld_validation_data$software)
  ) %>% 
  tidybayes::add_epred_draws(
    brms_ba_pe_mod, allow_new_levels = T
    # this part is crucial
    , re_formula = ~ (1 | depth_maps_generation_quality) + # main effects
    (1 | depth_maps_generation_quality) +
    (1 | depth_maps_generation_filtering_mode) + 
    (1 | software) +
    # two-way interactions
    (1 | depth_maps_generation_quality:depth_maps_generation_filtering_mode) +
    (1 | depth_maps_generation_quality:software) +
    (1 | depth_maps_generation_filtering_mode:software) +
    # three-way interactions
    (1 | depth_maps_generation_quality:depth_maps_generation_filtering_mode:software)
  ) %>% 
  dplyr::rename(value = .epred) %>% 
  dplyr::mutate(med = tidybayes::median_hdci(value)$y)

# plot
qlty_fltr_sftwr_ba_pe = 
  fltr_sftwr_draws_temp %>% 
    dplyr::inner_join(
      ptcld_validation_data %>% dplyr::distinct(software, depth_maps_generation_quality, depth_maps_generation_filtering_mode)
      , by = dplyr::join_by(software, depth_maps_generation_quality, depth_maps_generation_filtering_mode)
    ) %>% 
    dplyr::mutate(depth_maps_generation_quality = depth_maps_generation_quality %>% forcats::fct_rev()) %>% 
    ggplot(
      mapping = aes(
        y = value
        , x = depth_maps_generation_filtering_mode
        , fill = med
      )
    ) +
    geom_hline(yintercept = 0, color = "gray33") +
    tidybayes::stat_eye(
      point_interval = median_hdi, .width = .95
      , slab_alpha = 0.98
      , interval_color = "black", linewidth = 1
      , point_color = "black", point_fill = "black", point_size = 1
    ) +
    scale_fill_stepsn(
      n.breaks = 7
      , colors = scales::pal_div_gradient()(seq(0, 1, length.out = 7))
      , limits = c(-lmt_basal_area_pct_error*.5,lmt_basal_area_pct_error*.5)
      , labels = scales::percent_format(accuracy = 1)
      , show.limits = T
    ) +
    facet_grid(
      rows = vars(software)
      , cols = vars(depth_maps_generation_quality)
      # , switch = "y"
    ) +
    scale_y_continuous(
      labels = scales::percent_format(accuracy = 1)
      , limits = c(-lmt_basal_area_pct_error*1.5,lmt_basal_area_pct_error*1.2)
    ) +
    labs(
      x = "filtering mode", y = "Basal Area % Error"
      , subtitle = "posterior predictive distribution of basal area percentage error with 95% HDI\nby dense cloud quality and software"
      # , caption = form_temp
    ) +
    theme_light() +
    theme(
      legend.position = "none"
      , legend.direction  = "horizontal"
      , axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)
      , strip.text = element_text(color = "black", face = "bold")
      , panel.grid = element_blank()
      # , strip.placement = "outside"
    ) +
    guides(
      fill = guide_legend(override.aes = list(shape = NA, size = 6, alpha = 0.9, lwd = NA))
    )
# print it
qlty_fltr_sftwr_ba_pe
ggplot2::ggsave("../data/qlty_fltr_sftwr_ba_pe.png", height = 7, width = 10.5)
```

and a table of these 95% HDI values

```{r}
table_temp =
  fltr_sftwr_draws_temp %>% 
  tidybayes::median_hdi(value) %>%
  dplyr::inner_join(
    ptcld_validation_data %>% dplyr::distinct(software, depth_maps_generation_quality, depth_maps_generation_filtering_mode)
    , by = dplyr::join_by(software, depth_maps_generation_quality, depth_maps_generation_filtering_mode)
  ) %>% 
  dplyr::mutate(depth_maps_generation_quality = depth_maps_generation_quality %>% forcats::fct_rev()) %>%
  dplyr::select(c(
    software, depth_maps_generation_quality, depth_maps_generation_filtering_mode
    , value, .lower, .upper
  )) %>% 
  dplyr::ungroup() %>% 
  dplyr::arrange(software, depth_maps_generation_quality, depth_maps_generation_filtering_mode) %>% 
  dplyr::mutate(dplyr::across(.cols = is.numeric, .fns = ~ scales::percent(.x,accuracy = 0.1)))

table_temp %>% 
  # dplyr::select(-c(software)) %>% 
  kableExtra::kbl(
    digits = 2
    , caption = "Basal Area % Error<br>95% HDI of the posterior predictive distribution"
    , col.names = c(
      "software", "quality", "filtering mode"
      , "Basal Area % Error<br>median"
      , "HDI low", "HDI high"
    )
    , escape = F
  ) %>% 
  kableExtra::kable_styling() %>% 
  # kableExtra::pack_rows(index = table(forcats::fct_inorder(table_temp$software))) %>% 
  kableExtra::collapse_rows(columns = 1:2, valign = "top") %>%
  kableExtra::scroll_box(height = "8in")
```

## BA Absolute Percentage Error (precision)

### Summary Statistics

```{r, fig.height=8}
  # summarize data
  dta_temp = ptcld_validation_data %>% 
    dplyr::group_by(software, depth_maps_generation_quality, depth_maps_generation_filtering_mode) %>%
    # collapse across study site
    dplyr::summarise(
      basal_area_abs_pct_error = mean(basal_area_abs_pct_error, na.rm = T)
      , n = dplyr::n()
    )
  # set limits for color scale
  lmt_basal_area_abs_pct_error = ceiling(1.02*10*max(abs(range(dta_temp$basal_area_abs_pct_error, na.rm = T))))/10
  # scales::show_col(viridis::mako(n = 10, begin = 0.2, end = 0.9, direction = -1))
  # scales::show_col(scales::pal_div_gradient()(seq(0, 1, length.out = 7)))
  # plot it
  dta_temp %>% 
    ggplot(mapping = aes(
      y = depth_maps_generation_quality
      , x = depth_maps_generation_filtering_mode
      , fill = basal_area_abs_pct_error
      , label = paste0(scales::percent(basal_area_abs_pct_error,accuracy = 0.1), "\n(n=", n,")")
    )) +
    geom_tile(color = "white") +
    geom_text(color = "white", size = 3) +
    facet_grid(cols = vars(software)) + 
    scale_x_discrete(expand = c(0, 0)) +
    scale_y_discrete(expand = c(0, 0)) +
    scale_fill_stepsn(
      n.breaks = 5
      , colors = viridis::mako(n = 5, begin = 0.2, end = 0.9, direction = -1)
      , limits = c(0,lmt_basal_area_abs_pct_error)
      , labels = scales::percent_format(accuracy = 1)
      , show.limits = T
    ) +
    labs(
      x = "filtering mode"
      , y = "quality"
      , fill = "Basal Area Abs. % Error"
      , title = "mean basal area absolute percentage error and # of study sites"
    ) +
    theme_light() + 
    theme(
      legend.position = "none"
      , axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)
      , panel.background = element_blank()
      , panel.grid = element_blank()
      # , plot.title = element_text(hjust = 0.5)
      # , plot.subtitle = element_text(hjust = 0.5)
      , strip.text = element_text(color = "black", face = "bold")
    )
```

let's check the distribution (of our dependent or $y$ variable)

```{r}
# distribution
ptcld_validation_data %>% 
  ggplot(mapping = aes(x = basal_area_abs_pct_error)) + 
  geom_hline(yintercept = 0, color = "gray77") +
  geom_vline(xintercept = 0, color = "gray77") +
  # geom_vline(xintercept = c(0,1)) +
  geom_density(fill = "lightblue", alpha = 0.7, color = NA) +
  labs(y="",x="Basal Area Abs. % Error") +
  scale_y_continuous(breaks = c(0)) +
  scale_x_continuous(breaks = scales::extended_breaks(10), labels = scales::percent_format(accuracy = 1)) +
  theme_light() +
  theme(panel.grid = element_blank())
```

and the summary statistics

```{r}
ptcld_validation_data %>% 
  dplyr::ungroup() %>% 
  dplyr::select(basal_area_abs_pct_error) %>% 
  dplyr::summarise(
    dplyr::across(
      dplyr::everything()
      , .fns = list(
        mean = ~ mean(.x,na.rm=T), median = ~ median(.x,na.rm=T), sd = ~ sd(.x,na.rm=T)
        , min = ~ min(.x,na.rm=T), max = ~ max(.x,na.rm=T)
        , q25 = ~ quantile(.x, 0.25, na.rm = T)
        , q75 = ~ quantile(.x, 0.75, na.rm = T)
      )
      , .names = "{.fn}"
    )
  ) %>% 
  tidyr::pivot_longer(everything()) %>% 
  kableExtra::kbl(caption = "summary: `basal_area_abs_pct_error`", digits = 3, col.names = NULL) %>% 
  kableExtra::kable_styling()
```

```{r, include=FALSE, eval=FALSE}
ptcld_validation_data %>% 
  dplyr::select(
    depth_maps_generation_quality, depth_maps_generation_filtering_mode, study_site
    , uas_basal_area_m2, field_basal_area_m2
    , basal_area_pct_error, basal_area_abs_pct_error
  ) %>% 
  dplyr::arrange(desc(basal_area_abs_pct_error)) %>% 
  View()
```

### Model: BA Absolute percentage error

We'll model the BA APE using the gamma likelihood to accurately represent the dependent variable which is continuous and strictly positive (i.e. it is impossible to have a negative APE). The gamma distribution is a great alternative that accounts for data with a zero lower limit and any right skew.

We borrow here from the excellent series on causal inference by [A. Solomon Kurz](https://solomonkurz.netlify.app/blog/2023-05-14-causal-inference-with-gamma-regression-or-the-problem-is-with-the-link-function-not-the-likelihood/)

#### Prior distributions

First, let's set the priors

```{r}
# desired priors
m_temp <- mean(ptcld_validation_data$basal_area_abs_pct_error)  # desired mean
s_temp <- sd(ptcld_validation_data$basal_area_abs_pct_error)     # desired SD
# use the equations to get the lognormal parameter values
mu_temp    <- log(m_temp / sqrt((s_temp*5)^2 / m_temp^2 + 1))
sigma_temp <- sqrt(log((s_temp*5)^2 / m_temp^2 + 1))

# what are the lognormal parameter values?
# mu_temp
# sigma_temp
# exp(mu_temp)

stanvars_temp = 
  brms::stanvar(mu_temp,    name = "mu_temp") + 
  brms::stanvar(sigma_temp,      name = "sigma_temp")
#### setting priors
# required libraries: tidyverse, tidybayes, brms, palettetown, latex2exp
brms_ba_ape_mod_priors_temp <- c(
    brms::prior(normal(mu_temp, sigma_temp), class = "Intercept")
    , brms::prior(student_t(3, 0, 2.5), class = "sd")
    , brms::prior(gamma(0.1, 0.1), class = shape)
    # , brms::prior(exponential(0.5), class = shape)
    
  )
```

plot the priors

```{r}
# plot
plt_prior12 =
brms_ba_ape_mod_priors_temp %>% 
  tidybayes::parse_dist() %>% 
  tidybayes::marginalize_lkjcorr(K = 2) %>% 
  tidyr::separate(
    .args
    , sep = ","
    , into = c("a","b")
    , remove = F
  ) %>% 
  dplyr::mutate(
    distrib = dplyr::case_when(
        !is.na(b) ~ paste0(
          class, " ~ "
          , .dist
          , "("
          , a %>% readr::parse_number() %>% round(2)
          , ","
          , b %>% readr::parse_number() %>% round(2)
          , ")"
        )
      , T ~ paste0(
          class, " ~ "
          , .dist
          , "("
          , a %>% readr::parse_number() %>% round(2)
          , ")"
        )
    )
  ) %>% 
  ggplot(., aes(dist = .dist, args = .args)) +
  facet_grid(cols = vars(distrib), scales = "free") +
  ggdist::stat_halfeye(
    aes(fill = prior),
    n = 10e2,
    show.legend = F
    , fill = "slategray"
  ) +
  coord_flip() + 
  theme_light() +
  theme(
    strip.text = element_text(face = "bold", color = "black"),
    axis.text.y = element_blank(),
    axis.ticks = element_blank()
    , axis.text = element_text(size = 6)
  )+
  labs(
    x = ""
    , title = "Priors: Basal Area Absolute Percentage Error"
    , y = ""
  ) 
plt_prior12
```

#### Fit the model

Now fit the model.

```{r}
#### Fit the model
brms_ba_ape_mod = brms::brm(
  formula = basal_area_abs_pct_error ~ 
    # baseline
    1 + 
    # main effects
    (1 | depth_maps_generation_quality) +
    (1 | depth_maps_generation_filtering_mode) + 
    (1 | software) +
    (1 | study_site) + # only fitting main effects of site and not interactions
    # two-way interactions
    (1 | depth_maps_generation_quality:depth_maps_generation_filtering_mode) +
    (1 | depth_maps_generation_quality:software) +
    (1 | depth_maps_generation_filtering_mode:software) +
    # three-way interactions
    (1 | depth_maps_generation_quality:depth_maps_generation_filtering_mode:software)
  , data = ptcld_validation_data
  # , family = brms::brmsfamily("Gamma", link = "log")
  , family = brms::brmsfamily("weibull", link = "log")
  # priors
  , prior = brms_ba_ape_mod_priors_temp
  , stanvars = stanvars_temp
  # mcmc
  , iter = 20000, warmup = 10000, chains = 4
  , control = list(adapt_delta = 0.999, max_treedepth = 13)
  , cores = round(parallel::detectCores()/2)
  , file = paste0(rootdir, "/fits/brms_ba_ape_mod")
)
```

```{r, warning=FALSE, message=FALSE, echo=FALSE, include=FALSE}
remove(list = ls()[grep("_temp",ls())])
gc()
```

#### Quality:Filtering - interaction

```{r}
draws_temp = 
  ptcld_validation_data %>% 
    dplyr::distinct(depth_maps_generation_quality, depth_maps_generation_filtering_mode) %>% 
    tidybayes::add_epred_draws(
      brms_ba_ape_mod, allow_new_levels = T
      # this part is crucial
      , re_formula = ~ (1 | depth_maps_generation_quality) +
        (1 | depth_maps_generation_filtering_mode) + 
        (1 | depth_maps_generation_quality:depth_maps_generation_filtering_mode)
    ) %>% 
    dplyr::rename(value = .epred) %>% 
    dplyr::mutate(med = tidybayes::median_hdci(value)$y)
# plot
  draws_temp %>% 
    dplyr::mutate(depth_maps_generation_quality = depth_maps_generation_quality %>% forcats::fct_rev()) %>% 
  # plot
  ggplot(
    mapping = aes(
      y = value, x = depth_maps_generation_filtering_mode
      , fill = med
    )
  ) +
    geom_hline(yintercept = 0, color = "gray33") +
    tidybayes::stat_eye(
      point_interval = median_hdi, .width = .95
      , slab_alpha = 0.98
      , interval_color = "black", linewidth = 1
      , point_color = "black", point_fill = "black", point_size = 1
    ) +
    scale_fill_stepsn(
      n.breaks = 5
      , colors = viridis::mako(n = 5, begin = 0.2, end = 0.9, direction = -1)
      , limits = c(0,lmt_basal_area_abs_pct_error*.6)
      , labels = scales::percent_format(accuracy = 0.1)
      , show.limits = T
    ) +
    facet_grid(cols = vars(depth_maps_generation_quality)) +
    scale_y_continuous(
      limits = c(-0.005,lmt_basal_area_abs_pct_error*1.1)
      , labels = scales::percent_format(accuracy = 1)
    ) +
    labs(
      x = "filtering mode", y = "BA Abs. % Error"
      , subtitle = "posterior predictive distribution of BA Abs. % Error with 95% HDI\nby dense cloud quality"
    ) +
    theme_light() +
    theme(
      legend.position = "none"
      , legend.direction  = "horizontal"
      , axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)
      , strip.text = element_text(color = "black", face = "bold")
    ) 
```

and a table of these 95% HDI values

```{r}
table_temp =
  draws_temp %>% 
    tidybayes::median_hdi(value) %>% 
    dplyr::select(-c(.point,.interval, .width,.row)) %>% 
    dplyr::arrange(depth_maps_generation_quality,depth_maps_generation_filtering_mode) %>% 
    dplyr::mutate(dplyr::across(.cols = is.numeric, .fns = ~ scales::percent(.x,accuracy = 0.1)))

table_temp %>% 
  dplyr::select(-c(depth_maps_generation_quality)) %>% 
  kableExtra::kbl(
    digits = 2
    , caption = "BA Abs. % Error<br>95% HDI of the posterior predictive distribution"
    , col.names = c(
      "filtering mode"
      , "BA Abs. % Error<br>median"
      , "HDI low", "HDI high"
    )
    , escape = F
  ) %>% 
  kableExtra::kable_styling() %>% 
  kableExtra::pack_rows(index = table(forcats::fct_inorder(table_temp$depth_maps_generation_quality))) %>% 
  kableExtra::scroll_box(height = "8in")
```

we can also make pairwise comparisons

```{r}
# first we need to define the contrasts to make
contrast_list = 
  tidyr::crossing(
    x1 = unique(ptcld_validation_data$depth_maps_generation_quality)
    , x2 = unique(ptcld_validation_data$depth_maps_generation_quality)
  ) %>% 
  dplyr::mutate(
    dplyr::across(
      dplyr::everything()
      , .fns = function(x){factor(
        x, ordered = T
        , levels = levels(ptcld_validation_data$depth_maps_generation_quality)
      )}
    )
  ) %>% 
  dplyr::filter(x1<x2) %>% 
  dplyr::arrange(x1,x2) %>% 
  dplyr::mutate(dplyr::across(dplyr::everything(), as.character)) %>% 
  purrr::transpose()
# make the contrasts using compare_levels
brms_contrast_temp = draws_temp %>% 
    tidybayes::compare_levels(
      value
      , by = depth_maps_generation_quality
      , comparison = 
        contrast_list
        # tidybayes::emmeans_comparison("revpairwise") 
        #"pairwise"
    ) %>% 
    dplyr::rename(contrast = depth_maps_generation_quality)

# separate contrast
brms_contrast_temp = brms_contrast_temp %>% 
  dplyr::ungroup() %>% 
  tidyr::separate_wider_delim(
    cols = contrast
    , delim = " - "
    , names = paste0(
        "sorter"
        , 1:(max(stringr::str_count(brms_contrast_temp$contrast, "-"))+1)
      )
    , too_few = "align_start"
    , cols_remove = F
  ) %>% 
  dplyr::filter(sorter1!=sorter2) %>% 
  dplyr::mutate(
    dplyr::across(
      tidyselect::starts_with("sorter")
      , .fns = function(x){factor(
        x, ordered = T
        , levels = levels(ptcld_validation_data$depth_maps_generation_quality)
      )}
    )
    , contrast = contrast %>% 
      forcats::fct_reorder(
        paste0(as.numeric(sorter1), as.numeric(sorter2)) %>% 
        as.numeric()
      )
    , depth_maps_generation_filtering_mode = depth_maps_generation_filtering_mode %>% 
      factor(
        levels = levels(ptcld_validation_data$depth_maps_generation_filtering_mode)
        , ordered = T
      )
  ) %>% 
  # median_hdi summary for coloring 
  dplyr::group_by(contrast,depth_maps_generation_filtering_mode) %>% 
  make_contrast_vars()
```

plot it

```{r}
plt_contrast(
  brms_contrast_temp
  # , caption_text = form_temp
  , y_axis_title = "quality"
  , facet = "depth_maps_generation_filtering_mode"
  , label_size = 1.55
) +
  scale_x_continuous(
    labels = scales::percent_format(accuracy = 1)
    , limits = c(-1.2,0.3)
    , breaks = seq(-1,1,0.5)
  ) +
  labs(
    subtitle = "posterior predictive distribution of group constrasts with 95% & 50% HDI\nby filtering mode"
    , x = "constrast BA Abs. % Error"
  ) +
  theme(
    axis.text.x = element_text(size = 7)
  )
ggplot2::ggsave(
  "../data/qlty_fltr_comp_ba_ape.png"
  , plot = ggplot2::last_plot() + labs(subtitle = "")
  , height = 7, width = 10.5
)
```

and summarize these contrasts

```{r}
brms_contrast_temp %>%
  dplyr::group_by(contrast, depth_maps_generation_filtering_mode, pr_lt_zero) %>% 
  tidybayes::median_hdi(value) %>% 
  dplyr::arrange(contrast, depth_maps_generation_filtering_mode) %>% 
  dplyr::select(contrast, depth_maps_generation_filtering_mode, value, .lower, .upper, pr_lt_zero) %>% 
  dplyr::mutate(dplyr::across(.cols = is.numeric, .fns = ~ scales::percent(.x,accuracy = 0.1))) %>% 
kableExtra::kbl(
    digits = 2
    , caption = "BA Abs. % Error<br>95% HDI of the posterior predictive distribution of group contrasts"
    , col.names = c(
      "quality contrast"
      , "filtering mode"
      , "median difference<br>BA Abs. % Error"
      , "HDI low", "HDI high"
      , "Pr(diff<0)"
    )
    , escape = F
  ) %>% 
  kableExtra::kable_styling() %>% 
  kableExtra::scroll_box(height = "8in")
```

#### Software:Quality - interaction

```{r, warning=FALSE, message=FALSE, echo=FALSE, include=FALSE}
remove(list = ls()[grep("_temp",ls())])
gc()
```

```{r}
draws_temp = 
  tidyr::crossing(
    depth_maps_generation_quality = unique(ptcld_validation_data$depth_maps_generation_quality)
    , software = unique(ptcld_validation_data$software)
  ) %>% 
    tidybayes::add_epred_draws(
      brms_ba_ape_mod, allow_new_levels = T
      # this part is crucial
      , re_formula = ~ (1 | depth_maps_generation_quality) +
        (1 | software) + 
        (1 | depth_maps_generation_quality:software)
    ) %>% 
    dplyr::rename(value = .epred) %>% 
    dplyr::mutate(med = tidybayes::median_hdci(value)$y)
# plot
  draws_temp %>%
    # remove out-of-sample obs
    dplyr::inner_join(
      ptcld_validation_data %>% dplyr::distinct(depth_maps_generation_quality, software)
      , by = dplyr::join_by(depth_maps_generation_quality, software)
    ) %>% 
    dplyr::mutate(depth_maps_generation_quality = depth_maps_generation_quality %>% forcats::fct_rev()) %>% 
  # plot
  ggplot(
    mapping = aes(
      y = value, x = software
      , fill = med
    )
  ) +
    geom_hline(yintercept = 0, color = "gray33") +
    tidybayes::stat_eye(
      point_interval = median_hdi, .width = .95
      , slab_alpha = 0.98
      , interval_color = "black", linewidth = 1
      , point_color = "black", point_fill = "black", point_size = 1
    ) +
    scale_fill_stepsn(
      n.breaks = 5
      , colors = viridis::mako(n = 5, begin = 0.2, end = 0.9, direction = -1)
      , limits = c(0,lmt_basal_area_abs_pct_error*.6)
      , labels = scales::percent_format(accuracy = 0.1)
      , show.limits = T
    ) +
    facet_grid(cols = vars(depth_maps_generation_quality)) +
    scale_y_continuous(
      limits = c(-0.005,lmt_basal_area_abs_pct_error*1.1)
      , labels = scales::percent_format(accuracy = 1)
    ) +
    labs(
      x = "software", y = "BA Abs. % Error"
      , subtitle = "posterior predictive distribution of BA Abs. % Error with 95% HDI\nby dense cloud quality"
    ) +
    theme_light() +
    theme(
      legend.position = "none"
      , legend.direction  = "horizontal"
      , axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)
      , strip.text = element_text(color = "black", face = "bold")
    ) 
```

and a table of these 95% HDI values

```{r}
table_temp = 
  draws_temp %>% 
  tidybayes::median_hdi(value) %>% 
  # remove out-of-sample obs
    dplyr::inner_join(
      ptcld_validation_data %>% dplyr::distinct(depth_maps_generation_quality, software)
      , by = dplyr::join_by(depth_maps_generation_quality, software)
    ) %>% 
  dplyr::select(-c(.point,.interval, .width,.row)) %>%
  dplyr::arrange(software,depth_maps_generation_quality) %>% 
  dplyr::mutate(dplyr::across(.cols = is.numeric, .fns = ~ scales::percent(.x,accuracy = 0.1)))

table_temp %>% 
  dplyr::select(-c(software)) %>% 
  kableExtra::kbl(
    digits = 2
    , caption = "BA Abs. % Error<br>95% HDI of the posterior predictive distribution"
    , col.names = c(
      "quality"
      , "BA Abs. % Error<br>median"
      , "HDI low", "HDI high"
    )
    , escape = F
  ) %>% 
  kableExtra::kable_styling() %>% 
  kableExtra::pack_rows(index = table(forcats::fct_inorder(table_temp$software))) %>% 
  kableExtra::scroll_box(height = "8in")
```

we can also make pairwise comparisons

```{r}
# calculate contrast
brms_contrast_temp = draws_temp %>% 
  tidybayes::compare_levels(
    value
    , by = depth_maps_generation_quality
    , comparison = contrast_list
  ) %>% 
  dplyr::rename(contrast = depth_maps_generation_quality)

# separate contrast
brms_contrast_temp = brms_contrast_temp %>% 
  dplyr::ungroup() %>% 
  tidyr::separate_wider_delim(
    cols = contrast
    , delim = " - "
    , names = paste0(
      "sorter"
      , 1:(max(stringr::str_count(brms_contrast_temp$contrast, "-"))+1)
    )
    , too_few = "align_start"
    , cols_remove = F
  ) %>% 
  dplyr::filter(sorter1!=sorter2) %>% 
  dplyr::mutate(
    dplyr::across(
      tidyselect::starts_with("sorter")
      , .fns = function(x){factor(
        x, ordered = T
        , levels = levels(ptcld_validation_data$depth_maps_generation_quality)
      )}
    )
    , contrast = contrast %>% 
      forcats::fct_reorder(
        paste0(as.numeric(sorter1), as.numeric(sorter2)) %>% 
          as.numeric()
      )
  ) %>% 
  # median_hdi summary for coloring 
  dplyr::group_by(contrast, software) %>% 
  make_contrast_vars()

# remove out-of-sample obs
brms_contrast_temp = brms_contrast_temp %>% 
  dplyr::inner_join(
    ptcld_validation_data %>% dplyr::distinct(software, depth_maps_generation_quality)
    , by = dplyr::join_by(software, sorter1 == depth_maps_generation_quality)
  ) %>% 
  dplyr::inner_join(
    ptcld_validation_data %>% dplyr::distinct(software, depth_maps_generation_quality)
    , by = dplyr::join_by(software, sorter2 == depth_maps_generation_quality)
  )
  
```

plot it

```{r}
plt_contrast(
  brms_contrast_temp
  # , caption_text = form_temp
  , y_axis_title = "quality"
  , facet = "software"
  , label_size = 1.7
) +
  scale_x_continuous(
    labels = scales::percent_format(accuracy = 1)
    , limits = c(-1.1,0.3)
    , breaks = seq(-1,1,0.5)
  ) +
  labs(
    subtitle = "posterior predictive distribution of group constrasts with 95% & 50% HDI\nby software"
    , x = "constrast BA Abs. % Error"
  )

ggplot2::ggsave(
  "../data/qlty_sftwr_comp_ba_ape.png"
  , plot = ggplot2::last_plot() + labs(subtitle = "")
  , height = 7, width = 10.5
)
```

create plot for combining with other APE contrasts for publication

```{r}
ptchwrk_qlty_sftwr_comp_ba_ape =
  plt_contrast(
    brms_contrast_temp
    , y_axis_title = "quality contrast"
    , facet = "software"
    , label_size = 1.5
    , label = "pr_diff_lab_sm"
    , annotate_size = 1.6
  ) +
    labs(
      subtitle = "" # "constrast BA Abs. % Error"
      , x = "BA Abs. % Error constrast"
    ) +
    theme(
      legend.position="none"
      , axis.title.y = element_text(size = 10, face = "bold")
      , axis.title.x = element_text(size = 8)
    ) 
# ptchwrk_qlty_sftwr_comp_ba_ape
```

and summarize these contrasts

```{r}
table_temp = brms_contrast_temp %>%
  dplyr::group_by(contrast, software, pr_lt_zero) %>% 
  tidybayes::median_hdi(value) %>% 
  dplyr::arrange(contrast, software) %>% 
  dplyr::select(contrast, software, value, .lower, .upper, pr_lt_zero) %>% 
  dplyr::arrange(software, contrast) %>% 
  dplyr::mutate(dplyr::across(.cols = is.numeric, .fns = ~ scales::percent(.x,accuracy = 0.1)))

table_temp %>% 
  dplyr::select(-c(software)) %>% 
  kableExtra::kbl(
    digits = 2
    , caption = "BA Abs. % Error<br>95% HDI of the posterior predictive distribution of group contrasts"
    , col.names = c(
      "quality contrast"
      , "median difference<br>BA Abs. % Error"
      , "HDI low", "HDI high"
      , "Pr(diff<0)"
    )
    , escape = F
  ) %>% 
  kableExtra::kable_styling() %>% 
  kableExtra::pack_rows(index = table(forcats::fct_inorder(table_temp$software))) %>% 
  kableExtra::scroll_box(height = "8in")
```

The contrasts above address the question "are there differences in APE based on dense point cloud generation quality within each software?".

To address the different question of "are there differences in APE based on the processing software used at a given dense point cloud generation quality?" we need to utilize a different formulation of the `comparison` parameter within our call to the `tidybayes::compare_levels` function and calculate the contrast by `software` instead

```{r}
# calculate contrast
brms_contrast_temp = draws_temp %>% 
  tidybayes::compare_levels(
    value
    , by = software
    , comparison = "pairwise"
  ) %>% 
  dplyr::rename(contrast = software) %>% 
  # median_hdi summary for coloring 
  dplyr::group_by(contrast, depth_maps_generation_quality) %>% 
  make_contrast_vars()

# remove out-of-sample obs
brms_contrast_temp = brms_contrast_temp %>% 
  tidyr::separate_wider_delim(
    cols = contrast
    , delim = " - "
    , names = paste0(
      "sorter"
      , 1:(max(stringr::str_count(brms_contrast_temp$contrast, "-"))+1)
    )
    , too_few = "align_start"
    , cols_remove = F
  ) %>% 
  dplyr::filter(sorter1!=sorter2) %>% 
  dplyr::inner_join(
    ptcld_validation_data %>% dplyr::distinct(software, depth_maps_generation_quality)
    , by = dplyr::join_by(sorter1 == software, depth_maps_generation_quality)
  ) %>% 
  dplyr::inner_join(
    ptcld_validation_data %>% dplyr::distinct(software, depth_maps_generation_quality)
    , by = dplyr::join_by(sorter2 == software, depth_maps_generation_quality)
  )
```

plot it

```{r}
plt_contrast(
  brms_contrast_temp
  # , caption_text = form_temp
  , y_axis_title = "software"
  , facet = "depth_maps_generation_quality"
  , label_size = 1.7
) +
  scale_x_continuous(
    labels = scales::percent_format(accuracy = 1)
    , limits = c(-0.7,0.6)
    , breaks = seq(-0.6,0.6,0.3)
  ) +
  facet_wrap(facets = vars(depth_maps_generation_quality), ncol = 2) +
  labs(
    subtitle = "posterior predictive distribution of group constrasts with 95% & 50% HDI\nby dense cloud quality"
    , x = "constrast BA Abs. % Error"
  ) +
  theme(
    legend.position = c(.75, .13)
  ) +
  guides(fill = guide_colorbar(theme = theme(
    legend.key.width  = unit(1, "lines"),
    legend.key.height = unit(7, "lines")
  )))

ggplot2::ggsave(
  "../data/sftwr_qlty_comp_ba_ape.png"
  , plot = ggplot2::last_plot() + labs(subtitle = "")
  , height = 7, width = 10.5
)
```

create plot for combining with other APE contrasts for publication

```{r}
ptchwrk_sftwr_qlty_comp_ba_ape =
  plt_contrast(
    brms_contrast_temp
    , y_axis_title = "software contrast"
    , facet = "depth_maps_generation_quality"
    , label_size = 1.7
    , label = "pr_diff_lab_sm"
    , annotate_size = 1.8
  ) +
    facet_wrap(facets = vars(depth_maps_generation_quality), ncol = 3) +
    labs(
      subtitle = ""
      , x = "BA Abs. % Error constrast"
    ) +
    theme(
      legend.position = "inside"
      , legend.position.inside = c(.8, .10)
      , axis.title.y = element_text(size = 10, face = "bold")
      , axis.title.x = element_text(size = 8)
    ) +
    guides(fill = guide_colorbar(theme = theme(
      legend.key.width  = unit(1, "lines"),
      legend.key.height = unit(6.5, "lines")
    )))
# ptchwrk_sftwr_qlty_comp_ba_ape
```

```{r, include=FALSE, eval=FALSE}
### old
ptchwrk_sftwr_qlty_comp_ba_ape =
  plt_contrast(
    brms_contrast_temp
    , y_axis_title = "software contrast"
    , facet = "depth_maps_generation_quality"
    , label_size = 1.7
    , label = "pr_diff_lab_sm"
    , annotate_size = 1.8
  ) +
    facet_wrap(facets = vars(depth_maps_generation_quality), ncol = 2) +
    labs(
      subtitle = ""
      , x = "BA Abs. % Error constrast"
    ) +
    theme(
      legend.position = c(.75, .13)
      , axis.title.y = element_text(size = 10, face = "bold")
      , axis.title.x = element_text(size = 8)
    ) +
    guides(fill = guide_colorbar(theme = theme(
      legend.key.width  = unit(1, "lines"),
      legend.key.height = unit(7, "lines")
    )))
# ptchwrk_sftwr_qlty_comp_ba_ape
```

and summarize these contrasts

```{r}
table_temp = brms_contrast_temp %>%
  dplyr::group_by(contrast, depth_maps_generation_quality, pr_lt_zero) %>% 
  tidybayes::median_hdi(value) %>% 
  dplyr::arrange(contrast, depth_maps_generation_quality) %>% 
  dplyr::select(contrast, depth_maps_generation_quality, value, .lower, .upper, pr_lt_zero) %>% 
  dplyr::mutate(dplyr::across(.cols = is.numeric, .fns = ~ scales::percent(.x,accuracy = 0.1)))
  
table_temp %>% 
  dplyr::select(-c(contrast)) %>% 
  kableExtra::kbl(
    digits = 2
    , caption = "BA Abs. % Error<br>95% HDI of the posterior predictive distribution of group contrasts"
    , col.names = c(
      "quality"
      , "median difference<br>BA Abs. % Error"
      , "HDI low", "HDI high"
      , "Pr(diff<0)"
    )
    , escape = F
  ) %>% 
  kableExtra::kable_styling() %>% 
  kableExtra::pack_rows(index = table(forcats::fct_inorder(table_temp$contrast))) %>% 
  kableExtra::scroll_box(height = "8in")
```

#### Software:Filtering - interaction

```{r}
draws_temp = 
  tidyr::crossing(
    depth_maps_generation_filtering_mode = unique(ptcld_validation_data$depth_maps_generation_filtering_mode)
    , software = unique(ptcld_validation_data$software)
  ) %>% 
    tidybayes::add_epred_draws(
      brms_ba_ape_mod, allow_new_levels = T
      # this part is crucial
      , re_formula = ~ (1 | depth_maps_generation_filtering_mode) +
        (1 | software) + 
        (1 | depth_maps_generation_filtering_mode:software)
    ) %>% 
    dplyr::rename(value = .epred) %>% 
    dplyr::mutate(med = tidybayes::median_hdci(value)$y)
# plot
  draws_temp %>%
  # remove out-of-sample obs
  dplyr::inner_join(
    ptcld_validation_data %>% dplyr::distinct(depth_maps_generation_filtering_mode, software)
    , by = dplyr::join_by(depth_maps_generation_filtering_mode, software)
  ) %>% 
  # plot
  ggplot(
    mapping = aes(
      y = value, x = software
      , fill = med
    )
  ) +
    geom_hline(yintercept = 0, color = "gray33") +
    tidybayes::stat_eye(
      point_interval = median_hdi, .width = .95
      , slab_alpha = 0.98
      , interval_color = "black", linewidth = 1
      , point_color = "black", point_fill = "black", point_size = 1
    ) +
    scale_fill_stepsn(
      n.breaks = 5
      , colors = viridis::mako(n = 5, begin = 0.2, end = 0.9, direction = -1)
      , limits = c(0,lmt_basal_area_abs_pct_error*.6)
      , labels = scales::percent_format(accuracy = 0.1)
      , show.limits = T
    ) +
    facet_grid(cols = vars(depth_maps_generation_filtering_mode)) +
    scale_y_continuous(
      limits = c(-0.005,lmt_basal_area_abs_pct_error*1.1)
      , labels = scales::percent_format(accuracy = 1)
    ) +
    labs(
      x = "software", y = "BA Abs. % Error"
      , subtitle = "posterior predictive distribution of BA Abs. % Error with 95% HDI\nby filtering mode"
    ) +
    theme_light() +
    theme(
      legend.position = "none"
      , legend.direction  = "horizontal"
      , axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)
      , strip.text = element_text(color = "black", face = "bold")
    ) 
```

and a table of these 95% HDI values

```{r}
table_temp = 
  draws_temp %>% 
    tidybayes::median_hdi(value) %>% 
    dplyr::select(-c(.point,.interval, .width,.row)) %>% 
    dplyr::arrange(software,depth_maps_generation_filtering_mode) %>% 
    dplyr::mutate(dplyr::across(.cols = is.numeric, .fns = ~ scales::percent(.x,accuracy = 0.1)))

table_temp %>% 
  dplyr::select(-c(software)) %>% 
  kableExtra::kbl(
    digits = 2
    , caption = "BA Abs. % Error<br>95% HDI of the posterior predictive distribution"
    , col.names = c(
      "filtering mode"
      , "BA Abs. % Error<br>median"
      , "HDI low", "HDI high"
    )
    , escape = F
  ) %>% 
  kableExtra::kable_styling() %>% 
  kableExtra::pack_rows(index = table(forcats::fct_inorder(table_temp$software))) %>% 
  kableExtra::scroll_box(height = "8in")
```

we can also make pairwise comparisons

```{r}
# calculate contrast
brms_contrast_temp = draws_temp %>% 
  tidybayes::compare_levels(
    value
    , by = depth_maps_generation_filtering_mode
    , comparison = "pairwise"
  ) %>% 
  dplyr::rename(contrast = depth_maps_generation_filtering_mode)

# separate contrast
brms_contrast_temp = brms_contrast_temp %>% 
  dplyr::ungroup() %>% 
  tidyr::separate_wider_delim(
    cols = contrast
    , delim = " - "
    , names = paste0(
      "sorter"
      , 1:(max(stringr::str_count(brms_contrast_temp$contrast, "-"))+1)
    )
    , too_few = "align_start"
    , cols_remove = F
  ) %>% 
  dplyr::filter(sorter1!=sorter2) %>% 
  dplyr::mutate(
    dplyr::across(
      tidyselect::starts_with("sorter")
      , .fns = function(x){factor(
        x, ordered = T
        , levels = levels(ptcld_validation_data$depth_maps_generation_filtering_mode)
      )}
    )
    , contrast = contrast %>% 
      forcats::fct_reorder(
        paste0(as.numeric(sorter1), as.numeric(sorter2)) %>% 
          as.numeric()
      ) %>% 
      # re order for filtering mode
      forcats::fct_rev()
  ) %>% 
  # median_hdi summary for coloring 
  dplyr::group_by(contrast, software) %>% 
  make_contrast_vars()

# remove out-of-sample obs
brms_contrast_temp = brms_contrast_temp %>% 
  dplyr::inner_join(
    ptcld_validation_data %>% dplyr::distinct(software, depth_maps_generation_filtering_mode)
    , by = dplyr::join_by(software, sorter1 == depth_maps_generation_filtering_mode)
  ) %>% 
  dplyr::inner_join(
    ptcld_validation_data %>% dplyr::distinct(software, depth_maps_generation_filtering_mode)
    , by = dplyr::join_by(software, sorter2 == depth_maps_generation_filtering_mode)
  )

```

plot it

```{r}
plt_contrast(
  brms_contrast_temp
  # , caption_text = form_temp
  , y_axis_title = "filtering mode"
  , facet = "software"
  , label_size = 1.6
) +
  scale_x_continuous(
    labels = scales::percent_format(accuracy = 1)
    , limits = c(-0.8,0.65)
    , breaks = seq(-0.8,0.8,0.4)
  ) +
  labs(
    subtitle = "posterior predictive distribution of group constrasts with 95% & 50% HDI\nby software"
    , x = "constrast BA Abs. % Error"
  )

ggplot2::ggsave(
  "../data/fltr_sftwr_comp_ba_ape.png"
  , plot = ggplot2::last_plot() + labs(subtitle = "")
  , height = 7, width = 10.5
)
```

create plot for combining with other APE contrasts for publication

```{r}
ptchwrk_fltr_sftwr_comp_ba_ape =
  plt_contrast(
    brms_contrast_temp
    , y_axis_title = "filtering mode contrast"
    , facet = "software"
    , label_size = 1.7
    , label = "pr_diff_lab_sm"
    , annotate_size = 1.6
  ) +
    labs(
      subtitle = "" # "constrast BA Abs. % Error"
      , x = "BA Abs. % Error constrast"
    ) +
    theme(
      legend.position="none"
      , axis.title.y = element_text(size = 10, face = "bold")
      , axis.title.x = element_text(size = 8)
    ) 
# ptchwrk_fltr_sftwr_comp_ba_ape
```

and summarize these contrasts

```{r}
table_temp = brms_contrast_temp %>%
  dplyr::group_by(contrast, software, pr_lt_zero) %>% 
  tidybayes::median_hdi(value) %>% 
  dplyr::arrange(contrast, software) %>% 
  dplyr::select(contrast, software, value, .lower, .upper, pr_lt_zero) %>% 
  dplyr::arrange(software, contrast) %>% 
  dplyr::mutate(dplyr::across(.cols = is.numeric, .fns = ~ scales::percent(.x,accuracy = 0.1)))

table_temp %>% 
  dplyr::select(-c(software)) %>% 
  kableExtra::kbl(
    digits = 2
    , caption = "BA Abs. % Error<br>95% HDI of the posterior predictive distribution of group contrasts"
    , col.names = c(
      "filtering contrast"
      , "median difference<br>BA Abs. % Error"
      , "HDI low", "HDI high"
      , "Pr(diff<0)"
    )
    , escape = F
  ) %>% 
  kableExtra::kable_styling() %>% 
  kableExtra::pack_rows(index = table(forcats::fct_inorder(table_temp$software))) %>% 
  kableExtra::scroll_box(height = "8in")
```

#### Software:Quality:Filtering - interaction

```{r}
# get draws
fltr_sftwr_draws_temp =
  tidyr::crossing(
    depth_maps_generation_quality = unique(ptcld_validation_data$depth_maps_generation_quality)
    , depth_maps_generation_filtering_mode = unique(ptcld_validation_data$depth_maps_generation_filtering_mode)
    , software = unique(ptcld_validation_data$software)
  ) %>% 
  tidybayes::add_epred_draws(
    brms_ba_ape_mod, allow_new_levels = T
    # this part is crucial
    , re_formula = ~ (1 | depth_maps_generation_quality) + # main effects
    (1 | depth_maps_generation_quality) +
    (1 | depth_maps_generation_filtering_mode) + 
    (1 | software) +
    # two-way interactions
    (1 | depth_maps_generation_quality:depth_maps_generation_filtering_mode) +
    (1 | depth_maps_generation_quality:software) +
    (1 | depth_maps_generation_filtering_mode:software) +
    # three-way interactions
    (1 | depth_maps_generation_quality:depth_maps_generation_filtering_mode:software)
  ) %>% 
  dplyr::rename(value = .epred) %>% 
  dplyr::mutate(med = tidybayes::median_hdci(value)$y)

# plot
qlty_fltr_sftwr_ba_ape =
  fltr_sftwr_draws_temp %>% 
    dplyr::inner_join(
      ptcld_validation_data %>% dplyr::distinct(software, depth_maps_generation_quality, depth_maps_generation_filtering_mode)
      , by = dplyr::join_by(software, depth_maps_generation_quality, depth_maps_generation_filtering_mode)
    ) %>% 
    dplyr::mutate(depth_maps_generation_quality = depth_maps_generation_quality %>% forcats::fct_rev()) %>% 
    ggplot(
      mapping = aes(
        y = value
        , x = depth_maps_generation_filtering_mode
        , fill = med
      )
    ) +
    geom_hline(yintercept = 0, color = "gray33") +
    tidybayes::stat_eye(
      point_interval = median_hdi, .width = .95
      , slab_alpha = 0.98
      , interval_color = "black", linewidth = 1
      , point_color = "black", point_fill = "black", point_size = 1
    ) +
    scale_fill_stepsn(
      n.breaks = 5
      , colors = viridis::mako(n = 5, begin = 0.2, end = 0.9, direction = -1)
      , limits = c(0,lmt_basal_area_abs_pct_error*.6)
      , labels = scales::percent_format(accuracy = 0.1)
      , show.limits = T
    ) +
    facet_grid(
      rows = vars(software)
      , cols = vars(depth_maps_generation_quality)
      # , switch = "y"
    ) +
    scale_y_continuous(
      limits = c(-0.005,lmt_basal_area_abs_pct_error*1.45)
      , labels = scales::percent_format(accuracy = 1)
    ) +
    labs(
      x = "filtering mode", y = "BA Abs. % Error"
      , subtitle = "posterior predictive distribution of BA Abs. % Error with 95% HDI\nby dense cloud quality and software"
      # , caption = form_temp
    ) +
    theme_light() +
    theme(
      legend.position = "none"
      , legend.direction  = "horizontal"
      , axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)
      , strip.text = element_text(color = "black", face = "bold")
      , panel.grid = element_blank()
      # , strip.placement = "outside"
    ) +
    guides(
      fill = guide_legend(override.aes = list(shape = NA, size = 6, alpha = 0.9, lwd = NA))
    )
# print it
qlty_fltr_sftwr_ba_ape
ggplot2::ggsave("../data/qlty_fltr_sftwr_ba_ape.png", height = 7, width = 10.5)
```

and a table of these 95% HDI values

```{r}
table_temp =
  fltr_sftwr_draws_temp %>% 
  tidybayes::median_hdi(value) %>%
  dplyr::inner_join(
    ptcld_validation_data %>% dplyr::distinct(software, depth_maps_generation_quality, depth_maps_generation_filtering_mode)
    , by = dplyr::join_by(software, depth_maps_generation_quality, depth_maps_generation_filtering_mode)
  ) %>% 
  dplyr::mutate(depth_maps_generation_quality = depth_maps_generation_quality %>% forcats::fct_rev()) %>%
  dplyr::select(c(
    software, depth_maps_generation_quality, depth_maps_generation_filtering_mode
    , value, .lower, .upper
  )) %>% 
  dplyr::ungroup() %>% 
  dplyr::arrange(software, depth_maps_generation_quality, depth_maps_generation_filtering_mode) %>% 
  dplyr::mutate(dplyr::across(.cols = is.numeric, .fns = ~ scales::percent(.x,accuracy = 0.1)))

table_temp %>% 
  # dplyr::select(-c(software)) %>% 
  kableExtra::kbl(
    digits = 2
    , caption = "BA Abs. % Error<br>95% HDI of the posterior predictive distribution"
    , col.names = c(
      "software", "quality", "filtering mode"
      , "BA Abs. % Error<br>median"
      , "HDI low", "HDI high"
    )
    , escape = F
  ) %>% 
  kableExtra::kable_styling() %>% 
  # kableExtra::pack_rows(index = table(forcats::fct_inorder(table_temp$software))) %>% 
  kableExtra::collapse_rows(columns = 1:2, valign = "top") %>%
  kableExtra::scroll_box(height = "8in")
```

we can also make pairwise comparisons

```{r}
# calculate contrast
brms_contrast_temp = fltr_sftwr_draws_temp %>% 
  tidybayes::compare_levels(
    value
    , by = depth_maps_generation_filtering_mode
    , comparison = "pairwise"
  ) %>% 
  dplyr::rename(contrast = depth_maps_generation_filtering_mode)

# separate contrast
brms_contrast_temp = brms_contrast_temp %>% 
  dplyr::ungroup() %>% 
  tidyr::separate_wider_delim(
    cols = contrast
    , delim = " - "
    , names = paste0(
      "sorter"
      , 1:(max(stringr::str_count(brms_contrast_temp$contrast, "-"))+1)
    )
    , too_few = "align_start"
    , cols_remove = F
  ) %>% 
  dplyr::filter(sorter1!=sorter2) %>% 
  dplyr::mutate(
    dplyr::across(
      tidyselect::starts_with("sorter")
      , .fns = function(x){factor(
        x, ordered = T
        , levels = levels(ptcld_validation_data$depth_maps_generation_filtering_mode)
      )}
    )
    , contrast = contrast %>% 
      forcats::fct_reorder(
        paste0(as.numeric(sorter1), as.numeric(sorter2)) %>% 
          as.numeric()
      ) %>% 
      # re order for filtering mode
      forcats::fct_rev()
  ) %>% 
  # median_hdi summary for coloring 
  dplyr::group_by(contrast, software, depth_maps_generation_quality) %>% 
  make_contrast_vars()

# remove out-of-sample obs
brms_contrast_temp = brms_contrast_temp %>% 
  dplyr::inner_join(
    ptcld_validation_data %>% dplyr::distinct(software, depth_maps_generation_quality, depth_maps_generation_filtering_mode)
    , by = dplyr::join_by(software, depth_maps_generation_quality, sorter1==depth_maps_generation_filtering_mode)
  ) %>% 
  dplyr::inner_join(
    ptcld_validation_data %>% dplyr::distinct(software, depth_maps_generation_quality, depth_maps_generation_filtering_mode)
    , by = dplyr::join_by(software, depth_maps_generation_quality, sorter2==depth_maps_generation_filtering_mode)
  ) %>% 
  dplyr::mutate(depth_maps_generation_quality = depth_maps_generation_quality %>% forcats::fct_rev())

```

plot it

```{r}
brms_contrast_temp %>% 
  plt_contrast(
    facet = c("depth_maps_generation_quality", "software")
    , y_axis_title = "filtering mode"
    , label_size = 0
  ) +
  facet_grid(
    rows = vars(software)
    , cols = vars(depth_maps_generation_quality)
  ) +
  scale_x_continuous(
    labels = scales::percent_format(accuracy = 1)
    , limits = c(-0.8,0.4)
    , breaks = seq(-0.8,0.8,0.4)
  ) +
  labs(
    subtitle = "posterior predictive distribution of group constrasts with 95% & 50% HDI\nby dense cloud quality and software"
    , x = "constrast BA Abs. % Error"
  )
  
ggplot2::ggsave(
  "../data/qlty_fltr_sftwr_comp_ba_ape.png"
  , plot = ggplot2::last_plot() + labs(subtitle = "")
  , height = 7, width = 10.5
)
```

Export some final images for publication

```{r, fig.height=10}
p1_temp = qlty_fltr_sftwr_ba_pe + labs(subtitle = "A: Basal Area % Error") + theme(plot.subtitle = element_text(face="bold"))
p2_temp = qlty_fltr_sftwr_ba_ape + labs(subtitle = "B: Basal Area Abs. % Error") + theme(plot.subtitle = element_text(face="bold"))
# export
p1_temp / p2_temp
ggplot2::ggsave(
    filename = paste0("../data/qlty_fltr_sftwr_ba_comb.jpeg")
    , plot = ggplot2::last_plot()
    , width = 8.5
    , height = 11
    , units = "in"
    , dpi = "print"
  )
```

`patchwork` of Height APE contrasts

```{r, fig.height=9, include=T, eval=T}
layout_temp = c(
    # area(t, l, b, r)
    patchwork::area(2, 1, 2, 1)
    , patchwork::area(2, 3, 2, 3)
    , patchwork::area(4, 1, 4, 3)
  )
  # check the layout
  # plot(layout_temp)
############################
# patchwork for height
############################
  ptchwrk_qlty_sftwr_comp_ba_ape + 
    labs(subtitle = "A: Quality Contrast by Software") +
    theme(plot.background = element_rect(colour = "gray88", fill=NA, size=3)) +
  ptchwrk_fltr_sftwr_comp_ba_ape + 
    labs(subtitle = "B: Filtering Mode Contrast by Software") +
    theme(plot.background = element_rect(colour = "gray88", fill=NA, size=3)) +
  patchwork::free(
    ptchwrk_sftwr_qlty_comp_ba_ape + 
    labs(subtitle = "C: Software Contrast by Quality") +
    theme(plot.background = element_rect(colour = "gray88", fill=NA, size=3)) ) +
  # plot_annotation(tag_levels = list(c('#', '&'), '1')) +
  patchwork::plot_layout(
    design = layout_temp
    , widths = c(1,0.01,1)
    , heights = c(0.01,1,0.01,1,0.01)
  ) &
  scale_x_continuous(
    labels = scales::percent_format(accuracy = 1)
    , limits = c(-1.1,0.52)
    , breaks = seq(-0.8,0.8,0.4)
  ) &
  theme(
    axis.title.y = element_blank()
    , plot.subtitle = element_text(face = "bold", hjust = 0.0)
    # , plot.background = element_rect(colour = "gray88", fill=NA, size=3)
  )
ggplot2::ggsave(
    filename = paste0("../data/all_ba_ape_contrasts.jpeg")
    , plot = ggplot2::last_plot()
    , width = 11
    , height = 8.5
    , units = "in"
    , dpi = "print"
  )
```

## Posterior Predictive Checks

Markov chain Monte Carlo (MCMC) simulations were conducted using the `brms` package (Bürkner 2017) to estimate posterior predictive distributions of the parameters of interest. We ran three chains of 100,000 iterations with the first 50,000 discarded as burn-in. Trace-plots were utilized to visually assess model convergence and sufficient convergence was checked with $\hat{R}$ values near 1 ([Brooks & Gelman, 1998](https://scholar.google.com/scholar?cluster=14209404114665352991&hl=en&as_sdt=0,6)). Posterior predictive checks were used to evaluate model goodness-of-fit by comparing data simulated from the model with the observed data used to estimate the model parameters ([Hobbs & Hooten, 2015](https://scholar.google.com/scholar?cluster=9228589188684720156&hl=en&as_sdt=0,6)). Calculating the proportion of MCMC iterations in which the test statistic (i.e., mean and sum of squares) from the simulated data and observed data are more extreme than one another provides the Bayesian P-value. Lack of fit is indicated by a value close to 0 or 1 while a value of 0.5 indicates perfect fit ([Hobbs & Hooten, 2015](https://scholar.google.com/scholar?cluster=9228589188684720156&hl=en&as_sdt=0,6)).

To learn more about this approach to posterior predictive checks, check out Gabry’s (2022) vignette, [Graphical posterior predictive checks using the bayesplot package](https://cran.r-project.org/web/packages/bayesplot/vignettes/graphical-ppcs.html). 

### Prior Distriubutions

```{r, fig.height=8}
plt_prior11+plt_prior12 &
  theme(strip.text = element_text(size = 6))
```

### Trace-plots

check the trace plots for problems with convergence of the Markov chains

#### Basal Area Percentage Error

```{r, fig.height=8}
# height mean error
plot(brms_ba_pe_mod)
```

#### Basal Area Abs. percentage error

```{r, fig.height=8}
# height rmse
plot(brms_ba_ape_mod)
```

### $\hat{R}$ values

```{r, fig.height=8}
plt_rhat_temp <- function(my_mod) {
  my_mod %>% 
    brms::rhat() %>% 
    as.data.frame() %>% 
    tibble::rownames_to_column(var = "parameter") %>%
    dplyr::rename_with(tolower) %>% 
    dplyr::rename(rhat = 2) %>% 
    dplyr::filter(
      stringr::str_starts(parameter, "b_") 
      | stringr::str_starts(parameter, "r_") 
      | stringr::str_starts(parameter, "sd_") 
      | parameter == "phi"
      | parameter == "sigma"
    ) %>%
    dplyr::mutate(
      parameter = parameter %>% 
        stringr::str_replace_all("depth_maps_generation_quality", "quality") %>% 
        stringr::str_replace_all("depth_maps_generation_filtering_mode", "filtering")
      , chk = (rhat <= 1*0.998 | rhat >= 1*1.002)
    ) %>% 
    ggplot(aes(x = rhat, y = parameter, color = chk, fill = chk)) +
    geom_vline(xintercept = 1, linetype = "dashed", color = "gray44", lwd = 1.2) +
    geom_vline(xintercept = 1*0.998, lwd = 1.5) +
    geom_vline(xintercept = 1*1.002, lwd = 1.5) +
    geom_vline(xintercept = 1*0.999, lwd = 1.2, color = "gray33") +
    geom_vline(xintercept = 1*1.001, lwd = 1.2, color = "gray33") +
    geom_point() +
    scale_fill_manual(values = c("navy", "firebrick")) +
    scale_color_manual(values = c("navy", "firebrick")) +
    scale_y_discrete(NULL, breaks = NULL) +
    labs(
      x = latex2exp::TeX("$\\hat{R}$")
      , subtitle = latex2exp::TeX("MCMC chain convergence check for $\\hat{R}$ values")
    ) +
    theme_light() +
    theme(
      legend.position = "none"
      , axis.text.y = element_text(size = 3)
      , panel.grid.major.x = element_blank()
      , panel.grid.minor.x = element_blank()
      , plot.title = element_text(size = 9)
      , plot.subtitle = element_text(size = 8)
      , axis.title.y = element_blank()
      , axis.title.x = element_text(size = 9)
      , panel.grid = element_blank()
      , axis.text.x = element_text(size = 6.5)
    )
}
# plot together with patchwork
brms_ba_pe_mod %>% plt_rhat_temp() + labs(title = "Basal Area Percentage Error") +
brms_ba_ape_mod %>% plt_rhat_temp() + labs(title = "Basal Area Absolute Percentage Error") &
  theme(plot.subtitle = element_blank())
```

### ESS values

The effective length of an MCMC chain is indicated by the effective sample size (ESS), which refers to the sample size of the MCMC chain **not** to the sample size of the data
[Kruschke (2015)](https://sites.google.com/site/doingbayesiandataanalysis/) notes: 

>One simple guideline is this: For reasonably accurate and stable estimates of the limits of the 95% HDI, an ESS of 10,000 is recommended. This is merely a heuristic based on experience with practical applications, it is not a requirement. If accuracy of the HDI limits is not crucial for your application, then a smaller ESS may be sufficient. (p.184)

```{r, fig.height=8}
plt_ess_temp <- function(my_mod) {
# get ess values from model summary
dplyr::bind_rows(
    summary(my_mod) %>% 
      purrr::pluck("random") %>% 
      purrr::flatten() %>% 
      purrr::keep_at(~ .x == "Bulk_ESS") %>% 
      unlist() %>% 
      dplyr::as_tibble()
    , summary(my_mod) %>% 
      purrr::pluck("fixed") %>% 
      purrr::flatten() %>% 
      purrr::keep_at(~ .x == "Bulk_ESS") %>% 
      unlist() %>% 
      dplyr::as_tibble()
  ) %>% 
  dplyr::rename(ess = 1) %>% 
  dplyr::mutate(parameter = dplyr::row_number(), chk = ess<10000) %>% 
  ggplot(aes(x = ess, y = parameter, color = chk, fill = chk)) +
  geom_vline(xintercept = 10000, linetype = "dashed", color = "gray44", lwd = 1.2) +
  geom_segment( aes(x = 0, xend=ess, yend=parameter), color="black") +
  geom_point() +
  scale_fill_manual(values = c("blue4", "blue3")) +
  scale_color_manual(values = c("blue4", "blue3")) +
  scale_y_continuous(NULL, breaks = NULL) +
  scale_x_continuous(labels = scales::comma) +
  labs(
    x = "ESS"
    , subtitle = "MCMC chain resolution check for effective sample size (ESS) values"
    , y = ""
  ) +
  theme_light() +
  theme(
    legend.position = "none"
    , axis.text.y = element_text(size = 4)
    , panel.grid.major.x = element_blank()
    , panel.grid.minor.x = element_blank()
    , plot.title = element_text(size = 9)
    , plot.subtitle = element_text(size = 8)
    , axis.title.y = element_blank()
    , axis.title.x = element_text(size = 9)
    , axis.text.x = element_text(size = 6.5)
  )
}

# plot together with patchwork
brms_ba_pe_mod %>% plt_ess_temp() + labs(title = "Basal Area Percentage Error") +
brms_ba_ape_mod %>% plt_ess_temp() + labs(title = "Basal Area Absolute Percentage Error") &
  theme(plot.subtitle = element_blank())
```

### Mean and SD

posterior predictive check for the overall model combining mean and sd

```{r}
plt_pp_temp <- function(my_mod) {
  my_mod %>% 
  brms::pp_check(type = "stat_2d", ndraws = 5000) +
    theme_light() +
    theme(
      legend.position = "top", legend.direction = "horizontal"
      , legend.text = element_text(size = 8)
      , plot.title = element_text(size = 9)
    )
}

# plot together with patchwork
brms_ba_pe_mod %>% plt_pp_temp() + labs(title = "Basal Area Percentage Error") +
brms_ba_ape_mod %>% plt_pp_temp() + labs(title = "Basal Area Absolute Percentage Error") &
  theme(plot.subtitle = element_blank())
```

### Bayesian p-value

The Bayesian p-value is the probability that a test statistic in the reference distribution exceeds its value in the data. The Bayesian p-value is calculated from the posterior predictive distribution of the new data and the distribution of the observed data. We estimate the probability that the test statistic calculated from "new" data arising from our model ($y_{new}$) is more extreme than the test statistic calculated from the observed data ($y$): $\text{P-value}(y) = Pr(T(y_{new}) > T(y))$ where the test statistic $T(y)$ describes the distribution of the data as a summary of the data; it could be the mean, variance, the coefﬁcient of variation, the kurtosis, the maximum, or the minimum of the observed data set, or it might be an "omnibus" statistic like a squared discrepancy or a chi-square value [Hobbs and Hooten (2015, p. 188)](https://scholar.google.com/scholar?cluster=9228589188684720156&oi=gsb&hl=en&as_sdt=0,6)

>Bayesian P values for mean and standard deviation test statistics The P values for the mean (P mean) give the probability that the mean of the data of new, out-of-sample observations simulated from the model exceeds the mean of the observed data. The P values for the standard deviation (P SD) give the probability that the standard deviation of new, out-of-sample observations simulated from the model exceeds the standard deviation of the observed data. Large ($\gtrapprox 0.90$) or small ($\lessapprox 0.10$) values indicate lack of fit. [Hobbs and Hooten (2015)](https://scholar.google.com/scholar?cluster=9228589188684720156&oi=gsb&hl=en&as_sdt=0,6);[Hobbs et al. (2024, Appendix S2 p. 8)](https://esajournals.onlinelibrary.wiley.com/doi/abs/10.1002/ecm.1598)

Check the Bayesian p-values between the models

```{r}
# get the model p-values
set.seed(41) # replicate results
dplyr::bind_rows(
    get_mod_p_val(brms_ba_pe_mod, ndraws = 5000) %>% 
      dplyr::mutate(model = "brms_ba_pe_mod")
    , get_mod_p_val(brms_ba_ape_mod, ndraws = 5000) %>% 
      dplyr::mutate(model = "brms_ba_ape_mod")
  ) %>% 
  dplyr::relocate(model) %>% 
  kableExtra::kbl(digits = 3) %>% 
  kableExtra::kable_styling()
```

### $\sigma$ posteriors

Finally, we can quantify the variation in our dependent variable by comparing the $\sigma$ (`sd`) posteriors

```{r}
plt_sigma_temp <- function(my_mod) {
  # extract the posterior draws
  brms::as_draws_df(my_mod) %>%
    dplyr::select(c(tidyselect::starts_with("sd_"))) %>% 
    tidyr::pivot_longer(dplyr::everything()) %>% 
    # dplyr::group_by(name) %>% 
    # tidybayes::median_hdi(value) %>% 
    dplyr::mutate(
      name = name %>% 
        stringr::str_replace_all("depth_maps_generation_quality", "quality") %>% 
        stringr::str_replace_all("depth_maps_generation_filtering_mode", "filtering") %>% 
        stringr::str_remove_all("sd_") %>% 
        stringr::str_remove_all("__Intercept") %>% 
        stringr::str_replace_all("_", " ") %>% 
        forcats::fct_reorder(value)
    ) %>%
  # plot
    ggplot(aes(x = value, y = name)) +
    tidybayes::stat_dotsinterval(
      point_interval = median_hdi, .width = .95
      , justification = -0.04
      , shape = 21 #, point_size = 3
      , quantiles = 100
    ) +
    scale_x_continuous(breaks = NULL) +
    labs(x = "", y = ""
      , subtitle = latex2exp::TeX("$\\sigma_\\beta$ posterior distributions")
    ) +
    theme_light() +
    theme(
      plot.subtitle = element_text(size = 8)
      , plot.title = element_text(size = 9)
    )
}
# plot together with patchwork
brms_ba_pe_mod %>% plt_sigma_temp() + labs(title = "Basal Area Percentage Error") +
brms_ba_ape_mod %>% plt_sigma_temp() + labs(title = "Basal Area Absolute Percentage Error")
```

Variance of study site is slightly stronger than variance of depth map generation quality, but the posterior predictive distributions overlap a good deal. The study site (the "subjects" in our study) seems to have the overall strongest effect, but this comes with high uncertainty. Taken alone, the influence of quality and software comes with huge uncertainty. This makes sense as the influence of software largely depends on the depth map generation quality. Likewise, the influence of quality depends on the software. We are fairly certain of this conditional influence based on the uncertainty associated with the interaction of these two terms. Filtering mode by itself has the weakest effect on tree detection and this comes with relatively high certainty. As with the influence of software, we are certain that the effect of filtering mode is conditional on the depth map generation quality.
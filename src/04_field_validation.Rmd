# Field Validation{#field_valid}

This section combines the SfM-derived tree locations with stem-mapped tree locations from field sampling. 

[Tinkham and Swayze (2021; p.6)](https://scholar.google.com/scholar?oi=bibs&hl=en&cluster=11260597505702247290) describe a methodology for matching UAS *detected* trees with stem mapped trees identified via traditional field *survey* methods. Note, *detected* trees in the excerpt below references UAS detected trees while *survey* trees references field-based stem mapped trees:

*Each of the detected tree outputs was matched with survey tree locations through an iterative process. Iteratively, a detected tree was selected, and all survey trees within a 3 m radius and 10% height of the detected tree were identified. If a survey tree met both the location and height precision requirements, it was considered a true positive (TP) detection, and both the survey and detected trees were removed from further matching. However, if no match was made, the detected tree was considered a commission (Co) and removed from further matching. This process was repeated until all detected trees were classified as true positive or commission, with all unmatched survey trees classified as omission (Om). Overall tree detection performance was described using the F-score metric.*

The F-score incorporates true positive, commission, and omission rates to determine how well the UAS detected trees represent the field-based stem mapped trees. As a measure of predictive performance, the highest possible value of an F-score is 1.0, indicating perfect precision and recall, and the lowest possible value is 0, if either precision or recall are zero.

$$
\textrm{F-score} = 2 \times \frac{\bigl(\frac{TP}{TP+Om} \times \frac{TP}{TP+Co} \bigr)}{\bigl(\frac{TP}{TP+Om} + \frac{TP}{TP+Co} \bigr)}
$$

The process to match UAS detected trees to field stem mapped trees implemented here is slightly different than the process described above. To match the data parametrization from the UAS point cloud processing workflow, only stem-mapped trees above `r unique(ptcld_processing_data$sttng_minimum_tree_height_m)` m were considered for analysis. Each UAS detected tree was matched with stem-mapped tree locations that were within a 3 m radius and 2 m height of the UAS detected tree. The matched UAS and stem-mapped tree pairs were jointly compared (rather than iteratively) to select the pair that minimized the height difference for both the stem-mapped tree and the UAS detected tree to ensure that only one UAS detected tree was selected for each stem-mapped tree. If more than one UAS detected tree had the same height difference to a stem-mapped tree, the UAS detected tree spatially nearest to the stem-mapped tree was selected as the match. These UAS detected trees with a paired stem-mapped tree after this filtering process were considered true positive ($TP$) detections.

To determine UAS detected tree commissions (i.e. UAS detected trees within the overstory plot for which there was no stem-mapped tree pair; $Co$) this analysis used the 2023-06 BHEF overstory field survey plot center and plot radius with a minimum DBH of 5 in (12.69 cm) as only trees above this size were sampled as part of the overstory survey. UAS detected trees within this radius with an [estimated DBH](#local_mod) over 5 in (12.69 cm) that did not have a matched stem-mapped tree pair were considered commissions ($Co$). The 2023-06 BHEF field surveys used $\frac{1}{10}$ acre (404.686 m^2^) plots with a 37.24 ft (11.35 m) radius for overstory sampling and $\frac{1}{400}$ acre (10.117 m^2^) plots with a 5.89 ft (1.795 m) radius for regeneration sampling. All unmatched stem-mapped survey trees were classified as omissions ($Om$).

```{r, warning=FALSE, message=FALSE, echo=FALSE, include=FALSE}
# While trapped in the FVS meeting I was able to get the field stem maps organized and build stand boundary polygons for use in the validation of the software comparison project.
# 
# However, also realized I made a really dumb move. I discovered that I assigned the same imagery for SQ09_02 and SQ02_04, so all of the SQ02_04 data is trash. Deciding we will just move ahead with the five datasets I did not screw up.
remove(list = ls()[grep("_temp",ls())])
gc()
```

## Setup

Pick a DBH to use for the validation. For this project, the UAS point cloud [processing script](https://github.com/georgewoolsey/metashape_testing/blob/main/src/software_point_cloud_processing.R) utilized the random forest model to estimate missing DBH values using training values extracted from the point cloud using the `TreeLS` package. The script below adds two linear model estimates of DBH based on the training data: 1) a linear model with an intercept (`dbh_cm ~ 1 + tree_height_m`); and 2) a linear model with no intercept (`dbh_cm ~ 0 + tree_height_m`).

The options for picking a DBH to use are: 

1. "rf" for random forest estimate
2. "lin" for linear model with an intercept (`dbh_cm ~ 1 + tree_height_m`) estimate
3. "lin_noint" for linear model with no intercept (`dbh_cm ~ 0 + tree_height_m`) estimate 
4. "regional" for regional estimate based on regional FIA data using the [USFS TreeMap data](https://www.fs.usda.gov/rds/archive/catalog/RDS-2021-0074)

```{r}
# Pick a DBH to use for the validation
# my_dbh_estimate = "lin"
my_dbh_estimate = "regional"
```

Load field validation plot data and update the `ptcld_processing_data` created in [this section](#ptcld_analysis) by adding a `processing_id` which we'll use to process the files for validation.

```{r, include=FALSE, eval=F}
## !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! for testing
list.files(
    "D:/SfM_Software_Comparison" # "../data"
    , pattern = ".*_field_uas_comparison_data\\.csv$", full.names = T, recursive = T
  ) %>% 
  purrr::map(file.remove)
# # testing
# ptcld_processing_data = ptcld_processing_data %>% 
#   dplyr::slice_sample(n = 3, replace = F)
```

```{r}
# list of study sites with completed uas data
study_site_list = ptcld_processing_data$study_site %>% unique() %>% toupper()

# list of field validation data
validation_data =
  list.files(
    "../data/field_validation"
    , pattern = "\\.gpkg$", full.names = T
  ) %>% 
  normalizePath() %>% 
  dplyr::as_tibble() %>% 
  dplyr::rename(validation_file_full_path=1) %>% 
  dplyr::mutate(
    study_site = validation_file_full_path %>% 
      toupper() %>% 
      stringr::str_extract(pattern = paste(study_site_list, collapse = "|"))
  ) %>% 
  dplyr::filter(study_site %in% study_site_list) %>% 
  dplyr::group_by(study_site) %>% 
  dplyr::filter(dplyr::row_number() == 1) %>% 
  dplyr::ungroup()

# what about the field plot boundary?
validation_plots = sf::st_read("../data/field_validation/Field_Data_Boundary.shp") %>% 
  dplyr::rename_with(tolower) %>% 
  dplyr::mutate(
    study_site = site %>% 
      toupper() %>% 
      stringr::str_extract(pattern = paste(study_site_list, collapse = "|"))
  ) %>% 
  dplyr::filter(study_site %in% study_site_list) %>% 
  dplyr::group_by(study_site) %>% 
  dplyr::filter(dplyr::row_number() == 1) %>% 
  dplyr::ungroup() %>% 
  dplyr::mutate(
    area_ha = sf::st_area(.) %>% as.numeric() %>% `/`(10000)
    , area_acres = area_ha*2.471
  )

# where is the uas processed data?
ptcld_processing_data =
  ptcld_processing_data %>% 
  dplyr::mutate(
    processed_data_dir = dirname(tracking_file_full_path)
    , processing_id = dplyr::row_number()
  )
```

where are these validation plots and what do they look like?

```{r}
# what?
validation_plots %>% dplyr::glimpse()
# where?
mapview::mapviewOptions(basemaps = c("OpenStreetMap","Esri.WorldImagery"))
validation_plots %>% 
  sf::st_buffer(2000) %>% # because they are small
  mapview::mapview(col.regions = "blue", layer.name = "plot", alpha.regions = 0.7)
```

create a function to calculate the basal area of a tree in m^2^ from DBH measured in cm

```{r}
calc_ba_m2_from_dbh_cm = function(dbh_cm){
  return(
    pi * dbh_cm^2 / (4*10000)
  )
}
```

## Data Load Functions

field validation data

```{r}
# function to read field data once per site
read_field_data <- function(my_study_site) {
  d = sf::st_read(
    validation_data %>% 
      dplyr::filter(study_site == my_study_site) %>% 
      dplyr::pull(validation_file_full_path)
    ) %>% 
    dplyr::mutate(
      study_site = my_study_site
    ) %>% 
    dplyr::rename_with(tolower) %>% 
    dplyr::rename(
      field_dbh_cm = dbh_cm
      , field_tree_height_m = ht_m
    ) %>% 
    sf::st_set_geometry("geometry") %>% 
    dplyr::filter(
      !is.na(field_dbh_cm)
      & !is.na(field_tree_height_m)
      & sf::st_is_valid(geometry)
      # only keep trees that are above height threshold used for uas processing
      & field_tree_height_m >= min(ptcld_processing_data$sttng_minimum_tree_height_m)
      # & field_dbh_cm >= min_tree_dbh_cm # if know min field dbh for field sampling
    )
  # keep only trees within sampling plot
  d %>% 
    sf::st_intersection(
      validation_plots %>% 
        dplyr::filter(study_site == my_study_site) %>% 
        dplyr::mutate(intersected_with_plot_geom = T) %>% 
        dplyr::select(intersected_with_plot_geom) %>% 
        sf::st_transform(sf::st_crs(d))
    ) %>% 
    dplyr::mutate(
      field_tree_id = dplyr::row_number()
      , tree_utm_x = sf::st_coordinates(geometry)[,1] #lon
      , tree_utm_y = sf::st_coordinates(geometry)[,2] #lat
      # basal area
      , basal_area_m2 = calc_ba_m2_from_dbh_cm(field_dbh_cm)
    ) %>% 
    dplyr::relocate(field_tree_id)
    
}
```

### Summary of field validation plot data

```{r, results='hide', warning=FALSE, message=FALSE}
table_temp = validation_plots %>% 
  dplyr::pull(study_site) %>% 
  purrr::map(function(x){
    read_field_data(x) %>% 
      sf::st_drop_geometry() %>% 
      dplyr::select(study_site,field_dbh_cm,field_tree_height_m,basal_area_m2)
  }) %>% 
  dplyr::bind_rows() %>% 
  dplyr::group_by(study_site) %>% 
  dplyr::summarise(
    dplyr::across(
      tidyselect::starts_with("field_")
      , .fns = list(mean = mean, sd = sd)
    )
    , n_trees = dplyr::n()
    , basal_area_m2 = sum(basal_area_m2)
  ) %>% 
  # add area
  dplyr::inner_join(
    validation_plots %>% dplyr::select(study_site, area_ha) %>% sf::st_drop_geometry()
    , by = "study_site"
  ) %>% 
  dplyr::mutate(
    ht = paste0(
      field_tree_height_m_mean %>% 
        round(1) %>% 
        scales::comma(accuracy = 0.1)
      , "<br>("
      , field_tree_height_m_sd %>% 
          round(1) %>% 
          scales::comma(accuracy = 0.1)
      , ")"
    )
    , dbh = paste0(
      field_dbh_cm_mean %>% round(1) %>% scales::comma(accuracy = 0.1)
      , "<br>("
      , field_dbh_cm_sd %>% round(1) %>% scales::comma(accuracy = 0.1)
      , ")"
    )
    , trees_ha = n_trees/area_ha
    , basal_area_m2_per_ha = basal_area_m2/area_ha
    , area_ha = area_ha %>% round(1) %>% scales::comma(accuracy = 0.1)
  ) %>% 
  dplyr::select(
    study_site, area_ha, trees_ha, basal_area_m2_per_ha, ht, dbh
  )
```

```{r, results='asis'}
table_temp %>% 
  kableExtra::kbl(
    escape = F
    , digits = 1
    , col.names = c(
      ""
      , "Hectares"
      , "Trees<br>ha<sup>-1</sup>"
      , "Basal Area<br>m<sup>2</sup> ha<sup>-1</sup>"
      , "Height (m)", "DBH (cm)"
    )
  ) %>% 
  kableExtra::kable_styling()
```

### Load UAS data function

```{r}
# function finds uas tree list
# reads it
# estimates linear model if not already used for DBH
read_uas_data = function(my_processing_id, my_crs = NULL, use_this_dbh = my_dbh_estimate) {
  # where is this file?
  fnm = ptcld_processing_data %>% 
    dplyr::filter(
      processing_id == my_processing_id
    ) %>% 
    dplyr::mutate(
      fnm = paste0(
        processed_data_dir
        , "/"
        , file_name
        , "_final_detected_tree_tops.gpkg"
      )
    ) %>% 
    dplyr::pull(fnm)
  
  if(file.exists(fnm)){
    # read it
    dta = sf::st_read(fnm) %>% 
      dplyr::mutate(
        processing_id = my_processing_id
      ) %>% 
      dplyr::rename_with(tolower) %>% 
      sf::st_set_geometry("geometry")
    
    # transform
    if(is.null(my_crs)){
      tcrs = sf::st_crs(dta)
    }else{tcrs = my_crs}
    
    dta = dta %>% 
      sf::st_transform(tcrs)
    
    #################
    # estimate linear model if not already used for DBH
    #################
    if(
      # is there sufficient training data?
      dta %>% 
        dplyr::filter(is_training_data == T) %>% 
        nrow() > 10 & 
      # was rf model used?
      ptcld_processing_data %>% 
        dplyr::filter(processing_id == my_processing_id) %>% 
        dplyr::pull(sttng_local_dbh_model) %>% 
        tolower() == "rf"
    ){
        # Gamma distribution for strictly positive response variable dbh
          # !!!! fit with intercept 
        stem_prediction_model = brms::brm(
          formula = dbh_cm ~ 1 + tree_height_m
          , data = dta %>%
              dplyr::filter(is_training_data==T) %>% 
              dplyr::select(dbh_cm, tree_height_m)
          , family = brms::brmsfamily("Gamma", link = "log")
          , prior = c(prior(gamma(0.01, 0.01), class = shape))
          , iter = 4000, warmup = 2000, chains = 4
          , cores = lasR::half_cores()
          , file = ptcld_processing_data %>%
              dplyr::filter(processing_id == my_processing_id) %>%
              dplyr::mutate(
                fff = paste0(
                  processed_data_dir
                  , "/"
                  , file_name
                  , "_local_dbh_height_model"
                )
              ) %>%
              dplyr::pull(fff)
          # , file_refit = "on_change"
        )
        
        # Gamma distribution for strictly positive response variable dbh
          # !!!! fit with NO intercept 
        stem_prediction_noint_model = brms::brm(
          formula = dbh_cm ~ 0 + tree_height_m
          , data = dta %>%
              dplyr::filter(is_training_data==T) %>% 
              dplyr::select(dbh_cm, tree_height_m)
          , family = brms::brmsfamily("Gamma", link = "log")
          , prior = c(prior(gamma(0.01, 0.01), class = shape))
          , iter = 4000, warmup = 2000, chains = 4
          , cores = lasR::half_cores()
          , file = ptcld_processing_data %>%
              dplyr::filter(processing_id == my_processing_id) %>%
              dplyr::mutate(
                fff = paste0(
                  processed_data_dir
                  , "/"
                  , file_name
                  , "_local_dbh_height_noint_model"
                )
              ) %>%
              dplyr::pull(fff)
          # , file_refit = "on_change"
        )
      #################
      # prediction data
      #################
        pred_temp = predict(stem_prediction_model, dta) %>% 
          dplyr::as_tibble() %>% 
          dplyr::pull(1)
        
        pred_noint_temp = predict(stem_prediction_noint_model, dta) %>% 
          dplyr::as_tibble() %>% 
          dplyr::pull(1)
        
        # add to data
        dta = dta %>% 
          dplyr::mutate(
            rf_dbh_cm = dbh_cm
            , pred_dbh_cm = pred_temp
            , pred_noint_dbh_cm = pred_noint_temp
            , lin_dbh_cm = ifelse(is_training_data==T, dbh_cm, pred_dbh_cm)
            , lin_noint_dbh_cm = ifelse(is_training_data==T, dbh_cm, pred_noint_dbh_cm)
          ) %>% 
          dplyr::select(-c(pred_dbh_cm,pred_noint_dbh_cm))
    }else if(# is there sufficient training data?
      dta %>% 
        dplyr::filter(is_training_data == T) %>% 
        nrow() <= 10
    ){
      # the regional model was used which would result in the same est for rf and lin
      dta = dta %>% 
        dplyr::mutate(
          rf_dbh_cm = dbh_cm
          , lin_dbh_cm = dbh_cm
          , lin_noint_dbh_cm = dbh_cm
        )
    }else{
      # linear model was already used and no rf pred
      # could update this to estimate rf model if missing...#nextyear
      dta = dta %>% 
        dplyr::mutate(
          rf_dbh_cm = as.numeric(NA)
          , lin_dbh_cm = dbh_cm
          , lin_noint_dbh_cm = as.numeric(NA)
        )
    }
    # return with dbh updated
    return(
      dta %>% 
        dplyr::mutate(
          dbh_cm = dplyr::case_when(
          # update dbh to selected
          tolower(use_this_dbh) == "rf" & !is.na(rf_dbh_cm) ~ rf_dbh_cm
          , tolower(use_this_dbh) == "lin" & !is.na(lin_dbh_cm) ~ lin_dbh_cm
          , tolower(use_this_dbh) == "lin_noint" & !is.na(lin_noint_dbh_cm) ~ lin_noint_dbh_cm
          , tolower(use_this_dbh) == "regional" & !is.na(reg_est_dbh_cm) ~ reg_est_dbh_cm
          , T ~ reg_est_dbh_cm
        )) %>% 
        dplyr::mutate(
          basal_area_m2 = calc_ba_m2_from_dbh_cm(dbh_cm)
          , basal_area_ft2 = basal_area_m2 * 10.764
        )
        
    )
  }else{stop("could not find file: ", fnm)}
}
```

```{r, include=FALSE, eval=FALSE}
dta = read_uas_data(1)
dta %>% 
  ggplot(aes(x = tree_height_m, y = lin_dbh_cm, color = is_training_data)) + 
    geom_point(aes(y = reg_est_dbh_cm,color = "zz regional_est")) +
    geom_point(aes(y = rf_dbh_cm,color = "zz rf est")) +
    geom_point() + 
    labs(color = "lm est + training", x = "ht m", y = "dbh cm") +
    scale_color_viridis_d(option = "turbo") +
    scale_x_continuous(breaks = scales::extended_breaks(18)) +
    scale_y_continuous(breaks = scales::extended_breaks(16)) +
    theme_light() +
    theme(legend.position = "top") +
    guides(
      color = guide_legend(override.aes = list(size = 5))
    )
```

## Validation Data Functions

### True Positive Identification

The UAS detected and stem-mapped tree pairs identified in this filtering process (detailed above) were considered true positive ($TP$) detections.

```{r, results='hide'}
## BUFFER THE UAS TREES AND SPATIALLY MATCH FIELD TREES BASED ON THAT BUFFER
true_positive_trees_fn = function(uas_data, field_data, max_dist_m = 3, max_height_error_m = 2){
  ## get FIELD trees within radius OF UAS TREES
    potential_tree_pairs_temp = uas_data %>% 
      dplyr::select(treeid, tree_height_m) %>% 
      # buffer point
      sf::st_buffer(max_dist_m) %>% 
      # spatial join with all FIELD tree points
      sf::st_join(
        field_data %>% 
          dplyr::select(
            field_tree_id, field_tree_height_m
            , tree_utm_x, tree_utm_y
          )
        , join = sf::st_intersects
        , left = F # performs inner join to only keep uas trees with a match
      ) %>% 
      # calculate height difference
      dplyr::mutate(
        height_diff_m = abs(tree_height_m-field_tree_height_m)
        , height_diff_pct = height_diff_m/field_tree_height_m
      ) %>% 
      # removes tree pairs that are outside of the allowable error
      # dplyr::filter(height_diff_pct <= max_height_error_pct) %>% 
      dplyr::filter(height_diff_m <= max_height_error_m) %>% 
      dplyr::select(-c(height_diff_m)) %>% 
      dplyr::relocate(treeid, field_tree_id)
  
  ## apply pair selection criteria if there are potential tree pairs
    if(nrow(potential_tree_pairs_temp)>0){
      ## calculate row by row distances and height differences
        potential_tree_pairs_temp = potential_tree_pairs_temp %>% 
          # this is the position of the uas tree
          sf::st_centroid() %>% 
          sf::st_set_geometry("geom1") %>% 
          dplyr::bind_cols(
            potential_tree_pairs_temp %>% 
              sf::st_drop_geometry() %>% 
              dplyr::select("tree_utm_x", "tree_utm_y") %>% 
              # this is the position of the field tree
              sf::st_as_sf(
                coords = c("tree_utm_x", "tree_utm_y"), crs = sf::st_crs(uas_data)
              ) %>% 
              sf::st_set_geometry("geom2")
          ) %>% 
          dplyr::mutate(
            distance_m = sf::st_distance(geom1, geom2, by_element = T) %>% as.numeric()
          ) %>% 
          sf::st_drop_geometry() %>% 
          dplyr::select(-c(tree_utm_x, tree_utm_y, geom2))
      
      ## define function to select the best tree pair
        select_best_tree_pair_fn <- function(df) {
         df %>% 
          dplyr::group_by(field_tree_id) %>% 
          dplyr::arrange(field_tree_id, height_diff_pct, distance_m, desc(tree_height_m), treeid) %>% 
          dplyr::mutate(
            # at the field tree level...the number of uas trees
            n_uas_trees = dplyr::n()
            # at the field tree level...
              # the closest uas tree in height tie breaker distance, uas_tree_height_m, id
            , rank_within_field_tree = dplyr::row_number()
          ) %>% 
          dplyr::group_by(treeid) %>% 
          dplyr::arrange(treeid, height_diff_pct, distance_m, desc(field_tree_height_m), field_tree_id) %>% 
          dplyr::mutate(
            # at the uas tree level...the number of field trees
            n_field_trees = dplyr::n()
            # at the field tree level...
              # the closest field tree in height tie breaker distance, uas_tree_height_m, id
            , rank_within_uas_tree = dplyr::row_number()
          ) %>% 
          dplyr::ungroup() %>% 
          # select the uas-field tree pair with the minimum height difference
          dplyr::filter(
            rank_within_field_tree == 1
            & rank_within_uas_tree == 1
          ) %>% 
          # remove columns
          dplyr::select(
            -c(tidyselect::starts_with("rank_"), tidyselect::starts_with("n_"))
          )
        }
      
      ## first filter for tree pairs
        true_positive_trees = select_best_tree_pair_fn(potential_tree_pairs_temp)
      
      ##remove matches from potential tree pairs 
        potential_tree_pairs_temp = potential_tree_pairs_temp %>% 
          dplyr::filter(
            !(treeid %in% true_positive_trees$treeid)
            & !(field_tree_id %in% true_positive_trees$field_tree_id)
          )
        
      ## keep filtering for best pair until no unique pairs remain
        while(nrow(potential_tree_pairs_temp)>0) {
          # keep filtering for best pair until no unique pairs remain
          true_positive_trees = true_positive_trees %>% 
            dplyr::bind_rows(
              select_best_tree_pair_fn(potential_tree_pairs_temp)
            )
          #remove matches from potential tree pairs 
          potential_tree_pairs_temp = potential_tree_pairs_temp %>% 
            dplyr::filter(
              !(treeid %in% true_positive_trees$treeid)
              & !(field_tree_id %in% true_positive_trees$field_tree_id)
            )
        }
      ## rename columns and flag
        true_positive_trees = true_positive_trees %>% 
          dplyr::rename(
            uas_tree_height_m = tree_height_m
            , uas_tree_id = treeid
            , field_uas_distance_m = distance_m
          ) %>% 
          dplyr::mutate(
            field_uas_group = "true positive"
          ) 
    }else{ # if there are spatially matched trees
      true_positive_trees = dplyr::tibble(
        uas_tree_id = as.character(NA)
        , field_tree_id = as.character(NA)
        , uas_tree_height_m = as.numeric(NA)
        , field_tree_height_m = as.numeric(NA)
        , height_diff_pct = as.numeric(NA)
        , field_uas_distance_m = as.numeric(NA)
        , field_uas_group = as.character(NA)
      )
    }
  # return
    return(true_positive_trees)
}
```

### Combine with Commission and Omission

To determine UAS detected tree commissions (i.e. UAS detected trees within the overstory plot for which there was no stem-mapped tree pair; $Co$) this analysis used the 2023-06 BHEF overstory field survey plot center and plot radius of 11.35 m. UAS detected trees within this radius with an [estimated DBH](#local_mod) over 5 in (12.69 cm) that did not have a matched stem-mapped tree pair were considered commissions ($Co$).

Omissions ($Om$) are stem-mapped trees without a UAS detected tree match.

```{r, results='hide'}
field_uas_comparison_fn = function(uas_data, field_data, true_positive_trees, plot_data, overstory_ht_m = 7){
  field_uas_comparison = dplyr::bind_rows(
    ## true positive
      true_positive_trees %>% 
         dplyr::mutate(field_tree_id = as.numeric(field_tree_id))
    ## omission
      , field_data %>% 
        sf::st_drop_geometry() %>% 
        dplyr::select(
          field_tree_id, field_tree_height_m
        ) %>% 
        dplyr::anti_join(
          true_positive_trees %>% 
            dplyr::mutate(field_tree_id = as.numeric(field_tree_id))
          , by = dplyr::join_by(field_tree_id)
        ) %>% 
        dplyr::mutate(
          field_uas_group = "omission"
        )
    ## commission
      , plot_data %>% 
        sf::st_transform(sf::st_crs(uas_data)) %>% 
        dplyr::select(study_site) %>% 
        # join with uas tree points
        sf::st_join(
          uas_data %>% 
            dplyr::filter(
              !treeid %in% true_positive_trees$uas_tree_id
            ) %>% 
            dplyr::select(treeid) %>% 
            dplyr::rename(uas_tree_id=treeid)
          , join = sf::st_intersects
          , left = F # performs inner join to only keep uas trees and plots with a match
        ) %>% 
        dplyr::select(-c(study_site)) %>% 
        sf::st_drop_geometry() %>% 
        dplyr::mutate(
          field_uas_group = "commission"
        )
  ) %>% 
  dplyr::filter(!is.na(field_uas_group) & field_uas_group!="") %>% 
    # attach uas data
    dplyr::left_join(
      uas_data %>%
        sf::st_set_geometry("geometry") %>% 
        dplyr::mutate(
          uas_tree_utm_x = sf::st_coordinates(geometry)[,1] #lon
          , uas_tree_utm_y = sf::st_coordinates(geometry)[,2] #lat
        ) %>% 
        sf::st_drop_geometry() %>% 
        dplyr::select(treeid, tree_height_m, dbh_cm, basal_area_m2, uas_tree_utm_x, uas_tree_utm_y) %>% 
        dplyr::rename(
          uas_tree_id = treeid
          , uas_tree_height_m = tree_height_m
          , uas_dbh_cm = dbh_cm
          , uas_basal_area_m2 = basal_area_m2
        )
      , by = dplyr::join_by(uas_tree_id)
    ) %>% 
    # attach field data
    dplyr::left_join(
      field_data %>% 
        sf::st_drop_geometry() %>% 
        dplyr::select(
          field_tree_id, field_tree_height_m, field_dbh_cm, basal_area_m2
          , tree_utm_x, tree_utm_y
        ) %>% 
        dplyr::rename(
          field_basal_area_m2 = basal_area_m2
          , field_tree_utm_x = tree_utm_x
          , field_tree_utm_y = tree_utm_y
        )
      , by = dplyr::join_by(field_tree_id)
    ) %>% 
    # update data
    dplyr::mutate(
      uas_tree_height_m = uas_tree_height_m.y
      , field_tree_height_m = field_tree_height_m.y
      , field_uas_group = factor(
        field_uas_group
        , ordered = T
        , levels = c(
          "true positive"
          , "commission"
          , "omission"
        )
      ) %>% forcats::fct_rev()
      , dbh_diff_cm = uas_dbh_cm - field_dbh_cm
      , tree_height_diff_m = uas_tree_height_m - field_tree_height_m
      , dbh_diff_pct = dbh_diff_cm/field_dbh_cm
      , height_diff_pct = tree_height_diff_m/field_tree_height_m
      , abs_dbh_diff_pct = abs(dbh_diff_pct)
      , abs_height_diff_pct = abs(height_diff_pct)
      # determine overstory/understory
      , overstory_understory_grp = dplyr::case_when(
        dplyr::coalesce(field_tree_height_m, uas_tree_height_m) >= overstory_ht_m ~ "overstory"
        , dplyr::coalesce(field_tree_height_m, uas_tree_height_m) < overstory_ht_m ~ "understory"
        , T ~ "error"
      ) %>% factor()
      # attach identifying data
      , study_site = uas_data$study_site[1]
      , file_name = uas_data$file_name[1]
      , software = uas_data$software[1]
      , overstory_ht_m = overstory_ht_m
    ) %>% 
    dplyr::relocate(field_uas_group) %>% 
    dplyr::select(-c(tidyselect::ends_with(".x"), tidyselect::ends_with(".y")))
    # # convert to imperial units
    # calc_imperial_units_fn()
  # return
  return(field_uas_comparison)
}
```

```{r, eval=FALSE, include=FALSE}
xxx = field_uas_comparison_fn(
  uas_data = read_uas_data(
    my_processing_id = ptcld_processing_data %>% 
      dplyr::filter(study_site == study_site_list[1]) %>% 
      dplyr::pull(processing_id) %>% 
      .[1]
    , my_crs = read_field_data(my_study_site = study_site_list[1]) %>% sf::st_crs()
  )
  , field_data = read_field_data(my_study_site = study_site_list[1])
  , true_positive_trees = 
      true_positive_trees_fn(
        uas_data = read_uas_data(
          my_processing_id = ptcld_processing_data %>% 
            dplyr::filter(study_site == study_site_list[1]) %>% 
            dplyr::pull(processing_id) %>% 
            .[1]
          , my_crs = read_field_data(my_study_site = study_site_list[1]) %>% sf::st_crs()
        )
        , field_data = read_field_data(my_study_site = study_site_list[1])
      )
  , plot_data = validation_plots %>% dplyr::filter(study_site == study_site_list[1])
) 
xxx %>% dplyr::glimpse()
xxx %>% sf::st_drop_geometry() %>% View()
# basal area sum
xxx %>% 
  dplyr::group_by(overstory_understory_grp) %>% 
  dplyr::summarise(
    ba_uas = sum(uas_basal_area_m2, na.rm = T)
    , ba_field = sum(field_basal_area_m2, na.rm = T)
  )
remove(xxx)
gc()
```

### Full validation function

function to write comparison data and return aggregate metrics when passed a `ptcld_processing_data$processing_id`

function returns:

1) write full validation tree list to disk
2) update ptcld_processing_data with metrics for testing:
  * f-score
  * height comparison metrics (mae, mape, smape, mse, rmse)
  * dbh comparison metrics (mae, mape, smape, mse, rmse)
  * path to full validation tree list written to disk

```{r}
#####################################################
# function to map over each file for a particular study site
#####################################################
  # function for a file name identified by processing_id in ptcld_processing_data
  validate_file_fn = function(p_id, fld_dta, plt_dta){
    # tree list file name
      tl_fnm = paste0(
          ptcld_processing_data %>% 
            dplyr::filter(processing_id == p_id) %>% 
            dplyr::pull(processed_data_dir)
          , "/"
          , ptcld_processing_data %>% 
            dplyr::filter(processing_id == p_id) %>% 
            dplyr::pull(file_name)
          , "_field_uas_comparison_data.csv"
        )
    # brms model
      brms_fnm = paste0(
          ptcld_processing_data %>% 
            dplyr::filter(processing_id == p_id) %>% 
            dplyr::pull(processed_data_dir)
          , "/"
          , ptcld_processing_data %>% 
            dplyr::filter(processing_id == p_id) %>% 
            dplyr::pull(file_name)
          , "_local_dbh_height_model.rds"
        )
    # brms model noint
      brms_noint_fnm = paste0(
          ptcld_processing_data %>% 
            dplyr::filter(processing_id == p_id) %>% 
            dplyr::pull(processed_data_dir)
          , "/"
          , ptcld_processing_data %>% 
            dplyr::filter(processing_id == p_id) %>% 
            dplyr::pull(file_name)
          , "_local_dbh_height_noint_model.rds"
        )
    # check it
    if(file.exists(tl_fnm) & file.exists(brms_fnm) & file.exists(brms_noint_fnm)){
      # read it
      field_uas_comparison = readr::read_csv(tl_fnm)
    }else{
      # uas_data
        u_dta = read_uas_data(
          my_processing_id = p_id
          , my_crs = sf::st_crs(fld_dta)
        )
      # true positives
        tp_trees = true_positive_trees_fn(uas_data = u_dta, field_data = fld_dta)
      # field uas comparison
        field_uas_comparison = field_uas_comparison_fn(
            uas_data = u_dta
            , field_data = fld_dta
            , true_positive_trees = tp_trees
            , plot_data = plt_dta
          ) %>% 
          # attach id information
          dplyr::bind_cols(
            ptcld_processing_data %>% 
              dplyr::filter(processing_id == p_id) %>% 
              dplyr::select(
                processing_id, study_site, file_name, software
                , depth_maps_generation_quality
                , depth_maps_generation_filtering_mode
                , processing_attribute3
                , processed_data_dir
              )
          )
        # write it
        write.csv(
          field_uas_comparison
          , tl_fnm
          , row.names = F
        )
    }
    ############################################
    # aggregate field_uas_comparison for return
    ############################################
      # get plot area from plot data
      plot_area_ha = plt_dta$area_ha[1]
      # this is the return data which has lots of columns
      return_dta =
        ptcld_processing_data %>% 
        dplyr::filter(processing_id == p_id) %>%
        ############################################
        # overall statistics
        ############################################
        # attach f score
        dplyr::bind_cols(
          # blank data in case missing
          dplyr::tibble(field_uas_group = c("tp", "co", "om")) %>% 
          dplyr::left_join(
            field_uas_comparison %>% 
              dplyr::count(field_uas_group) %>% 
              dplyr::mutate(field_uas_group = dplyr::case_when(
                field_uas_group == "true positive" ~ "tp"
                , field_uas_group == "commission" ~ "co"
                , field_uas_group == "omission" ~ "om"
              ))
            , by = dplyr::join_by(field_uas_group)
          ) %>% 
          dplyr::mutate(n = ifelse(is.na(n),0,n)) %>% 
            tidyr::pivot_wider(
              names_from = field_uas_group
              , values_from = n
              , values_fill = 0
            ) %>% 
            dplyr::mutate(
              f_score = dplyr::coalesce(
                2 * ( (tp/(tp+om)) * (tp/(tp+co)) ) / ( (tp/(tp+om)) + (tp/(tp+co)) )
                , 0
              )
            ) %>% 
            dplyr::rename(
              true_positive_n_trees = tp
              , commission_n_trees = co
              , omission_n_trees = om
            ) %>% 
            dplyr::ungroup()
        ) %>% 
        # attach summary error metrics
        dplyr::bind_cols(
          field_uas_comparison %>% 
            dplyr::filter(field_uas_group=="true positive") %>% 
            dplyr::ungroup() %>% 
            # thx Metrics pkg!!
            dplyr::summarise(
              # tree_height_m
              tree_height_m_me = mean(uas_tree_height_m-field_tree_height_m, na.rm = T)
              , tree_height_m_mpe = mean((uas_tree_height_m-field_tree_height_m)/field_tree_height_m, na.rm = T)
              , tree_height_m_mae = Metrics::mae(field_tree_height_m, uas_tree_height_m)
              , tree_height_m_mape = Metrics::mape(field_tree_height_m, uas_tree_height_m)
              , tree_height_m_smape = Metrics::smape(field_tree_height_m, uas_tree_height_m)
              , tree_height_m_mse = Metrics::mse(field_tree_height_m, uas_tree_height_m)
              , tree_height_m_rmse = Metrics::rmse(field_tree_height_m, uas_tree_height_m)
              # dbh_cm
              , dbh_cm_me = mean(uas_dbh_cm-field_dbh_cm, na.rm = T)
              , dbh_cm_mpe = mean((uas_dbh_cm-field_dbh_cm)/field_dbh_cm, na.rm = T)
              , dbh_cm_mae = Metrics::mae(field_dbh_cm, uas_dbh_cm)
              , dbh_cm_mape = Metrics::mape(field_dbh_cm, uas_dbh_cm)
              , dbh_cm_smape = Metrics::smape(field_dbh_cm, uas_dbh_cm)
              , dbh_cm_mse = Metrics::mse(field_dbh_cm, uas_dbh_cm)
              , dbh_cm_rmse = Metrics::rmse(field_dbh_cm, uas_dbh_cm)
            )
        ) %>% 
        # attach basal area
        dplyr::bind_cols(
          field_uas_comparison %>% 
            dplyr::ungroup() %>% 
            dplyr::summarise(
              uas_basal_area_m2 = sum(uas_basal_area_m2, na.rm = T)
              , field_basal_area_m2 = sum(field_basal_area_m2, na.rm = T)
            ) %>% 
            # ba/ha and error
            dplyr::mutate(
              uas_basal_area_m2_per_ha = uas_basal_area_m2/plot_area_ha
              , field_basal_area_m2_per_ha = field_basal_area_m2/plot_area_ha
              # error
              , basal_area_m2_error = uas_basal_area_m2-field_basal_area_m2
              , basal_area_m2_per_ha_error = uas_basal_area_m2_per_ha-field_basal_area_m2_per_ha
              , basal_area_pct_error = (uas_basal_area_m2-field_basal_area_m2)/field_basal_area_m2
              , basal_area_abs_pct_error = abs(basal_area_pct_error)
            )
        ) %>% 
        ############################################
        # overstory/understory statistics
        ############################################
        # attach f score
        dplyr::bind_cols(
          # blank data in case missing
          tidyr::crossing(
            field_uas_group = c("tp", "co", "om")
            , overstory_understory_grp = c("overstory", "understory")
          ) %>% 
          dplyr::left_join(
            field_uas_comparison %>% 
              dplyr::count(field_uas_group, overstory_understory_grp) %>% 
              dplyr::mutate(field_uas_group = dplyr::case_when(
                field_uas_group == "true positive" ~ "tp"
                , field_uas_group == "commission" ~ "co"
                , field_uas_group == "omission" ~ "om"
              ))
            , by = dplyr::join_by(field_uas_group, overstory_understory_grp)
          ) %>% 
          dplyr::mutate(n = ifelse(is.na(n),0,n)) %>% 
            tidyr::pivot_wider(
              names_from = field_uas_group
              , values_from = n
              , values_fill = 0
            ) %>% 
            dplyr::mutate(
              f_score = dplyr::coalesce(
                2 * ( (tp/(tp+om)) * (tp/(tp+co)) ) / ( (tp/(tp+om)) + (tp/(tp+co)) )
                , 0
              )
            ) %>% 
            dplyr::rename(
              true_positive_n_trees = tp
              , commission_n_trees = co
              , omission_n_trees = om
            ) %>% 
            dplyr::ungroup() %>% 
            tidyr::pivot_wider(
              names_from = overstory_understory_grp
              , values_from = -c(overstory_understory_grp)
              , values_fill = 0
              , names_glue = "{overstory_understory_grp}_{.value}"
            )
        ) %>% 
        # attach summary error metrics
        dplyr::bind_cols(
          tidyr::crossing(
              field_uas_group = c("true positive")
              , overstory_understory_grp = c("overstory","understory")
            ) %>% 
          dplyr::left_join(
              field_uas_comparison %>%
                dplyr::mutate(overstory_understory_grp=as.character(overstory_understory_grp))
              , by = dplyr::join_by("field_uas_group", "overstory_understory_grp")
            ) %>% 
            dplyr::group_by(overstory_understory_grp) %>% 
            # thx Metrics pkg!!
            dplyr::summarise(
              # tree_height_m
              tree_height_m_me = mean(uas_tree_height_m-field_tree_height_m, na.rm = T)
              , tree_height_m_mpe = mean((uas_tree_height_m-field_tree_height_m)/field_tree_height_m, na.rm = T)
              , tree_height_m_mae = Metrics::mae(field_tree_height_m, uas_tree_height_m)
              , tree_height_m_mape = Metrics::mape(field_tree_height_m, uas_tree_height_m)
              , tree_height_m_smape = Metrics::smape(field_tree_height_m, uas_tree_height_m)
              , tree_height_m_mse = Metrics::mse(field_tree_height_m, uas_tree_height_m)
              , tree_height_m_rmse = Metrics::rmse(field_tree_height_m, uas_tree_height_m)
              # dbh_cm
              , dbh_cm_me = mean(uas_dbh_cm-field_dbh_cm, na.rm = T)
              , dbh_cm_mpe = mean((uas_dbh_cm-field_dbh_cm)/field_dbh_cm, na.rm = T)
              , dbh_cm_mae = Metrics::mae(field_dbh_cm, uas_dbh_cm)
              , dbh_cm_mape = Metrics::mape(field_dbh_cm, uas_dbh_cm)
              , dbh_cm_smape = Metrics::smape(field_dbh_cm, uas_dbh_cm)
              , dbh_cm_mse = Metrics::mse(field_dbh_cm, uas_dbh_cm)
              , dbh_cm_rmse = Metrics::rmse(field_dbh_cm, uas_dbh_cm)
            ) %>% 
            dplyr::ungroup() %>% 
            tidyr::pivot_wider(
              names_from = overstory_understory_grp
              , values_from = -c(overstory_understory_grp)
              , values_fill = 0
              , names_glue = "{overstory_understory_grp}_{.value}"
            )
        ) %>% 
        # attach basal area
        dplyr::bind_cols(
          dplyr::tibble(
            overstory_understory_grp = c("overstory","understory")
          ) %>% 
          dplyr::left_join(
            field_uas_comparison %>% 
              dplyr::group_by(overstory_understory_grp) %>% 
              dplyr::summarise(
                uas_basal_area_m2 = sum(uas_basal_area_m2, na.rm = T)
                , field_basal_area_m2 = sum(field_basal_area_m2, na.rm = T)
              ) %>% 
              dplyr::ungroup() %>% 
              # ba/ha and error
              dplyr::mutate(
                uas_basal_area_m2_per_ha = uas_basal_area_m2/plot_area_ha
                , field_basal_area_m2_per_ha = field_basal_area_m2/plot_area_ha
                # error
                , basal_area_m2_per_ha_error = uas_basal_area_m2_per_ha-field_basal_area_m2_per_ha
                , basal_area_pct_error = (uas_basal_area_m2_per_ha-field_basal_area_m2_per_ha)/field_basal_area_m2_per_ha
                , basal_area_abs_pct_error = abs(basal_area_pct_error)
              )
            , by = dplyr::join_by("overstory_understory_grp")
          ) %>% 
          tidyr::pivot_wider(
            names_from = overstory_understory_grp
            , values_from = -c(overstory_understory_grp)
            , values_fill = 0
            , names_glue = "{overstory_understory_grp}_{.value}"
          )
        ) %>% 
        # where is the tree list ?
        dplyr::mutate(
          validation_file_full_path = tl_fnm
          # what is this overstory/understory?
          , overstory_ht_m = field_uas_comparison$overstory_ht_m[1]
        )
      
    # return
      return(return_dta)
  }
```

check validation function

```{r, results='hide'}
validation_temp = 
  validate_file_fn(
    p_id = ptcld_processing_data %>% 
      dplyr::filter(study_site == study_site_list[1]) %>% 
      dplyr::pull(processing_id) %>% 
      .[1]
    , fld_dta = read_field_data(study_site_list[1])
    , plt_dta = validation_plots %>% 
      dplyr::filter(study_site == study_site_list[1])
  )
```

```{r}
# what? 
validation_temp %>% dplyr::glimpse()
# output file is the same thing as field_uas_comparison_fn
validation_temp$validation_file_full_path %>% 
  readr::read_csv() %>% 
  dplyr::glimpse()
```

## Full pipeline function

function to map over study sites represented in `ptcld_processing_data`

```{r}
# function to map over study sites represented in ptcld_processing_data
# set up in a way so that only have to read field data from disk once and 
# perform validation for each uas data represented for that site in ptcld_processing_data
# Returns:
# 1) write full validation tree list to disk
# 2) update ptcld_processing_data with metrics for testing:
  # f-score
  # ht rmse
  # dbh rmse
  # path to validation tree list
full_validation_fn = function(study_site_nm) {
  # filter plot data
    validation_plot = validation_plots %>% 
      dplyr::filter(study_site == study_site_nm)
  # read field data
    field_data = read_field_data(study_site_nm)
  # # map over file validation function and return data
    # function for a file name identified by processing_id in ptcld_processing_data
    d = ptcld_processing_data %>% 
      dplyr::filter(study_site == study_site_nm) %>% 
      dplyr::pull(processing_id) %>% 
      purrr::map(validate_file_fn, fld_dta = field_data, plt_dta = validation_plot) %>% 
      dplyr::bind_rows()
  # return
    return(d)
}
```

## Apply validation for all

```{r, results='hide', message=FALSE, warning=FALSE}
ptcld_validation_data = 
  study_site_list %>% 
    purrr::map(full_validation_fn) %>% 
    dplyr::bind_rows()
# write this!
write.csv(
    ptcld_validation_data
    , "../data/ptcld_full_analysis_data.csv"
    , row.names = F
  )
```

what is this validation data?

```{r, include=FALSE, eval=TRUE}
# load data if needed
if(ls()[ls() %in% "ptcld_validation_data"] %>% length()==0){
 ptcld_validation_data = readr::read_csv("../data/ptcld_full_analysis_data.csv") %>% 
   dplyr::mutate(
      depth_maps_generation_quality = factor(
          depth_maps_generation_quality %>% 
            tolower() %>% 
            stringr::str_replace_all("ultrahigh", "ultra high")
          , ordered = TRUE
          , levels = c(
            "lowest"
            , "low"
            , "medium"
            , "high"
            , "ultra high"
          )
        ) %>% forcats::fct_rev()
      , depth_maps_generation_filtering_mode = factor(
          depth_maps_generation_filtering_mode %>% tolower()
          , ordered = TRUE
          , levels = c(
            "disabled"
            , "mild"
            , "moderate"
            , "aggressive"
          )
        ) %>% forcats::fct_rev()
    )
}
```

```{r}
ptcld_validation_data %>% dplyr::glimpse()
# summary of validation metrics
ptcld_validation_data %>% 
  dplyr::select(f_score, tree_height_m_mape, dbh_cm_mape) %>% 
  summary()
```

```{r, warning=FALSE, message=FALSE, echo=FALSE, include=FALSE}
remove(list = ls()[grep("_temp",ls())])
gc()
```

## Full Validation Summary Data

```{r, include=F, eval=FALSE}
# summary
ptcld_validation_data %>% 
  dplyr::filter(study_site == "KAIBAB_HIGH") %>% 
  dplyr::select(tidyselect::ends_with("f_score")) %>% 
  summary()
# 
read_field_data("KAIBAB_HIGH") %>% 
  ggplot(aes(x=field_tree_height_m)) + geom_density() + theme_light()

read_field_data("KAIBAB_HIGH") %>% 
  sf::st_drop_geometry() %>% 
  dplyr::select(field_tree_height_m) %>% 
  summary()

read_field_data("WA85_02") %>% 
  sf::st_drop_geometry() %>% 
  dplyr::select(field_tree_height_m) %>% 
  summary()
```

### True Positive, Commission, Ommission

Summary of tree true positive ($TP$), commission ($Co$), and omission ($Om$) detection by depth map quality and filtering mode

```{r, fig.height=11}
plt_fn_temp = function(site = study_site_list[1]){
  ptcld_validation_data %>%
    dplyr::filter(study_site == site) %>% 
    dplyr::mutate(
      plot_lab = forcats::fct_cross(depth_maps_generation_quality,depth_maps_generation_filtering_mode)
    ) %>% 
    dplyr::mutate(plot_lab = forcats::fct_reorder(
        plot_lab
        , .x = depth_maps_generation_quality
        , .fun = max
      ) %>% forcats::fct_rev()
    ) %>% 
    dplyr::select(
      software, plot_lab, 
      tidyselect::ends_with("_n_trees")
      & !tidyselect::starts_with("overstory_")
      & !tidyselect::starts_with("understory_")
    ) %>% 
    tidyr::pivot_longer(
      cols = -c(software,plot_lab)
      , values_drop_na = F
    ) %>% 
    dplyr::group_by(software,plot_lab) %>% 
    dplyr::mutate(
      field_uas_group = name %>% 
        stringr::str_remove_all("_n_trees") %>% 
        stringr::str_replace_all("_"," ") %>% 
        factor(
          ordered = T
          , levels = c(
            "true positive"
            , "commission"
            , "omission"
          )
        ) %>% forcats::fct_rev()
      , pct = dplyr::coalesce(value,0)/sum(dplyr::coalesce(value,0))
    ) %>%
    dplyr::ungroup() %>% 
  ggplot(
    mapping = aes(x = pct, y = plot_lab, fill=field_uas_group, group=field_uas_group)
  ) +
    geom_col(
      width = 0.7, alpha=0.8
    ) +
    geom_text(
      mapping = aes(
          label = scales::percent(ifelse(pct>=0.12,pct,NA), accuracy = 1)
          , fontface = "bold"
        )
      , position = position_stack(vjust = 0.5)
      , color = "black", size = 2.3
    ) +
    facet_grid(cols = vars(software)) +
    scale_fill_viridis_d(option = "cividis") +
    scale_x_continuous(labels = scales::percent_format()) +
    labs(
      fill = ""
      , y = ""
      , x = "Percent of Trees"
      # , title = "UAS and Stem-Mapped Tree Validation Summary"
      , subtitle = paste0("plot: ", site)
    ) +
    theme_light() +
    theme(
      legend.position = "top"
      , legend.direction  = "horizontal"
      , legend.title = element_text(size=7)
      , axis.title.x = element_text(size=8, face = "bold")
      , axis.title.y = element_blank()
      , axis.text.x = element_blank()
      , axis.text.y = element_text(color = "black",size=8)
      , axis.ticks.x = element_blank()
      , panel.grid.major.x = element_blank()
      , panel.grid.minor.x = element_blank()
      , strip.text = element_text(color = "black", face = "bold")
    ) +
    guides(
      fill = guide_legend(reverse = T, override.aes = list(alpha = 0.9))
    )
}
# map over sites
plt_list_temp = study_site_list %>% 
  purrr::map(plt_fn_temp)
# combine
patchwork::wrap_plots(plt_list_temp, ncol = 2, guides = "collect") &
  theme(legend.position="bottom")
```

### F-score

```{r, fig.height=11}
plt_fn_temp = function(site = study_site_list[1]){
ptcld_validation_data %>%
  dplyr::filter(study_site == site) %>% 
  dplyr::mutate(
    plot_lab = forcats::fct_cross(depth_maps_generation_quality,depth_maps_generation_filtering_mode)
  ) %>% 
  dplyr::mutate(plot_lab = forcats::fct_reorder(
      plot_lab
      , .x = depth_maps_generation_quality
      , .fun = max
    ) %>% forcats::fct_rev()
  ) %>% 
  dplyr::distinct(software,plot_lab,f_score) %>%
ggplot(
  mapping = aes(x = f_score, y = plot_lab, fill=f_score, label = scales::comma(f_score, accuracy = 0.01))
) +
  geom_col(
    width = 0.7
  ) +
  geom_text(
    color = "black", size = 2.3
    , hjust = -0.1
  ) +
  facet_grid(cols = vars(software)) +
  scale_fill_viridis_c(option = "mako", direction = -1, begin = 0.1, limits = c(0,max(ptcld_validation_data$f_score)*1.14)) +
  scale_x_continuous(limits = c(0,max(ptcld_validation_data$f_score)*1.14), breaks = NULL) +
  labs(
    fill = ""
    , y = ""
    , x = "F-Score"
    # , title = "UAS and Stem-Mapped Tree F-Score Summary"
    , subtitle = paste0("plot: ", site)
  ) +
  theme_light() +
  theme(
    legend.position = "none"
    , axis.title.x = element_text(size=8, face = "bold")
    , axis.title.y = element_blank()
    , axis.text.x = element_blank()
    , axis.text.y = element_text(color = "black",size=8)
    , axis.ticks.x = element_blank()
    , panel.grid.major.x = element_blank()
    , panel.grid.minor.x = element_blank()
    , strip.text = element_text(color = "black", face = "bold")
  ) +
  guides(
    fill = guide_legend(reverse = T, override.aes = list(alpha = 0.9))
  )
}
# plt_fn_temp()
# map over sites
plt_list_temp = study_site_list %>% 
  purrr::map(plt_fn_temp)
# combine
patchwork::wrap_plots(plt_list_temp, ncol = 2)
```

```{r, warning=FALSE, message=FALSE, echo=FALSE, include=FALSE}
remove(list = ls()[grep("_temp",ls())])
gc()
```

## Example Validation Process{#valid_ex}

Let's go through one example for **`r study_site_list[2]`**

### Data Load

Data load using functions defined above for **`r study_site_list[2]`**

```{r, results='hide', message=FALSE, warning=FALSE}
# validation plot boundary
plot_bound_temp = validation_plots %>% 
  dplyr::filter(study_site==study_site_list[2])
# read field data
field_data_temp = read_field_data(my_study_site = study_site_list[2])
# read_uas_data
uas_data_temp = read_uas_data(
  my_processing_id = ptcld_processing_data %>% 
    dplyr::filter(study_site==study_site_list[2]) %>% 
    dplyr::pull(processing_id) %>% 
    .[1]
  , my_crs = sf::st_crs(field_data_temp)
)
# true positive
true_positive_trees_temp = true_positive_trees_fn(uas_data = uas_data_temp, field_data = field_data_temp)
# field_uas_comparison_fn
field_uas_comparison_temp = field_uas_comparison_fn(
  uas_data = uas_data_temp
  , field_data = field_data_temp
  , true_positive_trees = true_positive_trees_temp 
  , plot_data = plot_bound_temp
)
```

get the orthomosaic (here using from ODM ultra-lowest) from the directory titled `field_validation/orthomosaic` with the name of the site as the file name (e.g.; "kaibab_high.tif")

```{r, results='hide', message=FALSE, warning=FALSE}
# let's load the orthomosaic for this site too
# put the orthomosaic images (here using from ODM ultra-lowest) in a folder 
# ...titled "field_validation/orthomosaic" with the name of the site as the file ("kaibab_high.tif")
ortho_list = list.files(
  "../data/field_validation/orthomosaic/"
  , pattern = ".*\\.(tif|tiff)$"
  , full.names = T
)
# load raster
ortho_rast = ortho_list %>% 
  purrr::pluck(
    ortho_list %>% 
      toupper() %>% 
      stringr::str_which(pattern = study_site_list[2]) %>% 
      .[1]
  ) %>% 
  terra::rast()
# aggregate to lower resolution if needed
if(terra::res(ortho_rast)[1]<0.5){
  ortho_rast = terra::aggregate(
    ortho_rast
    , fact = round(0.5/terra::res(ortho_rast)[1])
    , fun = "median"
    , cores = round(parallel::detectCores()/2)
  )
}
# ortho_rast
# terra::res(ortho_rast)
# ortho_rast %>%
#   terra::aggregate(2) %>%
#   terra::plotRGB(r = 1, g = 2, b = 3, stretch = "lin", colNA = "transparent")

# convert to stars
ortho_st = ortho_rast %>%  
  terra::subset(subset = c(1,2,3)) %>%
  terra::crop(
    # stand %>% 
    plot_bound_temp %>%
      sf::st_buffer(2) %>% 
      sf::st_bbox() %>% 
      sf::st_as_sfc() %>% 
      terra::vect() %>% 
      terra::project(terra::crs(ortho_rast))
  ) %>% 
  stars::st_as_stars()

# convert to rgb
ortho_rgb = stars::st_rgb(
  ortho_st[,,,1:3]
  , dimension = 3
  , use_alpha = FALSE
  # , stretch = "histogram"
  , probs = c(0.005, 0.995)
  , stretch = "percent"
)
```

what is all this data?

### Orthomosaic Data

`ortho_rast`

```{r}
ortho_rast
```

plot it

```{r}
# ggplot rgb
  plt_rgb = ggplot() +
    stars::geom_stars(data = ortho_rgb[]) +
    scale_fill_identity(na.value = "transparent") + # !!! don't take this out or RGB plot will kill your computer
    # add plot boundary
    geom_sf(
      data =  plot_bound_temp %>%
        terra::vect() %>% 
        terra::project(terra::crs(ortho_rast)) %>% 
        sf::st_as_sf()
      , alpha = 0
      , lwd = 1.2
      , color = "blue"
    ) +
    scale_x_continuous(expand = c(0, 0)) +
    scale_y_continuous(expand = c(0, 0)) +
    labs(
      x = ""
      , y = ""
    ) +
    theme_void()
# plot + boundary
plt_rgb
```


### Field Data

`field_data`

```{r}
# field_data
field_data_temp %>% dplyr::glimpse()
```

plot it

```{r}
plt_field_data_temp = plt_rgb + 
  ggnewscale::new_scale_fill() +
  geom_sf(
    data = field_data_temp %>% 
      terra::vect() %>% 
      terra::project(terra::crs(ortho_rast)) %>% 
      sf::st_as_sf()
    , mapping = aes(fill = field_tree_height_m)
    , shape = 21
    , size = 1.1
  ) +
  scale_fill_viridis_c(
    option="plasma", alpha = 0.6, name = "ht. (m)"
    , limits = c(
      min(field_data_temp$field_tree_height_m, na.rm = T)
      , max(field_data_temp$field_tree_height_m, na.rm = T)
    )
    , breaks = scales::breaks_extended(6)
  ) + 
  labs(subtitle = "field mapped trees")
# plot
plt_field_data_temp
```

### UAS Data

`uas_data`

```{r}
# uas_data
uas_data_temp %>% dplyr::glimpse()
```

plot it

```{r}
plt_uas_data_temp = plt_rgb + 
  ggnewscale::new_scale_fill() +
  geom_sf(
    data = uas_data_temp %>% 
      sf::st_transform(sf::st_crs(plot_bound_temp)) %>% 
      sf::st_intersection(plot_bound_temp %>% sf::st_buffer(3)) %>% 
      terra::vect() %>% 
      terra::project(terra::crs(ortho_rast)) %>% 
      sf::st_as_sf()
    , mapping = aes(fill = tree_height_m)
    , shape = 21
    , size = 1.1
  ) +
  scale_fill_viridis_c(
    option="plasma", alpha = 0.6, name = "ht. (m)"
    , limits = c(
      min(field_data_temp$field_tree_height_m, na.rm = T)
      , max(field_data_temp$field_tree_height_m, na.rm = T)
    )
    , breaks = scales::breaks_extended(6)
  ) + 
  labs(subtitle = "UAS detected trees")
# plot
plt_uas_data_temp
```

### True Positives

`true_positive_trees`

```{r}
# true_positive_trees
true_positive_trees_temp %>% dplyr::glimpse()
```

### Field & UAS Comparison

`field_uas_comparison`

```{r}
# field_uas_comparison
field_uas_comparison_temp %>% dplyr::glimpse()
```

no geometry, let's attach it

```{r}
field_uas_comparison_temp = field_uas_comparison_temp %>% 
  dplyr::mutate(
    x = ifelse(!is.na(field_tree_utm_x), field_tree_utm_x, uas_tree_utm_x)
    , y = ifelse(!is.na(field_tree_utm_x), field_tree_utm_y, uas_tree_utm_y)
  ) %>% 
  sf::st_as_sf(
    coords = c("x", "y")
    , crs = sf::st_crs(field_data_temp)
    , remove=T
  )
```

plot it

```{r}
plt_comparison_temp = plt_rgb + 
  ggnewscale::new_scale_fill() +
  geom_sf(
    data = field_uas_comparison_temp %>% 
      terra::vect() %>% 
      terra::project(terra::crs(ortho_rast)) %>% 
      sf::st_as_sf()
    , mapping = aes(fill = field_uas_group)
    , color = "black"
    , shape = 21
    , size = 1.1
  ) +
  scale_fill_viridis_d(option = "cividis", name = "trees", drop = F, alpha = 0.7) +
  labs(subtitle = "field & UAS comparison trees")
# plot
plt_comparison_temp
```

### Combine Plots

combine these

```{r, fig.height=9}
(plt_field_data_temp + theme(legend.position = "none") + plt_uas_data_temp) / plt_comparison_temp
ggplot2::ggsave("../data/field_uas_comparison.jpg", width = 8, height = 9)
```

we can also view these with satellite imagery which is *not* what the UAS-derived tree detections are from but can be a good viewing tool

```{r, fig.height=6}
# load chm
chm_temp = ptcld_processing_data %>% 
  dplyr::filter(study_site==study_site_list[2]) %>% 
  dplyr::filter(dplyr::row_number()==1) %>% 
  dplyr::mutate(
    f = paste0(
      processed_data_dir
      , "/"
      , file_name
      , "_chm_0.25m.tif"
    )
  ) %>% 
  dplyr::pull(f) %>% 
  terra::rast() %>% 
  terra::aggregate(2) %>% 
  stars::st_as_stars()

# map it
mapview::mapviewOptions(basemaps = c("Esri.WorldImagery", "OpenStreetMap"))
mapview::mapview(
  plot_bound_temp
  , color = "blue"
  , lwd = 2
  , alpha.regions = 0
  , layer.name = "boundary"
  , label = FALSE
  , legend = FALSE
  , popup = FALSE
) +
# aggregate raster and map
  mapview::mapview(
    chm_temp 
    , layer.name = "canopy ht. (m)"
    , col.regions = viridis::plasma(n=50)
    , alpha.regions = 0.7
    , na.color = "transparent"
  ) +
# validation
  mapview::mapview(
    field_uas_comparison_temp
    , zcol = "field_uas_group"
    , col.regions = viridis::cividis(n=3)
    , cex = 2
    , alpha.regions = 0.8
    , layer.name = "validation"
    , popup = leafpop::popupTable(
      field_uas_comparison_temp
      , zcol = c(
        "field_uas_group"
        , "uas_tree_height_m"
        , "field_tree_height_m"
        , "uas_dbh_cm"
        , "field_dbh_cm"
      )
      , row.numbers = FALSE
      , feature.id = FALSE
    )
  ) + 
# fld
  mapview::mapview(
    field_data_temp
    , zcol = "field_tree_height_m"
    , cex = 2
    , alpha.regions = 0.8
    , layer.name = "field"
    , hide = T
  )+ 
# uas
  mapview::mapview(
    uas_data_temp
    , zcol = "tree_height_m"
    , cex = 2
    , alpha.regions = 0.8
    , layer.name = "uas"
    , hide = T
  )
```

```{r, include=FALSE, eval=FALSE}
mapview::viewRGB(
  raster::stack(
    raster::raster(ortho_rast["red"])
    , raster::raster(ortho_rast["green"])
    , raster::raster(ortho_rast["blue"]) 
  )
  , r = 1, g = 2, b = 3
  , layer.name = "orthomosaic"
  , na.color = "transparent"
)
```


### Height vs. DBH of $Tp$, $Co$, $Om$

```{r fld-dta-sum-htdbh}
field_uas_comparison_temp %>% 
  sf::st_drop_geometry() %>% 
  dplyr::mutate(
    dbh_temp = dplyr::coalesce(field_dbh_cm, uas_dbh_cm)
    , ht_temp = dplyr::coalesce(field_tree_height_m, uas_tree_height_m)
  ) %>% 
  ggplot(
    mapping = aes(x = ht_temp, y = dbh_temp, color = field_uas_group)
  ) +
    geom_point(
      mapping = aes(shape = field_uas_group)
      , alpha=0.8
      , size=2
    ) +
    scale_color_viridis_d(option = "cividis", drop = F) +
    scale_x_continuous(breaks = scales::extended_breaks(n=8)) +
    scale_y_continuous(breaks = scales::extended_breaks(n=8)) +
    labs(
      color = "detection"
      , shape = "detection"
      , y = "DBH (cm)"
      , x = "Tree Ht. (m)"
      , title = "UAS and Stem-Mapped Tree Validation Summary"
      , subtitle = "height and DBH relationship"
    ) +
    theme_light() +
    theme(
      legend.position = "top"
      , legend.direction  = "horizontal"
      , legend.title = element_blank()
    ) +
    guides(
      color = guide_legend(reverse = T, override.aes = list(alpha = 0.9, size = 5))
      , shape = guide_legend(reverse = T)
    )  
```

### Height and DBH Distribution $Tp$, $Co$, $Om$

```{r fld-dta-sum-htdbh-dist}
field_uas_comparison_temp %>% 
  sf::st_drop_geometry() %>% 
  dplyr::mutate(
    dbh = dplyr::coalesce(field_dbh_cm, uas_dbh_cm)
    , height = dplyr::coalesce(field_tree_height_m, uas_tree_height_m)
  ) %>% 
  dplyr::select(dbh, height, field_uas_group) %>% 
  tidyr::pivot_longer(cols = -c(field_uas_group), names_to = "metric", values_to = "value") %>% 
  dplyr::group_by(field_uas_group,metric) %>% 
  dplyr::mutate(
    metric = dplyr::case_when(
      metric == "dbh" ~ "DBH (cm)"
      , metric == "height" ~ "Height (m)"
    )
    , n_rows = dplyr::n()
    , plot_lab = paste0(
      field_uas_group
      ," (n=", scales::comma(n_rows,accuracy=1),")"
    )
  ) %>% 
  ggplot(mapping = aes(x = value, y = plot_lab, fill = field_uas_group)) +
    geom_violin() +
    geom_boxplot(width = 0.1, outlier.shape = NA, color = "gray66") +
    facet_grid(cols = vars(metric), scales = "free_x") +
    scale_fill_viridis_d(option = "cividis", drop = F) +
    scale_x_continuous(breaks = scales::extended_breaks(n=8)) +
    labs(
      fill = ""
      , y = ""
      , x = ""
      , title = "UAS and Stem-Mapped Tree Validation Summary"
      , subtitle = "height and DBH distribution comparison"
    ) +
    theme_light() +
    theme(
      legend.position = "none"
      , axis.title.x = element_text(size=10, face = "bold")
      , axis.title.y = element_blank()
      , axis.text.y = element_text(color = "black",size=10, face = "bold", hjust = 0)
      , strip.text = element_text(color = "black", size = 12)
      , strip.background = element_rect(fill = "gray88")
    )
```

### Detected Overstory ($TP$) Height Difference

Detected overstory tree ($TP$) height reliability.

```{r fld-dta-sum-ht}
field_uas_comparison_temp %>%
  sf::st_drop_geometry() %>% 
  dplyr::filter(field_uas_group == "true positive") %>%
  dplyr::group_by(field_uas_group) %>% 
  dplyr::mutate(
    plot_lab = paste0(
      field_uas_group
      ," (n=", scales::comma(dplyr::n(),accuracy=1),")"
    )
    , med = median(height_diff_pct, na.rm=T)
    , color_box = med<0
  ) %>% 
  ggplot(mapping = aes(x = height_diff_pct)) + # height_diff_pct
  # ggplot(mapping = aes(x = height_diff_pct, y = plot_lab )) + # height_diff_pct
    geom_vline(xintercept = 0, color = "gray22", lwd = 1) +
    # geom_boxplot(mapping = aes(fill = color_box), alpha = 0.8, width = 0.7, outlier.shape = NA) +
    geom_density(mapping = aes(fill = color_box), alpha = 0.8) +
    geom_vline(aes(xintercept = med), color = "gray66", linetype = "dashed") + # ymin = -Inf, ymax = Inf
    geom_text(
      aes(x = med, y = 0, label = paste0("median: ",scales::percent(med, accuracy = 0.1)))
      , hjust = -0.1, vjust = 1
    ) +
    scale_fill_manual(values = c("steelblue", "coral")) +
    scale_x_continuous(
      labels = scales::percent_format()
      , breaks = scales::extended_breaks(n=8)
      , limits = c(
        -max(field_uas_comparison_temp$abs_height_diff_pct, na.rm = T)
        , max(field_uas_comparison_temp$abs_height_diff_pct, na.rm = T)
      )
    ) +
    scale_y_continuous(NULL, breaks = NULL) +
    labs(
      fill = ""
      , y = ""
      , x = "Percent Difference in Height"
      , title = "Detected Overstory Height Difference"
      , caption = "-values = UAS<field | +values = UAS>field"
    ) +
    theme_light() +
    theme(
      legend.position = "none"
      , axis.title.x = element_text(size=10, face = "bold")
      , axis.title.y = element_blank()
      , axis.text.y = element_text(color = "black",size=10, face = "bold", hjust = 0)
    )
```

### Detected Overstory ($TP$) DBH Difference

Detected overstory tree ($TP$) DBH reliability.

```{r fld-dta-sum-dbh}
field_uas_comparison_temp %>%
  sf::st_drop_geometry() %>% 
  dplyr::filter(field_uas_group == "true positive") %>%
  dplyr::group_by(field_uas_group) %>% 
  dplyr::mutate(
    plot_lab = paste0(
      field_uas_group
      ," (n=", scales::comma(dplyr::n(),accuracy=1),")"
    )
    , med = median(dbh_diff_pct, na.rm=T)
    , color_box = med<0
  ) %>% 
  ggplot(mapping = aes(x = dbh_diff_pct)) + # height_diff_pct
    geom_vline(xintercept = 0, color = "gray22", lwd = 1) +
    geom_density(mapping = aes(fill = color_box), alpha = 0.8) +
    geom_vline(aes(xintercept = med), color = "gray66", linetype = "dashed") + # ymin = -Inf, ymax = Inf
    geom_text(
      aes(x = med, y = 0, label = paste0("median: ",scales::percent(med, accuracy = 0.1)))
      , hjust = -0.1, vjust = 1
    ) +
    scale_fill_manual(values = c("steelblue", "coral")) +
    scale_x_continuous(
      labels = scales::percent_format()
      , breaks = scales::extended_breaks(n=8)
      , limits = c(-2,2)
    ) +
    scale_y_continuous(NULL, breaks = NULL) +
    labs(
      fill = ""
      , y = ""
      , x = "Percent Difference in DBH"
      , title = "Detected Overstory DBH Difference"
      , caption = "-values = UAS<field | +values = UAS>field"
    ) +
    theme_light() +
    theme(
      legend.position = "none"
      , axis.title.x = element_text(size=10, face = "bold")
      , axis.title.y = element_blank()
      , axis.text.y = element_text(color = "black",size=10, face = "bold", hjust = 0)
    )

```

#### Detected Overstory ($TP$) Reliability

```{r fld-dta-sum-rmse, results='asis'}
dbh_f_temp = field_uas_comparison_temp %>% dplyr::filter(field_uas_group=="true positive") %>% dplyr::pull(field_dbh_cm)
dbh_u_temp = field_uas_comparison_temp %>% dplyr::filter(field_uas_group=="true positive") %>% dplyr::pull(uas_dbh_cm)
ht_f_temp = field_uas_comparison_temp %>% dplyr::filter(field_uas_group=="true positive") %>% dplyr::pull(field_tree_height_m)
ht_u_temp = field_uas_comparison_temp %>% dplyr::filter(field_uas_group=="true positive") %>% dplyr::pull(uas_tree_height_m)

data.frame(
  mae_dbh = Metrics::mae(
    dbh_f_temp
    , dbh_u_temp
  )
  , mape_dbh = Metrics::mape(
    dbh_f_temp
    , dbh_u_temp
  )
  , rmse_dbh = Metrics::rmse(
    dbh_f_temp
    , dbh_u_temp
  )
    ## height
  , mae_height = Metrics::mae(
    ht_f_temp
    , ht_u_temp
  )
  , mape_height = Metrics::mape(
    ht_f_temp
    , ht_u_temp
  )
  , rmse_height = Metrics::rmse(
    ht_f_temp
    , ht_u_temp
  )
) %>% 
  tidyr::pivot_longer(dplyr::everything()) %>% 
  tidyr::separate_wider_delim(cols = name, delim = "_", names = c("error", "metric")) %>% 
  tidyr::pivot_wider(names_from = error, values_from = value) %>% 
  dplyr::mutate(
    metric = dplyr::case_when(
      metric == "dbh" ~ "DBH (cm)"
      , metric == "height" ~ "Height (m)"
    )
    , n = field_uas_comparison_temp %>% dplyr::filter(field_uas_group=="true positive") %>% nrow()
  ) %>% 
    kableExtra::kbl(
      caption = "Detected overstory tree height and DBH prediction performance"
      , col.names = c(
        " "
        , "Mean Abs. Error"
        , "Mean Abs. Percent Error"
        , "Root Mean Squared Error"
        , "N"
      )
      , digits = 2
    ) %>% 
    kableExtra::kable_styling()

```

```{r, warning=FALSE, message=FALSE, echo=FALSE, include=FALSE}
remove(list = ls()[grep("_temp",ls())])
remove(list = ls()[grep("ortho_",ls())])
gc()
```

## Mapped validation for all sites

[Above](#valid_ex), we reviewed the process for matching field mapped trees to UAS detected trees to determine true positive (TP) detections, commission (Co), and omission (Om) trees.

Here, we visualize the location of the classified trees for each study site.

We're only going to use point clouds generated via Metashape with the "high" point cloud generation quality setting and the "mild" filtering setting.

### Plotting Function

Let's define a plotting function to map sites over

```{r}
plt_validation_fn = function(my_site = study_site_list[1]){
  ############################################
  # validation plot boundary
  ############################################
    plot_bound_temp = validation_plots %>% 
      dplyr::filter(study_site==my_site)
  ############################################
  # field data
  ############################################
    field_data_temp = read_field_data(my_study_site = my_site)
  ############################################
  # orthomosaic
  ############################################
    ortho_list = list.files(
      "../data/field_validation/orthomosaic/"
      , pattern = ".*\\.(tif|tiff)$"
      , full.names = T
    )
    # load raster
    ortho_rast = ortho_list %>% 
      purrr::pluck(
        ortho_list %>% 
          toupper() %>% 
          stringr::str_which(pattern = my_site) %>% 
          .[1]
      ) %>% 
      terra::rast()
    # aggregate to lower resolution if needed
    if(terra::res(ortho_rast)[1]<0.5){
      ortho_rast = terra::aggregate(
        ortho_rast
        , fact = round(0.5/terra::res(ortho_rast)[1])
        , fun = "median"
        , cores = round(parallel::detectCores()/2)
      )
    }
    # convert to stars
    ortho_st = ortho_rast %>%  
      terra::subset(subset = c(1,2,3)) %>%
      terra::crop(
        # stand %>% 
        plot_bound_temp %>%
          sf::st_buffer(2) %>% 
          sf::st_bbox() %>% 
          sf::st_as_sfc() %>% 
          terra::vect() %>% 
          terra::project(terra::crs(ortho_rast))
      ) %>% 
      stars::st_as_stars()
    
    # convert to rgb
    ortho_rgb = stars::st_rgb(
      ortho_st[,,,1:3]
      , dimension = 3
      , use_alpha = FALSE
      # , stretch = "histogram"
      , probs = c(0.005, 0.995)
      , stretch = "percent"
    )
  ############################################
  # load validation data ftw
  ############################################
  field_uas_comparison_temp = ptcld_validation_data %>% 
    dplyr::filter(
      study_site == my_site
      & tolower(software) == "metashape"
      & tolower(depth_maps_generation_quality) == "high"
      & tolower(depth_maps_generation_filtering_mode) == "mild"
    ) %>% 
    dplyr::pull(validation_file_full_path) %>% 
    readr::read_csv() %>% 
    dplyr::mutate(
      field_uas_group = factor(
          field_uas_group
          , ordered = T
          , levels = c(
            "true positive"
            , "commission"
            , "omission"
          )
        ) %>% forcats::fct_rev()
      , overstory_understory_grp = overstory_understory_grp %>% factor()
      , x = ifelse(!is.na(field_tree_utm_x), field_tree_utm_x, uas_tree_utm_x)
      , y = ifelse(!is.na(field_tree_utm_x), field_tree_utm_y, uas_tree_utm_y)
    ) %>% 
    sf::st_as_sf(
      coords = c("x", "y")
      , crs = sf::st_crs(field_data_temp)
      , remove=T
    )  
  ############################################
  # plot it all
  ############################################
    # make a label
    hey_lab = ptcld_validation_data %>% 
      dplyr::filter(
        study_site == my_site
        & tolower(software) == "metashape"
        & tolower(depth_maps_generation_quality) == "high"
        & tolower(depth_maps_generation_filtering_mode) == "mild"
      ) %>% 
      dplyr::mutate(
        hey_lab = paste0(
          "true positive: ", scales::comma(true_positive_n_trees, accuracy = 1)
          , "\ncommission: ", scales::comma(commission_n_trees, accuracy = 1)
          , "\nomission: ", scales::comma(omission_n_trees, accuracy = 1)
          , "\n(F-score: ", scales::comma(f_score, accuracy = 0.01), ")"
        )
      ) %>% 
      dplyr::pull(hey_lab)
    # ggplot rgb
      plt_rgb = ggplot() +
        stars::geom_stars(data = ortho_rgb[]) +
        scale_fill_identity(na.value = "transparent") + # !!! don't take this out or RGB plot will kill your computer
        # add plot boundary
        geom_sf(
          data =  plot_bound_temp %>%
            terra::vect() %>% 
            terra::project(terra::crs(ortho_rast)) %>% 
            sf::st_as_sf()
          , alpha = 0
          , lwd = 1.2
          , color = "blue"
        ) +
        scale_x_continuous(expand = c(0, 0)) +
        scale_y_continuous(expand = c(0, 0)) +
        labs(
          x = ""
          , y = ""
        ) +
        theme_void()
    # combine
      plt_comparison_temp = plt_rgb + 
        ggnewscale::new_scale_fill() +
        geom_sf(
          data = field_uas_comparison_temp %>% 
            terra::vect() %>% 
            terra::project(terra::crs(ortho_rast)) %>% 
            sf::st_as_sf()
          , mapping = aes(fill = field_uas_group)
          , color = "black"
          , shape = 21
          , size = 1.4
        ) +
        scale_fill_viridis_d(option = "cividis", name = "trees", drop = F, alpha = 0.8) +
        labs(
          title = paste0("plot: ", my_site)
          , subtitle = hey_lab
        ) +
        theme(legend.position = "bottom", legend.direction = "horizontal")
    # return
    return(plt_comparison_temp)
}
# plt_validation_fn(study_site_list[5])
```

apply the function

```{r, warning=FALSE, message=FALSE, results='hide'}
hey_list_temp = study_site_list %>% 
  purrr::map(plt_validation_fn)
```

### Validation Maps

```{r}
hey_list_temp
```

### Validation Maps Combined

```{r, fig.height=11}
# combine
patchwork::wrap_plots(hey_list_temp, ncol = 2, guides = "collect") &
  theme(legend.position="bottom", legend.direction = "horizontal", plot.title = element_text(size = 8), plot.subtitle = element_text(size = 7))
```

## Field Data Descriptive Statistics

Load and combine all field data sets

```{r, warning=FALSE, message=FALSE, results='hide'}
field_data = study_site_list %>% 
  purrr::map(function(x){
    read_field_data(x) %>% sf::st_drop_geometry()
  }) %>% 
  dplyr::bind_rows() %>% 
  dplyr::left_join(
    validation_plots %>% 
      dplyr::mutate(ha = sf::st_area(.) %>% as.numeric() %>% `/`(10000)) %>% 
      sf::st_drop_geometry() %>% 
      dplyr::select(study_site, ha)
    , by = dplyr::join_by("study_site")
  )
```

### Table of Height Summary Statistics

```{r}
field_data %>% 
  dplyr::group_by(study_site,ha) %>% 
  dplyr::summarise(
    n_trees = dplyr::n()
    , min_tree_height_m = min(field_tree_height_m, na.rm = T)
    , max_tree_height_m = max(field_tree_height_m, na.rm = T)
    , median_tree_height_m = median(field_tree_height_m, na.rm = T)
    , tree_height_m_25 = quantile(field_tree_height_m, probs = 0.25)
    , tree_height_m_75 = quantile(field_tree_height_m, probs = 0.75)
  ) %>% 
  dplyr::mutate(
    tph = (n_trees/ha) %>% scales::comma(accuracy = 1)
    ,  n_trees = n_trees %>% scales::comma(accuracy = 1)
  ) %>% 
  dplyr::relocate(tph, .after = n_trees) %>% 
  dplyr::select(-c(ha)) %>% 
  kableExtra::kbl(
    caption = "Field Data: Table of Height Summary Statistics"
    , col.names = c(
      "Site"
      , "# trees"
      , "TPH"
      , "Minimum"
      , "Maximum"
      , "Median"
      , "25th percentile"
      , "75th percentile"
    )
    , digits = 1
  ) %>% 
  kableExtra::add_header_above(
    c(
      " " = 3
      , "Tree Height (meters)"=5
    )
  ) %>%
  kableExtra::kable_styling()


```

### Table of DBH Summary Statistics

```{r}
field_data %>% 
  dplyr::group_by(study_site,ha) %>% 
  dplyr::summarise(
    n_trees = dplyr::n()
    , min_dbh_cm = min(field_dbh_cm, na.rm = T)
    , max_dbh_cm = max(field_dbh_cm, na.rm = T)
    , median_dbh_cm = median(field_dbh_cm, na.rm = T)
    , dbh_cm_25 = quantile(field_dbh_cm, probs = 0.25)
    , dbh_cm_75 = quantile(field_dbh_cm, probs = 0.75)
  ) %>% 
  dplyr::mutate(
    tph = (n_trees/ha) %>% scales::comma(accuracy = 1)
    ,  n_trees = n_trees %>% scales::comma(accuracy = 1)
  ) %>% 
  dplyr::relocate(tph, .after = n_trees) %>% 
  dplyr::select(-c(ha)) %>% 
  kableExtra::kbl(
    caption = "Field Data: Table of DBH Summary Statistics"
    , col.names = c(
      "Site"
      , "# trees"
      , "TPH"
      , "Minimum"
      , "Maximum"
      , "Median"
      , "25th percentile"
      , "75th percentile"
    )
    , digits = 1
  ) %>% 
  kableExtra::add_header_above(
    c(
      " " = 3
      , "Tree DBH (cm)"=5
    )
  ) %>%
  kableExtra::kable_styling()

```

### Height and DBH Distribution

```{r}
field_data %>% 
  dplyr::select(study_site, field_dbh_cm, field_tree_height_m) %>% #
  tidyr::pivot_longer(
    cols = -c(study_site)
  ) %>% 
  dplyr::mutate(
    name = dplyr::case_when(
      name == "field_dbh_cm" ~ "DBH (cm)"
      , name == "field_tree_height_m" ~ "Height (m)"
      , T ~ "error"
    )
  ) %>% 
  # plot
  ggplot(mapping = aes(x = value, y = study_site)) +
    geom_violin(mapping = aes(fill = name), color = NA) +
    geom_boxplot(width = 0.1, outlier.shape = NA, fill = NA, color = "black") +
    facet_grid(cols = vars(name), scales = "free_x") +
    scale_fill_manual(values = c("skyblue4", "skyblue2")) +
    scale_x_continuous(breaks = scales::breaks_extended(8)) +
    labs(x = "", y = "") +
    theme_light() +
    theme(legend.position = "none", strip.text = element_text(color = "black", face = "bold"))
```

```{r, warning=FALSE, message=FALSE, echo=FALSE, include=FALSE}
remove(list = ls()[grep("_temp",ls())])
remove(
  field_data, validation_data, validation_plots, my_dbh_estimate
  , read_field_data, read_uas_data, true_positive_trees_fn
  , validate_file_fn, field_uas_comparison_fn, full_validation_fn
)
gc()
```

## Summary of Dependent Variables

descriptive statistics of potential dependent variables

```{r}
ptcld_validation_data %>% 
  dplyr::select(
    f_score, basal_area_pct_error, basal_area_abs_pct_error
    , tree_height_m_me, tree_height_m_rmse, dbh_cm_me, dbh_cm_rmse
  ) %>% 
  dplyr::ungroup() %>% 
  dplyr::summarise(
    dplyr::across(
      .cols = tidyselect::everything()
      , .fns = list(
        mean = ~ mean(.x, na.rm=T)
        , median = ~ median(.x, na.rm=T)
        , sd = ~ sd(.x, na.rm=T)
        , min = ~ min(.x, na.rm=T)
        , max = ~ max(.x, na.rm=T)
      )
      , .names = "{.fn}_xxx_{.col}"
    )
    , n = dplyr::n()
  ) %>% 
  tidyr::pivot_longer(cols = -n) %>% 
  tidyr::separate(col = name, sep = "_xxx_", into = c("stat", "metric")) %>% 
  # format
  dplyr::mutate(
    value = dplyr::case_when(
      stringr::str_detect(metric, "_pct_") ~ scales::percent(value, accuracy = 0.1)
      , metric == "f_score" ~ scales::number(value, accuracy = 0.01)
      , T ~ scales::number(value, accuracy = 0.1)
    )
  ) %>% 
  tidyr::pivot_wider(names_from = stat, values_from = value) %>% 
  dplyr::relocate(c(metric, n)) %>% 
  # dplyr::mutate(
  #   range = paste0(
  #     min, " to ", max
  #   )
  # ) %>% 
  # select(-c(min, max)) 
  kableExtra::kbl(
    digits = 2
    , caption = "SfM data set summary statistics of potential dependent variable metrics"
  ) %>% 
  kableExtra::kable_styling()
```

